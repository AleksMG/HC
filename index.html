<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Crypto S-Box with NIST Tests</title>
    <style>
        body { font-family: monospace; margin: 20px; background: #0d1117; color: #c9d1d9; }
        .container { max-width: 1400px; margin: 0 auto; }
        textarea, input, select { width: 100%; background: #161b22; color: #c9d1d9; border: 1px solid #30363d; padding: 8px; margin: 5px 0; }
        button { background: #238636; color: white; border: none; padding: 10px 15px; cursor: pointer; margin: 5px; }
        button:hover { background: #2ea043; }
        .output { background: #161b22; padding: 15px; margin: 10px 0; border-radius: 5px; }
        .row { display: flex; margin: 10px 0; gap: 20px; }
        .col { flex: 1; }
        .section { border: 1px solid #30363d; padding: 15px; border-radius: 5px; margin: 10px 0; }
        .config { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
        .test-results { max-height: 300px; overflow-y: auto; }
        .test-pass { color: #3fb950; }
        .test-fail { color: #f85149; }
        .test-warning { color: #d29922; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ”’ Enhanced Crypto S-Box with NIST Tests</h1>
        
        <div class="section">
            <h3>Key Configuration:</h3>
            <input type="password" id="keyInput" placeholder="Enter encryption key" value="my-secret-key">
            <button onclick="generateSBox()">Generate S-Box from Key</button>
            <div class="output" id="status">S-Box not generated yet</div>
        </div>

        <div class="section">
            <h3>Encryption Settings:</h3>
            <div class="config">
                <div>
                    <label>Rounds:</label>
                    <select id="roundsCount">
                        <option value="1">1 round</option>
                        <option value="2">2 rounds</option>
                        <option value="3">3 rounds</option>
                        <option value="4" selected>4 rounds</option>
                    </select>
                </div>
                <div>
                    <label>CBC Mode:</label>
                    <select id="cbcMode">
                        <option value="off">OFF</option>
                        <option value="on">ON</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col">
                <div class="section">
                    <h3>Encryption:</h3>
                    <textarea id="encryptInput" rows="4" placeholder="Enter text to encrypt">The quick brown fox jumps over the lazy dog 1234567890!@#$%^&*()</textarea>
                    <button onclick="encryptData()">Encrypt</button>
                    <button onclick="runNISTTests()">Run NIST Tests</button>
                    <div class="output" id="encryptOutput">Encrypted output will appear here</div>
                </div>
            </div>
            
            <div class="col">
                <div class="section">
                    <h3>Decryption:</h3>
                    <textarea id="decryptInput" rows="4" placeholder="Paste encrypted hex here"></textarea>
                    <button onclick="decryptData()">Decrypt</button>
                    <div class="output" id="decryptOutput">Decrypted output will appear here</div>
                </div>
            </div>
        </div>

        <div class="section">
            <h3>NIST Statistical Tests Results:</h3>
            <div class="output test-results" id="nistResults">Test results will appear here</div>
        </div>
    </div>

    <script>
        let bytePermutation = null;
        let homophonicSBox = null;
        let inverseBytePermutation = null;
        let inverseHomophonicSBox = null;
        let roundKeys = [];
        let lastEncryptedBytes = [];

        // NIST Test Functions
        const NISTTests = {
            // 1. Frequency (Monobit) Test
            frequencyTest: function(data) {
                let sum = 0;
                for (let i = 0; i < data.length; i++) {
                    for (let j = 0; j < 8; j++) {
                        const bit = (data[i] >> j) & 1;
                        sum += bit === 1 ? 1 : -1;
                    }
                }
                const s = Math.abs(sum) / Math.sqrt(data.length * 8);
                const pValue = this.erfc(s / Math.sqrt(2));
                return { passed: pValue >= 0.01, pValue, test: "Frequency (Monobit) Test" };
            },

            // 2. Runs Test
            runsTest: function(data) {
                let n = data.length * 8;
                let pi = 0;
                for (let i = 0; i < data.length; i++) {
                    for (let j = 0; j < 8; j++) {
                        pi += (data[i] >> j) & 1;
                    }
                }
                pi /= n;
                
                if (Math.abs(pi - 0.5) >= 2 / Math.sqrt(n)) {
                    return { passed: false, pValue: 0, test: "Runs Test" };
                }

                let runs = 1;
                let currentBit = (data[0] & 1);
                for (let i = 0; i < data.length; i++) {
                    for (let j = 0; j < 8; j++) {
                        if (i === 0 && j === 0) continue;
                        const bit = (data[i] >> j) & 1;
                        if (bit !== currentBit) {
                            runs++;
                            currentBit = bit;
                        }
                    }
                }

                const pValue = this.erfc(Math.abs(runs - 2 * n * pi * (1 - pi)) / 
                                      (2 * Math.sqrt(2 * n) * pi * (1 - pi)));
                return { passed: pValue >= 0.01, pValue, test: "Runs Test" };
            },

            // 3. Binary Derivative Test
            binaryDerivativeTest: function(data) {
                let changes = 0;
                let total = 0;
                for (let i = 0; i < data.length - 1; i++) {
                    const xor = data[i] ^ data[i + 1];
                    for (let j = 0; j < 8; j++) {
                        if ((xor >> j) & 1) changes++;
                        total++;
                    }
                }
                const ratio = changes / total;
                return { 
                    passed: Math.abs(ratio - 0.5) < 0.05, 
                    pValue: Math.abs(ratio - 0.5), 
                    test: "Binary Derivative Test",
                    ratio: ratio
                };
            },

            // 4. Entropy Test
            entropyTest: function(data) {
                const frequency = new Array(256).fill(0);
                for (const byte of data) {
                    frequency[byte]++;
                }
                
                let entropy = 0;
                for (let i = 0; i < 256; i++) {
                    if (frequency[i] > 0) {
                        const p = frequency[i] / data.length;
                        entropy -= p * Math.log2(p);
                    }
                }
                
                const maxEntropy = 8; // Maximum for bytes
                return { 
                    passed: entropy > 7.9, 
                    pValue: entropy, 
                    test: "Entropy Test",
                    entropy: entropy
                };
            },

            // 5. Chi-square Test
            chiSquareTest: function(data) {
                const expected = data.length / 256;
                const frequency = new Array(256).fill(0);
                for (const byte of data) {
                    frequency[byte]++;
                }
                
                let chi2 = 0;
                for (let i = 0; i < 256; i++) {
                    chi2 += Math.pow(frequency[i] - expected, 2) / expected;
                }
                
                // p-value from chi-square distribution with 255 degrees of freedom
                const pValue = this.chi2cdf(chi2, 255);
                return { passed: pValue >= 0.01, pValue, test: "Chi-square Test", chi2 };
            },

            // 6. Pi Estimation Test (Monte Carlo)
            piEstimationTest: function(data) {
                if (data.length < 4) return { passed: false, pValue: 0, test: "Pi Test" };
                
                let inside = 0;
                let total = 0;
                
                for (let i = 0; i < data.length - 3; i += 4) {
                    const x = (data[i] / 255) * 2 - 1;
                    const y = (data[i + 1] / 255) * 2 - 1;
                    const x2 = (data[i + 2] / 255) * 2 - 1;
                    const y2 = (data[i + 3] / 255) * 2 - 1;
                    
                    if (x * x + y * y <= 1) inside++;
                    if (x2 * x2 + y2 * y2 <= 1) inside++;
                    total += 2;
                }
                
                const estimatedPi = (4 * inside) / total;
                const error = Math.abs(estimatedPi - Math.PI);
                return { 
                    passed: error < 0.05, 
                    pValue: error, 
                    test: "Pi Estimation Test",
                    estimatedPi: estimatedPi,
                    error: error
                };
            },

            // Mathematical functions
            erfc: function(x) {
                // Complementary error function approximation
                const z = Math.abs(x);
                const t = 1.0 / (1.0 + 0.5 * z);
                const ans = t * Math.exp(-z * z - 1.26551223 + 
                    t * (1.00002368 + t * (0.37409196 + t * (0.09678418 + 
                    t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 + 
                    t * (1.48851587 + t * (-0.82215223 + t * 0.17087277))))))));
                return x >= 0 ? ans : 2 - ans;
            },

            chi2cdf: function(x, df) {
                // Chi-square cumulative distribution function approximation
                if (df <= 0) return 0;
                if (x <= 0) return 0;
                if (df === 1) {
                    return 2 * (1 - this.erfc(x / Math.sqrt(2)));
                }
                return 1 - Math.exp(-0.5 * x);
            }
        };

        function cryptoShuffle(array, keyBytes) {
            const result = [...array];
            for (let i = result.length - 1; i > 0; i--) {
                const keyIndex = i % keyBytes.length;
                const j = keyBytes[keyIndex] % (i + 1);
                [result[i], result[j]] = [result[j], result[i]];
            }
            return result;
        }

        async function generateRoundKeys(masterKey, rounds) {
            const encoder = new TextEncoder();
            roundKeys = [];
            
            for (let round = 0; round < rounds; round++) {
                const roundSeed = await crypto.subtle.sign(
                    'HMAC', 
                    masterKey, 
                    encoder.encode(`round-key-${round}`)
                );
                const roundKeyBytes = new Uint8Array(roundSeed);
                roundKeys.push(roundKeyBytes);
            }
        }

        function applyRoundKey(byte, roundKey, index) {
            return byte ^ roundKey[index % roundKey.length];
        }

        async function generateSBox() {
            const key = document.getElementById('keyInput').value;
            if (!key) {
                alert('Please enter a key');
                return;
            }

            const statusElement = document.getElementById('status');
            statusElement.textContent = 'Generating S-Box...';

            try {
                const encoder = new TextEncoder();
                const keyData = encoder.encode(key);
                
                const cryptoKey = await crypto.subtle.importKey(
                    'raw', keyData, { name: 'HMAC', hash: 'SHA-512' }, false, ['sign']
                );

                const rounds = parseInt(document.getElementById('roundsCount').value);
                await generateRoundKeys(cryptoKey, rounds);

                const seed1 = await crypto.subtle.sign('HMAC', cryptoKey, encoder.encode('byte-permutation'));
                const seed2 = await crypto.subtle.sign('HMAC', cryptoKey, encoder.encode('homophonic-sbox'));
                
                const seedBytes1 = new Uint8Array(seed1);
                const seedBytes2 = new Uint8Array(seed2);

                const byteArray = Array.from({length: 256}, (_, i) => i);
                bytePermutation = cryptoShuffle(byteArray, Array.from(seedBytes1));
                
                inverseBytePermutation = Array(256);
                for (let i = 0; i < 256; i++) {
                    inverseBytePermutation[bytePermutation[i]] = i;
                }

                const wordArray = Array.from({length: 65536}, (_, i) => i);
                const shuffledWords = cryptoShuffle(wordArray, Array.from(seedBytes2));

                homophonicSBox = {};
                inverseHomophonicSBox = {};

                let wordIndex = 0;
                for (let containerId = 0; containerId < 256; containerId++) {
                    homophonicSBox[containerId] = [];
                    for (let i = 0; i < 256; i++) {
                        if (wordIndex < shuffledWords.length) {
                            const word = shuffledWords[wordIndex++];
                            homophonicSBox[containerId].push(word);
                            inverseHomophonicSBox[word] = containerId;
                        }
                    }
                }

                statusElement.textContent = `S-Box generated! Rounds: ${rounds}, CBC: ${document.getElementById('cbcMode').value}`;

            } catch (error) {
                statusElement.textContent = 'Error: ' + error.message;
            }
        }

        async function encryptData() {
            if (!bytePermutation || !homophonicSBox || roundKeys.length === 0) {
                alert('Please generate S-Box first');
                return;
            }

            const inputText = document.getElementById('encryptInput').value;
            if (!inputText) {
                alert('Please enter text to encrypt');
                return;
            }

            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(inputText);
                const rounds = parseInt(document.getElementById('roundsCount').value);
                const useCBC = document.getElementById('cbcMode').value === 'on';
                
                let currentState = Array.from(data);
                let iv = null;
                let encryptedData = [];

                if (useCBC) {
                    iv = crypto.getRandomValues(new Uint8Array(2));
                    encryptedData.push(...Array.from(iv));
                    currentState = currentState.map((byte, i) => byte ^ iv[i % 2]);
                }

                for (let round = 0; round < rounds - 1; round++) {
                    const roundKey = roundKeys[round];
                    currentState = currentState.map((byte, index) => {
                        const keyedByte = applyRoundKey(byte, roundKey, index);
                        return bytePermutation[keyedByte];
                    });
                }

                const finalRoundKey = roundKeys[rounds - 1];
                let encryptedWords = [];

                for (let i = 0; i < currentState.length; i++) {
                    const byte = applyRoundKey(currentState[i], finalRoundKey, i);
                    const randomIndex = crypto.getRandomValues(new Uint8Array(1))[0] % 256;
                    const encryptedWord = homophonicSBox[byte][randomIndex];
                    encryptedWords.push(encryptedWord);
                }

                for (const word of encryptedWords) {
                    encryptedData.push(word >> 8, word & 0xFF);
                }

                lastEncryptedBytes = encryptedData;
                const hexOutput = encryptedData.map(byte => byte.toString(16).padStart(2, '0'));
                const result = hexOutput.join(' ');
                
                let outputHTML = `<strong>Encrypted Hex (${encryptedData.length} bytes):</strong> ${result}<br>`;
                outputHTML += `<strong>Rounds:</strong> ${rounds}<br>`;
                outputHTML += `<strong>CBC:</strong> ${useCBC ? 'ON' : 'OFF'}<br>`;
                if (useCBC && iv) {
                    outputHTML += `<strong>IV:</strong> ${Array.from(iv).map(b => b.toString(16).padStart(2, '0')).join('')}<br>`;
                }
                outputHTML += `<button onclick="copyToDecrypt('${result}')">Copy to Decrypt Input</button>`;
                outputHTML += `<br><button onclick="runNISTTests()">Run NIST Tests on this output</button>`;

                document.getElementById('encryptOutput').innerHTML = outputHTML;

            } catch (error) {
                document.getElementById('encryptOutput').textContent = 'Encryption error: ' + error.message;
            }
        }

        async function runNISTTests() {
            if (lastEncryptedBytes.length === 0) {
                alert('Please encrypt some data first');
                return;
            }

            const resultsElement = document.getElementById('nistResults');
            resultsElement.innerHTML = '<strong>Running NIST Tests...</strong><br>';
            
            setTimeout(() => {
                const tests = [
                    NISTTests.frequencyTest(lastEncryptedBytes),
                    NISTTests.runsTest(lastEncryptedBytes),
                    NISTTests.binaryDerivativeTest(lastEncryptedBytes),
                    NISTTests.entropyTest(lastEncryptedBytes),
                    NISTTests.chiSquareTest(lastEncryptedBytes),
                    NISTTests.piEstimationTest(lastEncryptedBytes)
                ];

                let html = '<strong>NIST Statistical Test Results:</strong><br>';
                html += `<strong>Sample size:</strong> ${lastEncryptedBytes.length} bytes<br><br>`;
                
                let passed = 0;
                tests.forEach(test => {
                    const status = test.passed ? 'PASS' : 'FAIL';
                    const colorClass = test.passed ? 'test-pass' : 'test-fail';
                    
                    html += `<span class="${colorClass}">${test.test}: ${status}</span><br>`;
                    html += `P-value: ${test.pValue.toFixed(6)}<br>`;
                    
                    if (test.entropy !== undefined) {
                        html += `Entropy: ${test.entropy.toFixed(4)}/8.0000<br>`;
                    }
                    if (test.estimatedPi !== undefined) {
                        html += `Estimated Ï€: ${test.estimatedPi.toFixed(6)} (Error: ${test.error.toFixed(6)})<br>`;
                    }
                    if (test.ratio !== undefined) {
                        html += `Bit change ratio: ${test.ratio.toFixed(4)}<br>`;
                    }
                    if (test.chi2 !== undefined) {
                        html += `ChiÂ²: ${test.chi2.toFixed(2)}<br>`;
                    }
                    html += '<br>';
                    
                    if (test.passed) passed++;
                });

                const overall = passed === tests.length ? 'EXCELLENT' : 
                               passed >= tests.length - 1 ? 'GOOD' : 'POOR';
                const overallColor = passed === tests.length ? 'test-pass' : 
                                   passed >= tests.length - 1 ? 'test-warning' : 'test-fail';
                
                html += `<span class="${overallColor}"><strong>Overall: ${overall} (${passed}/${tests.length} tests passed)</strong></span>`;
                
                resultsElement.innerHTML = html;
            }, 100);
        }

        async function decryptData() {
            if (!inverseBytePermutation || !inverseHomophonicSBox || roundKeys.length === 0) {
                alert('Please generate S-Box first');
                return;
            }

            const hexText = document.getElementById('decryptInput').value.trim();
            if (!hexText) {
                alert('Please enter encrypted hex data');
                return;
            }

            try {
                const hexValues = hexText.split(/\s+/).filter(x => x);
                const rounds = parseInt(document.getElementById('roundsCount').value);
                const useCBC = document.getElementById('cbcMode').value === 'on';
                
                const encryptedBytes = [];
                for (const hexValue of hexValues) {
                    const byte = parseInt(hexValue, 16);
                    if (!isNaN(byte) && byte >= 0 && byte <= 255) {
                        encryptedBytes.push(byte);
                    }
                }

                if (encryptedBytes.length === 0) {
                    throw new Error('No valid encrypted bytes found');
                }

                let iv = null;
                let dataStart = 0;

                if (useCBC) {
                    if (encryptedBytes.length < 2) {
                        throw new Error('CBC mode requires at least 2 bytes for IV');
                    }
                    iv = new Uint8Array(encryptedBytes.slice(0, 2));
                    dataStart = 2;
                }

                const encryptedWords = [];
                for (let i = dataStart; i < encryptedBytes.length; i += 2) {
                    if (i + 1 < encryptedBytes.length) {
                        const word = (encryptedBytes[i] << 8) | encryptedBytes[i + 1];
                        encryptedWords.push(word);
                    }
                }

                const finalRoundKey = roundKeys[rounds - 1];
                let currentState = encryptedWords.map((word, index) => {
                    const containerId = inverseHomophonicSBox[word];
                    return applyRoundKey(containerId, finalRoundKey, index);
                });

                for (let round = rounds - 2; round >= 0; round--) {
                    const roundKey = roundKeys[round];
                    currentState = currentState.map((byte, index) => {
                        const unpermutedByte = inverseBytePermutation[byte];
                        return applyRoundKey(unpermutedByte, roundKey, index);
                    });
                }

                if (useCBC && iv) {
                    currentState = currentState.map((byte, i) => byte ^ iv[i % 2]);
                }

                const decoder = new TextDecoder();
                const decryptedText = decoder.decode(new Uint8Array(currentState));
                
                document.getElementById('decryptOutput').innerHTML = 
                    `<strong>Decrypted Text:</strong> ${decryptedText}<br>
                     <strong>Bytes Decrypted:</strong> ${currentState.length}<br>
                     <strong>Mode:</strong> ${useCBC ? 'CBC' : 'ECB'}`;

            } catch (error) {
                document.getElementById('decryptOutput').textContent = 'Decryption error: ' + error.message;
            }
        }

        function copyToDecrypt(hexText) {
            document.getElementById('decryptInput').value = hexText;
        }
    </script>
</body>
</html>
