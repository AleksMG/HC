<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto-Strong Homophonic S-Box with Permutation</title>
    <style>
        body { font-family: monospace; margin: 20px; background: #0d1117; color: #c9d1d9; }
        .container { max-width: 1000px; margin: 0 auto; }
        textarea, input { width: 100%; background: #161b22; color: #c9d1d9; border: 1px solid #30363d; padding: 8px; }
        button { background: #238636; color: white; border: none; padding: 10px 15px; cursor: pointer; margin: 5px; }
        button:hover { background: #2ea043; }
        .output { background: #161b22; padding: 15px; margin: 10px 0; border-radius: 5px; }
        .row { display: flex; margin: 10px 0; }
        .col { flex: 1; padding: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîí Homophonic Cipher with AES-like SubBytes</h1>
        
        <div class="row">
            <div class="col">
                <h3>Key Input:</h3>
                <input type="password" id="keyInput" placeholder="Enter encryption key" value="my-secret-key">
                <button onclick="generateSBox()">Generate S-Box from Key</button>
                <button onclick="encryptData()">Encrypt</button>
                <button onclick="decryptData()">Decrypt</button>
            </div>
        </div>

        <div class="row">
            <div class="col">
                <h3>Input Text:</h3>
                <textarea id="inputText" rows="4" placeholder="Enter text to encrypt">Hello, World!</textarea>
            </div>
            <div class="col">
                <h3>Output:</h3>
                <div class="output" id="output"></div>
            </div>
        </div>

        <div class="row">
            <div class="col">
                <h3>S-Box Status:</h3>
                <div class="output" id="status">S-Box not generated yet</div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let bytePermutation = null;    // SubBytes –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞: 256 –±–∞–π—Ç ‚Üí 256 –±–∞–π—Ç
        let homophonicSBox = null;     // –û–º–æ—Ñ–æ–Ω–∏—á–µ—Å–∫–∏–π S-Box: 256 –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ ‚Üí 256 –æ–º–æ—Ñ–æ–Ω–æ–≤
        let inverseBytePermutation = null; // –û–±—Ä–∞—Ç–Ω–∞—è –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–∞–π—Ç–æ–≤
        let inverseHomophonicSBox = null;  // –û–±—Ä–∞—Ç–Ω—ã–π S-Box –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è

        // Crypto-safe Fisher-Yates shuffle
        function cryptoShuffle(array, keyBytes) {
            const result = [...array];
            for (let i = result.length - 1; i > 0; i--) {
                const keyIndex = i % keyBytes.length;
                const j = keyBytes[keyIndex] % (i + 1);
                [result[i], result[j]] = [result[j], result[i]];
            }
            return result;
        }

        // Generate both permutations from key
        async function generateSBox() {
            const key = document.getElementById('keyInput').value;
            if (!key) {
                alert('Please enter a key');
                return;
            }

            const statusElement = document.getElementById('status');
            statusElement.textContent = 'Generating S-Box...';

            try {
                const encoder = new TextEncoder();
                const keyData = encoder.encode(key);
                
                // Import key for HMAC
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    keyData,
                    { name: 'HMAC', hash: 'SHA-512' },
                    false,
                    ['sign']
                );

                // Generate seeds for both permutations
                const seed1 = await crypto.subtle.sign('HMAC', cryptoKey, encoder.encode('byte-permutation'));
                const seed2 = await crypto.subtle.sign('HMAC', cryptoKey, encoder.encode('homophonic-sbox'));
                
                const seedBytes1 = new Uint8Array(seed1);
                const seedBytes2 = new Uint8Array(seed2);

                // 1. Create and shuffle byte permutation (SubBytes)
                const byteArray = Array.from({length: 256}, (_, i) => i);
                bytePermutation = cryptoShuffle(byteArray, Array.from(seedBytes1));
                
                // Create inverse permutation for decryption
                inverseBytePermutation = Array(256);
                for (let i = 0; i < 256; i++) {
                    inverseBytePermutation[bytePermutation[i]] = i;
                }

                // 2. Create and shuffle homophonic S-Box
                const wordArray = Array.from({length: 65536}, (_, i) => i);
                const shuffledWords = cryptoShuffle(wordArray, Array.from(seedBytes2));

                // Build homophonic S-Box structure
                homophonicSBox = {};
                inverseHomophonicSBox = {};

                let wordIndex = 0;
                for (let containerId = 0; containerId < 256; containerId++) {
                    homophonicSBox[containerId] = [];
                    for (let i = 0; i < 256; i++) {
                        if (wordIndex < shuffledWords.length) {
                            const word = shuffledWords[wordIndex++];
                            homophonicSBox[containerId].push(word);
                            inverseHomophonicSBox[word] = containerId; // Reverse mapping
                        }
                    }
                }

                statusElement.textContent = 'S-Box generated! Byte permutation: 256‚Üí256, Homophonic: 256√ó256‚Üí65536';

            } catch (error) {
                statusElement.textContent = 'Error: ' + error.message;
                console.error(error);
            }
        }

        // Encrypt with proper AES-like substitution
        async function encryptData() {
            if (!bytePermutation || !homophonicSBox) {
                alert('Please generate S-Box first');
                return;
            }

            const inputText = document.getElementById('inputText').value;
            if (!inputText) {
                alert('Please enter text to encrypt');
                return;
            }

            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(inputText);
                
                let output = [];
                let hexOutput = [];

                for (let i = 0; i < data.length; i++) {
                    const originalByte = data[i];
                    
                    // 1. AES-like SubBytes: –Ω–µ–ª–∏–Ω–µ–π–Ω–∞—è –∑–∞–º–µ–Ω–∞ –±–∞–π—Ç–∞
                    const permutedByte = bytePermutation[originalByte];
                    
                    // 2. Homophonic substitution: –≤—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–π –æ–º–æ—Ñ–æ–Ω
                    if (homophonicSBox[permutedByte]) {
                        const randomIndex = crypto.getRandomValues(new Uint8Array(1))[0] % 256;
                        const encryptedWord = homophonicSBox[permutedByte][randomIndex];
                        
                        output.push(encryptedWord);
                        hexOutput.push(encryptedWord.toString(16).padStart(4, '0'));
                    }
                }

                document.getElementById('output').innerHTML = 
                    `<strong>Encrypted (hex):</strong> ${hexOutput.join(' ')}<br><br>
                     <strong>Words:</strong> ${output.join(', ')}`;

            } catch (error) {
                document.getElementById('output').textContent = 'Encryption error: ' + error.message;
            }
        }

        // Decrypt with inverse operations
        async function decryptData() {
            if (!inverseBytePermutation || !inverseHomophonicSBox) {
                alert('Please generate S-Box first');
                return;
            }

            const outputText = document.getElementById('output').textContent;
            const hexMatch = outputText.match(/Encrypted \(hex\): ([0-9a-f ]+)/);
            
            if (!hexMatch) {
                alert('No encrypted data found');
                return;
            }

            try {
                const hexValues = hexMatch[1].split(' ').filter(x => x);
                const decoder = new TextDecoder();
                let decryptedBytes = [];

                for (const hexValue of hexValues) {
                    const encryptedWord = parseInt(hexValue, 16);
                    
                    // 1. Reverse homophonic substitution: –Ω–∞—Ö–æ–¥–∏–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
                    if (inverseHomophonicSBox[encryptedWord] !== undefined) {
                        const permutedByte = inverseHomophonicSBox[encryptedWord];
                        
                        // 2. Reverse SubBytes: –æ–±—Ä–∞—Ç–Ω–∞—è –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞
                        const originalByte = inverseBytePermutation[permutedByte];
                        decryptedBytes.push(originalByte);
                    }
                }

                const decryptedText = decoder.decode(new Uint8Array(decryptedBytes));
                document.getElementById('output').innerHTML += 
                    `<br><br><strong>Decrypted:</strong> ${decryptedText}`;

            } catch (error) {
                document.getElementById('output').textContent += '\nDecryption error: ' + error.message;
            }
        }

        // Initialize
        document.getElementById('inputText').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') encryptData();
        });
    </script>
</body>
</html>
