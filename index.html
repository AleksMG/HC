<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ö° True ITN v20.1 ‚Äî Adaptive Expert + Entropy</title>
    <style>
        :root {
            --bg: #050510;
            --panel: #0f0f1a;
            --text: #e0e0e0;
            --primary: #00f2ff;
            --accent: #ff0055;
            --success: #00ff9d;
            --border: #2a2a40;
            --phase: #aa88ff;
            --warning: #ffaa00;
            --hyper: #00ff88;
            --entropy: #ff8800;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', system-ui, sans-serif; }
        body { background: var(--bg); color: var(--text); padding: 20px; line-height: 1.4; }
        .container { max-width: 1400px; margin: 0 auto; }

        header { text-align: center; margin-bottom: 30px; padding: 20px; background: linear-gradient(135deg, var(--panel), #1a1a2e); border-radius: 16px; border: 1px solid var(--border); }
        h1 { color: var(--primary); font-size: 2rem; margin-bottom: 5px; text-shadow: 0 0 20px rgba(0,242,255,0.3); }
        .subtitle { color: #888; font-size: 0.9rem; }
        .version { color: var(--phase); font-weight: 600; font-size: 0.85rem; }

        .main-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        @media (max-width: 1100px) { .main-grid { grid-template-columns: 1fr; } }

        .panel {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
        }

        .panel-title {
            color: var(--primary);
            font-size: 1.05rem;
            font-weight: 600;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .input-group { margin-bottom: 15px; }
        label { display: block; color: var(--primary); margin-bottom: 6px; font-weight: 600; font-size: 0.8rem; }
        
        input, textarea, select {
            width: 100%; background: #0a0a15; border: 1px solid var(--border);
            color: var(--text); padding: 12px; border-radius: 8px;
            font-size: 0.9rem; font-family: 'Courier New', monospace;
            transition: border-color 0.2s;
        }
        input:focus, textarea:focus, select:focus { 
            outline: none; 
            border-color: var(--primary);
            box-shadow: 0 0 10px rgba(0,242,255,0.1);
        }

        .controls { display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap; }
        button {
            flex: 1; min-width: 120px; padding: 12px; border: none; border-radius: 8px;
            font-weight: 700; cursor: pointer; text-transform: uppercase;
            font-size: 0.85rem; transition: all 0.2s; letter-spacing: 0.5px;
        }
        .btn-enc { background: var(--primary); color: #000; }
        .btn-enc:hover { background: #fff; transform: translateY(-1px); }
        .btn-dec { background: var(--accent); color: #fff; }
        .btn-dec:hover { background: #ff5588; transform: translateY(-1px); }
        .btn-copy { background: #1a1a2e; color: var(--text); border: 1px solid var(--border); }
        .btn-copy:hover { background: #2a2a40; }
        .btn-test { background: var(--phase); color: #fff; }
        .btn-test:hover { background: #cc99ff; }

        .output-box {
            background: #000;
            border: 2px solid var(--success);
            border-radius: 8px;
            padding: 15px;
            min-height: 80px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 1rem;
            word-break: break-all;
            color: var(--success);
            font-family: 'Courier New', monospace;
            margin-bottom: 12px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            padding: 12px;
            background: #0a0a15;
            border-radius: 8px;
            font-size: 0.8rem;
        }
        .stat { text-align: center; }
        .stat-label { color: #666; display: block; margin-bottom: 4px; }
        .stat-value { color: var(--primary); font-weight: 700; font-family: 'Courier New', monospace; }
        .stat-value.ok { color: var(--success); }
        .stat-value.err { color: var(--accent); }
        .stat-value.warn { color: var(--warning); }
        .stat-value.hyper { color: var(--hyper); }
        .stat-value.entropy { color: var(--entropy); }

        .mode-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            padding: 8px;
            background: #0a0a15;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        .mode-option {
            flex: 1;
            text-align: center;
            padding: 8px 4px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
            font-size: 0.75rem;
        }
        .mode-option.active {
            border-color: var(--primary);
            background: rgba(0,242,255,0.1);
        }
        .mode-option .title { font-weight: 700; color: var(--primary); margin-bottom: 2px; }
        .mode-option .desc { font-size: 0.7rem; color: #888; }
        .mode-option.neural .title { color: var(--phase); }
        .mode-option.neural.active { border-color: var(--phase); background: rgba(170,136,255,0.1); }
        .mode-option.hyper .title { color: var(--hyper); }
        .mode-option.hyper.active { border-color: var(--hyper); background: rgba(0,255,136,0.1); }

        .perf-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }
        .perf-btn {
            flex: 1;
            padding: 8px;
            border: 1px solid var(--border);
            background: #0a0a15;
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
        }
        .perf-btn.active {
            border-color: var(--success);
            background: rgba(0,255,157,0.1);
            color: var(--success);
        }

        .rotor-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        @media (max-width: 600px) { .rotor-grid { grid-template-columns: repeat(2, 1fr); } }

        .rotor {
            background: #0a0a15;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            transition: border-color 0.2s;
        }
        .rotor.active { border-color: var(--primary); }
        .rotor.phase-active { border-color: var(--phase); }
        .rotor.hyper-active { border-color: var(--hyper); }

        .rotor-label {
            color: var(--primary);
            font-size: 0.7rem;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }
        .rotor-phase { color: var(--phase); font-size: 0.65rem; }
        .rotor-hyper { color: var(--hyper); font-size: 0.65rem; }

        .rotor-display {
            height: 60px;
            overflow: hidden;
            background: #050510;
            border-radius: 4px;
            position: relative;
            mask-image: linear-gradient(to bottom, transparent, black 20%, black 80%, transparent);
        }
        .rotor-tape {
            position: absolute;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.3s ease;
        }
        .rotor-char {
            height: 28px;
            line-height: 28px;
            font-size: 1rem;
            font-weight: 600;
            color: #444;
        }
        .rotor-char.active {
            color: var(--success);
            text-shadow: 0 0 8px var(--success);
            transform: scale(1.3);
        }
        .rotor-char.interference {
            color: var(--phase);
            text-shadow: 0 0 8px var(--phase);
        }
        .rotor-char.hyper-mod {
            color: var(--hyper);
            text-shadow: 0 0 8px var(--hyper);
        }

        .rotor-info {
            margin-top: 8px;
            font-size: 0.65rem;
            color: #666;
            font-family: 'Courier New', monospace;
        }
        .rotor-resonance {
            font-size: 0.6rem;
            color: var(--phase);
            margin-top: 2px;
        }
        .rotor-hyper-info {
            font-size: 0.6rem;
            color: var(--hyper);
            margin-top: 2px;
        }

        .dynamics-panel {
            margin-top: 15px;
            padding: 12px;
            background: #0a0a15;
            border-radius: 8px;
            border: 1px solid var(--border);
            font-size: 0.75rem;
        }
        .dynamics-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        .dynamics-label { color: #888; }
        .dynamics-value { color: var(--phase); font-family: 'Courier New', monospace; }
        .dynamics-value.hyper { color: var(--hyper); }
        .dynamics-value.entropy { color: var(--entropy); }

        .head-prefs-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 3px;
            margin-top: 8px;
        }
        .head-cell {
            background: #000;
            border: 1px solid #333;
            border-radius: 3px;
            padding: 4px 2px;
            text-align: center;
            font-size: 0.55rem;
            color: #666;
        }
        .head-cell.active {
            border-color: var(--primary);
            color: var(--primary);
        }
        .head-cell.hyper-active {
            border-color: var(--hyper);
            color: var(--hyper);
        }
        .head-cell .spec { display: block; font-weight: 700; margin-bottom: 1px; }
        .head-cell .strength { font-size: 0.5rem; opacity: 0.7; }

        .entropy-bar {
            height: 8px;
            background: #1a1a2e;
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden;
        }
        .entropy-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--warning), var(--success));
            transition: width 0.3s;
        }
        .entropy-value {
            text-align: right;
            font-size: 0.7rem;
            color: var(--entropy);
            margin-top: 4px;
        }

        .interference-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 3px;
            margin-top: 8px;
        }
        .interference-cell {
            background: #000;
            border: 1px solid #333;
            border-radius: 3px;
            padding: 3px;
            text-align: center;
            font-size: 0.6rem;
            color: #666;
        }
        .interference-cell.active {
            color: var(--phase);
            border-color: var(--phase);
        }

        .log {
            background: #000;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            max-height: 120px;
            overflow-y: auto;
            font-size: 0.7rem;
            color: #666;
            font-family: 'Courier New', monospace;
        }
        .log-entry { margin-bottom: 4px; padding-bottom: 4px; border-bottom: 1px solid #111; }
        .log-entry.ok { color: var(--success); }
        .log-entry.err { color: var(--accent); }
        .log-entry.info { color: var(--primary); }
        .log-entry.phase { color: var(--phase); }
        .log-entry.perf { color: var(--warning); }
        .log-entry.hyper { color: var(--hyper); }
        .log-entry.entropy { color: var(--entropy); }

        .footer {
            text-align: center;
            margin-top: 30px;
            padding: 15px;
            color: #666;
            font-size: 0.75rem;
        }
        .footer a { color: var(--primary); text-decoration: none; }
        .footer a:hover { text-decoration: underline; }

        .badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 700;
            margin-left: 8px;
        }
        .badge-hyper { background: rgba(0,255,136,0.2); color: var(--hyper); border: 1px solid var(--hyper); }
        .badge-entropy { background: rgba(255,136,0,0.2); color: var(--entropy); border: 1px solid var(--entropy); }

        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #0a0a15; }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--primary); }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚ö° True ITN v20.1 <span class="badge badge-hyper">ADAPTIVE</span><span class="badge badge-entropy">ENTROPY</span></h1>
            <p class="subtitle">Adaptive Expert Optimization ¬∑ Attention Confidence ¬∑ Real-time Entropy</p>
            <span class="version">Professional Optimized Build</span>
        </header>

        <div class="main-grid">
            <div class="panel">
                <div class="panel-title">
                    üîê –í–•–û–î
                    <span id="perfIndicator" style="font-size:0.7rem;color:var(--warning)">‚öôÔ∏è Quality</span>
                </div>
                
                <div class="input-group">
                    <label>üî§ –ê–õ–§–ê–í–ò–¢</label>
                    <input type="text" id="alphabet" value="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" maxlength="256">
                </div>

                <div class="input-group">
                    <label>üîë –ü–ê–†–û–õ–¨</label>
                    <input type="text" id="password" value="ITN_V20_ADAPTIVE" maxlength="128">
                </div>

                <div class="mode-selector">
                    <div class="mode-option active" id="modeClassic" onclick="setMode('classic')">
                        <div class="title">üé° CLASSIC</div>
                        <div class="desc">v17.3 ‚Äî Independent rotors</div>
                    </div>
                    <div class="mode-option neural" id="modeNeural" onclick="setMode('neural')">
                        <div class="title">üß† NEURAL</div>
                        <div class="desc">v18.0 ‚Äî Phase + Resonance</div>
                    </div>
                    <div class="mode-option hyper" id="modeHyper" onclick="setMode('hyper')">
                        <div class="title">üîÆ HYPER</div>
                        <div class="desc">v20.1 ‚Äî Adaptive Expert + Entropy</div>
                    </div>
                </div>

                <div class="perf-toggle">
                    <button class="perf-btn active" id="perfQuality" onclick="setPerf('quality')">üß† Quality</button>
                    <button class="perf-btn" id="perfTurbo" onclick="setPerf('turbo')">‚ö° Turbo</button>
                    <button class="perf-btn" id="perfDebug" onclick="setPerf('debug')">üîç Debug</button>
                </div>

                <div class="input-group">
                    <label>üìù –¢–ï–ö–°–¢</label>
                    <textarea id="inputText" rows="6" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è...">HELLO WORLD 123</textarea>
                </div>

                <div class="controls">
                    <button class="btn-enc" onclick="run('encrypt')">üîí –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                    <button class="btn-dec" onclick="run('decrypt')">üîì –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                    <button class="btn-test" onclick="runTest()">üß™ –¢–µ—Å—Ç</button>
                    <button class="btn-copy" onclick="copyOutput()">üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title">üìä –†–ï–ó–£–õ–¨–¢–ê–¢</div>
                
                <div class="output-box" id="outputText">–û–∂–∏–¥–∞–Ω–∏–µ...</div>

                <div class="stats-grid">
                    <div class="stat">
                        <span class="stat-label">–î–ª–∏–Ω–∞</span>
                        <span class="stat-value" id="statLen">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">–û–±—Ä–∞—Ç–∏–º–æ—Å—Ç—å</span>
                        <span class="stat-value" id="statRev">-</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">–ü–∞—Ç—Ç–µ—Ä–Ω—ã</span>
                        <span class="stat-value" id="statPatterns">0/16</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">–í—Ä–µ–º—è</span>
                        <span class="stat-value" id="statTime">0ms</span>
                    </div>
                </div>

                <div class="dynamics-panel" id="dynamicsPanel">
                    <div class="dynamics-row">
                        <span class="dynamics-label">–§–∞–∑–æ–≤–∞—è –º–æ–¥—É–ª—è—Ü–∏—è:</span>
                        <span class="dynamics-value" id="phaseValue">0.00</span>
                    </div>
                    <div class="dynamics-row">
                        <span class="dynamics-label">–†–µ–∑–æ–Ω–∞–Ω—Å –ø–∞–º—è—Ç–∏:</span>
                        <span class="dynamics-value" id="resonanceValue">0.00</span>
                    </div>
                    <div class="dynamics-row hyper-row" style="display:none;">
                        <span class="dynamics-label">Attention Confidence:</span>
                        <span class="dynamics-value hyper" id="confidenceValue">0.00</span>
                    </div>
                    <div class="dynamics-row">
                        <span class="dynamics-label">–ò–Ω—Ç–µ—Ä—Ñ–µ—Ä–µ–Ω—Ü–∏—è:</span>
                        <span class="dynamics-value" id="interferenceValue">0/256</span>
                    </div>
                    <div class="dynamics-row">
                        <span class="dynamics-label">–≠–Ω—Ç—Ä–æ–ø–∏—è (–ª–æ–∫–∞–ª—å–Ω–∞—è):</span>
                        <span class="dynamics-value entropy" id="localEntropyValue">0.00</span>
                    </div>
                    <div class="dynamics-row">
                        <span class="dynamics-label">–≠–Ω—Ç—Ä–æ–ø–∏—è (–≥–ª–æ–±–∞–ª—å–Ω–∞—è):</span>
                        <span class="dynamics-value entropy" id="globalEntropyValue">0.00</span>
                    </div>
                    <div class="entropy-bar">
                        <div class="entropy-fill" id="entropyBar" style="width: 0%"></div>
                    </div>
                    <div class="entropy-value" id="entropyPercent">0% –æ—Ç –º–∞–∫—Å–∏–º—É–º–∞</div>
                    <div class="head-prefs-grid" id="headPrefsGrid"></div>
                    <div class="interference-grid" id="interferenceGrid"></div>
                </div>

                <div class="panel-title" style="margin-top: 20px;">üé° –†–û–¢–û–†–´</div>
                <div class="rotor-grid" id="rotorViz"></div>

                <div class="log" id="log"></div>
            </div>
        </div>

        <div class="footer">
            True ITN v20.1 ‚Äî Adaptive Expert Optimization with Entropy Analysis<br>
            <strong>–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞:</strong> INN + 16-Head Attention + Adaptive Experts + Attention Confidence + Entropy Monitor<br>
            <strong>–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:</strong> Dynamic expert ranges, No hardcoded multipliers, LUT trig, TypedArray pooling, Reversible<br>
            <strong>–û–±—Ä–∞—Ç–∏–º–æ—Å—Ç—å:</strong> –ü–æ–ª–Ω–∞—è –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∏–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å —Å hash-–≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–µ–π<br>
            <strong>–≠–Ω—Ç—Ä–æ–ø–∏—è:</strong> Real-time Shannon entropy analysis with avalanche tracking
        </div>
    </div>

<script>
/**
 * ============================================================================
 * TRUE ITN v20.1 ‚Äî ADAPTIVE EXPERT OPTIMIZATION + ENTROPY ANALYSIS
 * ============================================================================
 * –£–±—Ä–∞–Ω—ã hardcoded –º–Ω–æ–∂–∏—Ç–µ–ª–∏ ‚Äî —Ç–µ–ø–µ—Ä—å –≤—Å—ë –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –æ—Ç –≤–Ω–∏–º–∞–Ω–∏—è
 * –î–æ–±–∞–≤–ª–µ–Ω–∞ Attention Confidence –º–µ—Ç—Ä–∏–∫–∞
 * –í—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∞–¥–∞–ø—Ç–∏–≤–Ω–æ –∑–∞–≤–∏—Å—è—Ç –æ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–µ—Ç–∏
 * –û–±—Ä–∞—Ç–∏–º–æ—Å—Ç—å –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞
 * 
 * @version 20.1.0-adaptive
 * ============================================================================
 */

const FastMath = (() => {
    const LUT_SIZE = 2048;
    const SIN_LUT = new Float32Array(LUT_SIZE);
    const COS_LUT = new Float32Array(LUT_SIZE);
    
    for(let i = 0; i < LUT_SIZE; i++) {
        const angle = (i / LUT_SIZE) * Math.PI * 2;
        SIN_LUT[i] = Math.sin(angle);
        COS_LUT[i] = Math.cos(angle);
    }
    
    function fastTrig(x, useCos = false) {
        let norm = x % (Math.PI * 2);
        if(norm < 0) norm += Math.PI * 2;
        const idx = (norm / (Math.PI * 2)) * LUT_SIZE;
        const i0 = Math.floor(idx) & (LUT_SIZE - 1);
        const i1 = (i0 + 1) & (LUT_SIZE - 1);
        const frac = idx - Math.floor(idx);
        const lut = useCos ? COS_LUT : SIN_LUT;
        return lut[i0] + (lut[i1] - lut[i0]) * frac;
    }
    
    function fastTanh(x) {
        if(x > 3) return 1;
        if(x < -3) return -1;
        const x2 = x * x;
        return x * (27 + x2) / (27 + 9 * x2);
    }
    
    function fastMod(n, m) {
        return n >= 0 ? n % m : (n % m + m) % m;
    }
    
    return {
        sin: (x) => fastTrig(x, false),
        cos: (x) => fastTrig(x, true),
        tanh: (x) => fastTanh(x),
        mod: (n, m) => fastMod(n, m),
        LUT_SIZE
    };
})();

const { sin, cos, tanh, mod } = FastMath;

class SeededRandom {
    constructor(seedStr) {
        let h = 0x811c9dc5;
        for(let i = 0; i < seedStr.length; i++) {
            h ^= seedStr.charCodeAt(i);
            h = Math.imul(h, 0x01000193);
        }
        this.seed = h >>> 0;
    }
    
    next() {
        this.seed = (this.seed * 1664525 + 1013904223) >>> 0;
        return this.seed / 0xFFFFFFFF;
    }
    
    nextInt(max) {
        return Math.floor(this.next() * max);
    }
    
    generateOrthogonalMatrix(rows, cols, scale = 0.1) {
        const matrix = [];
        for(let i = 0; i < rows; i++) {
            const row = [];
            for(let j = 0; j < cols; j++) {
                row.push((this.next() * 2 - 1) * scale);
            }
            matrix.push(row);
        }
        return matrix;
    }
    
    generateVector(length, scale = 1.0) {
        const vec = new Float32Array(length);
        for(let i = 0; i < length; i++) {
            vec[i] = (this.next() * 2 - 1) * scale;
        }
        return vec;
    }
}

// ============================================================================
// HEAD PREFERENCES ‚Äî 16 ADAPTIVE EXPERTS (NO HARDCODED MULTIPLIERS)
// ============================================================================
class HeadPreferences {
    static SPECIALIZATIONS = {
        'local':      { template: [1, 0.8, 0.6, 0.4, 0.2, 0, -0.2, -0.4], baseStrength: 0.6 },
        'global':     { template: [0.2, 0.4, 0.6, 0.8, 1, 0.8, 0.6, 0.4], baseStrength: 0.5 },
        'freq':       { template: [1, -1, 1, -1, 1, -1, 1, -1], baseStrength: 0.55 },
        'phase':      { template: [0, 1, 0, -1, 0, 1, 0, -1], baseStrength: 0.5 },
        'edge':       { template: [-1, -0.5, 0, 0.5, 1, 0.5, 0, -0.5], baseStrength: 0.6 },
        'smooth':     { template: [0.3, 0.5, 0.7, 0.9, 1, 0.9, 0.7, 0.5], baseStrength: 0.4 },
        'chaos':      { template: [0.9, -0.7, 0.5, -0.3, 0.1, -0.1, 0.3, -0.5], baseStrength: 0.7 },
        'resonant':   { template: [1, 0, -1, 0, 1, 0, -1, 0], baseStrength: 0.5 },
        'gradient':   { template: [-1, -0.7, -0.4, 0, 0.4, 0.7, 1, 0.7], baseStrength: 0.55 },
        'oscillate':  { template: [0, 0.7, 1, 0.7, 0, -0.7, -1, -0.7], baseStrength: 0.5 },
        'spike':      { template: [0, 0, 0, 1, 0, 0, 0, 0], baseStrength: 0.65 },
        'broad':      { template: [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], baseStrength: 0.45 },
        'alternating':{ template: [1, 0, -1, 0, 1, 0, -1, 0], baseStrength: 0.5 },
        'decay':      { template: [1, 0.85, 0.7, 0.55, 0.4, 0.25, 0.1, 0], baseStrength: 0.45 },
        'inverse':    { template: [-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4], baseStrength: 0.55 },
        'random':     { template: [0.5, -0.3, 0.7, -0.1, 0.4, -0.6, 0.2, -0.8], baseStrength: 0.6 }
    };
    
    constructor(seedStr, numHeads = 16, prefDim = 64) {
        this.numHeads = numHeads;
        this.prefDim = prefDim;
        this.preferences = [];
        this.specializations = [];
        this.strengths = [];
        this.noiseSensitivities = [];
        
        const rng = new SeededRandom(seedStr + "_HEAD_PREFS");
        const specNames = Object.keys(HeadPreferences.SPECIALIZATIONS);
        
        for(let h = 0; h < numHeads; h++) {
            const specName = specNames[h % specNames.length];
            const specData = HeadPreferences.SPECIALIZATIONS[specName];
            const baseTemplate = specData.template;
            
            const pref = new Float32Array(prefDim);
            const specRng = new SeededRandom(seedStr + "_SPEC_" + h);
            
            for(let i = 0; i < prefDim; i++) {
                const templateVal = baseTemplate[i % baseTemplate.length];
                const noise = (specRng.next() - 0.5) * 0.3;
                pref[i] = templateVal + noise;
            }
            
            const norm = Math.sqrt(pref.reduce((s, v) => s + v*v, 0)) || 1;
            this.preferences.push(pref.map(v => v / norm));
            this.specializations.push(specName);
            
            // ‚úÖ ADAPTIVE: Strength with small deterministic variation
            this.strengths.push(specData.baseStrength + (specRng.next() - 0.5) * 0.2);
            // ‚úÖ ADAPTIVE: Noise sensitivity from expert type
            this.noiseSensitivities.push(0.3 + specData.baseStrength * 0.4 + (specRng.next() - 0.5) * 0.15);
        }
    }
    
    getPreference(headId) { return this.preferences[headId] || null; }
    getSpecialization(headId) { return this.specializations[headId] || 'unknown'; }
    getStrength(headId) { return this.strengths[headId] || 0.5; }
    getNoiseSensitivity(headId) { return this.noiseSensitivities[headId] || 0.5; }
}

class BufferPool {
    constructor(dim, workingDim, memoryDim) {
        this.dim = dim;
        this.workingDim = workingDim;
        this.memoryDim = memoryDim;
        
        this.state = new Float32Array(dim);
        this.working = new Float32Array(workingDim);
        this.memory = new Float32Array(memoryDim);
        this.output = new Float32Array(dim);
        
        this.Q = new Float32Array(16 * Math.floor(workingDim / 16));
        this.K = new Float32Array(16 * Math.floor(workingDim / 16));
        this.V = new Float32Array(16 * Math.floor(workingDim / 16));
        this.scores = new Float32Array(16);
        this.interfered = new Float32Array(16);
        
        this.values = new Float32Array(16);
        this.input = new Float32Array(16 + memoryDim);
        
        this.commands = new Array(4).fill(null).map(() => ({}));
        this.interferenceMatrix = Array.from({length: 16}, () => new Float32Array(16));
        
        this.hyperMod = new Float32Array(16);
        this.hyperState = new Float32Array(64);
        this.entropyBuffer = new Float32Array(256);
    }
    
    reset() {
        this.state.fill(0);
        this.working.fill(0);
        this.memory.fill(0);
        this.output.fill(0);
        this.scores.fill(0);
        this.interfered.fill(0);
        this.values.fill(0);
        this.input.fill(0);
        this.hyperMod.fill(0);
        this.hyperState.fill(0);
        this.entropyBuffer.fill(0);
    }
}

// ============================================================================
// 16-HEAD ATTENTION WITH ADAPTIVE EXPERT OPTIMIZATION
// ============================================================================
class SixteenHeadAttention {
    constructor(dim, password, mode = 'classic', perfMode = 'quality') {
        this.dim = dim;
        this.mode = mode;
        this.perfMode = perfMode;
        this.numHeads = 16;
        this.headDim = Math.floor(dim / this.numHeads);
        
        const rng = new SeededRandom(password + "_ATTN");
        
        this.W_q = []; this.W_k = []; this.W_v = [];
        for(let h = 0; h < this.numHeads; h++) {
            this.W_q.push(rng.generateOrthogonalMatrix(this.headDim, dim, 0.05));
            this.W_k.push(rng.generateOrthogonalMatrix(this.headDim, dim, 0.05));
            this.W_v.push(rng.generateOrthogonalMatrix(this.headDim, dim, 0.05));
        }
        
        this.headPrefs = new HeadPreferences(password + "_ATTN", 16, Math.min(64, this.headDim));
        
        const hyperRng = new SeededRandom(password + "_HYPER");
        this.W_hyper = [];
        for(let h = 0; h < this.numHeads; h++) {
            this.W_hyper.push(hyperRng.generateVector(Math.min(64, dim), 0.15));
        }
        
        this.earlyExitThreshold = perfMode === 'turbo' ? 0.08 : 0.03;
        this.hyperStrength = mode === 'hyper' ? 0.5 : (mode === 'neural' ? 0.3 : 0);
        this.prefStrength = mode === 'hyper' ? 0.6 : (mode === 'neural' ? 0.4 : 0);
    }
    
    // ‚úÖ NEW: Calculate attention confidence (how focused is the attention?)
    calculateAttentionConfidence(scores) {
        // Max absolute score indicates focus strength
        let maxScore = 0;
        for(let s of scores) {
            const absS = Math.abs(s);
            if(absS > maxScore) maxScore = absS;
        }
        
        // Calculate entropy of attention distribution
        let entropy = 0;
        let total = 0;
        for(let s of scores) {
            const p = Math.abs(s) + 0.001; // Avoid log(0)
            total += p;
        }
        
        for(let s of scores) {
            const p = (Math.abs(s) + 0.001) / total;
            if(p > 0.001 && p < 0.999) {
                entropy -= p * Math.log2(p);
            }
        }
        
        // Normalize: 0 = chaos (all equal), 1 = focus (one dominant)
        const maxEntropy = Math.log2(16);
        const focusFactor = 1 - (entropy / maxEntropy);
        
        // Combine: high maxScore + low entropy = high confidence
        return Math.min(1, maxScore * (0.5 + focusFactor * 0.5));
    }
    
    forward(state, buffers = null) {
        const headDim = this.headDim;
        const scores = buffers?.scores || new Float32Array(16);
        const outputs = buffers?.output || new Float32Array(this.dim);
        const hyperMods = buffers?.hyperMod || new Float32Array(16);
        
        for(let h = 0; h < this.numHeads; h++) {
            let score = 0;
            const Wq = this.W_q[h], Wk = this.W_k[h], Wv = this.W_v[h];
            
            for(let i = 0; i < headDim; i++) {
                let qs = 0, ks = 0, vs = 0;
                for(let j = 0; j < this.dim; j++) {
                    qs += state[j] * Wq[i][j];
                    ks += state[j] * Wk[i][j];
                    vs += state[j] * Wv[i][j];
                }
                if(buffers) {
                    buffers.Q[h * headDim + i] = tanh(qs);
                    buffers.K[h * headDim + i] = tanh(ks);
                    buffers.V[h * headDim + i] = tanh(vs);
                }
                score += tanh(qs) * tanh(ks);
            }
            
            score = tanh(score / Math.sqrt(headDim));
            
            // ‚úÖ EXPERT PREFERENCES MODULATION
            if(this.prefStrength > 0) {
                const prefVec = this.headPrefs.getPreference(h);
                let prefScore = 0;
                const prefLen = Math.min(state.length, prefVec.length);
                for(let i = 0; i < prefLen; i++) {
                    prefScore += state[i] * prefVec[i];
                }
                const prefInfluence = tanh(prefScore) * this.headPrefs.getStrength(h) * this.prefStrength;
                score = tanh(score + prefInfluence);
            }
            
            // ‚úÖ HYPERNETWORK MODULATION
            if(this.hyperStrength > 0) {
                const hyperVec = this.W_hyper[h];
                let hyperScore = 0;
                const hyperLen = Math.min(state.length, hyperVec.length);
                for(let i = 0; i < hyperLen; i++) {
                    hyperScore += state[i] * hyperVec[i];
                }
                hyperMods[h] = tanh(hyperScore) * this.hyperStrength;
                score = tanh(score * (1 + hyperMods[h]));
            } else {
                hyperMods[h] = 0;
            }
            
            scores[h] = score;
            
            for(let i = 0; i < headDim; i++) {
                outputs[h * headDim + i] = (buffers ? buffers.V[h * headDim + i] : tanh(0)) * scores[h];
            }
        }
        
        // Calculate attention confidence for adaptive expert ranges
        this.attentionConfidence = this.calculateAttentionConfidence(scores);
        
        if(this.mode === 'neural' || this.mode === 'hyper') {
            this._applyInterference(scores, buffers);
        }
        
        return { 
            output: outputs, 
            scores: Array.from(scores),
            hyperMods: Array.from(hyperMods),
            headPrefs: this.headPrefs,
            attentionConfidence: this.attentionConfidence
        };
    }
    
    _applyInterference(scores, buffers) {
        const interfered = buffers?.interfered || new Float32Array(16);
        const threshold = this.earlyExitThreshold;
        
        for(let h = 0; h < 16; h++) interfered[h] = scores[h];
        
        let entropy = 0;
        for(let h = 0; h < 16; h++) {
            const p = (scores[h] + 1) / 2;
            if(p > 0.001 && p < 0.999) {
                entropy -= p * Math.log2(p) + (1-p) * Math.log2(1-p);
            }
        }
        const confidence = 1 - (entropy / 16);
        const interferenceStrength = 0.1 + confidence * 0.3;
        
        const matrix = buffers?.interferenceMatrix || Array.from({length: 16}, () => new Float32Array(16));
        let activeCount = 0;
        
        for(let h = 0; h < 16; h++) {
            if(Math.abs(scores[h]) < threshold) continue;
            
            for(let k = 0; k < 16; k++) {
                if(h === k || Math.abs(scores[k]) < threshold) {
                    matrix[h][k] = 0;
                    continue;
                }
                
                const phaseDiff = scores[h] - scores[k];
                const interference = sin(phaseDiff * 5) * interferenceStrength;
                matrix[h][k] = interference;
                interfered[h] += interference;
                activeCount++;
            }
            interfered[h] = tanh(interfered[h]);
        }
        
        this.lastInterference = matrix;
        this.lastInterferenceActive = activeCount;
        this.lastEntropy = entropy;
        
        for(let h = 0; h < 16; h++) scores[h] = interfered[h];
    }
}

// ============================================================================
// FLEXIBLE DRIVER ‚Äî ADAPTIVE EXPERT OPTIMIZATION (NO HARDCODED VALUES)
// ============================================================================
class FlexibleDriver {
    constructor(password, workingDim, memoryDim, mode = 'classic', perfMode = 'quality') {
        this.workingDim = workingDim;
        this.memoryDim = memoryDim;
        this.mode = mode;
        this.perfMode = perfMode;
        this.patternsUsed = new Set();
        
        const rng = new SeededRandom(password + "_DRIVER");
        
        this.W_pattern = rng.generateOrthogonalMatrix(16, workingDim + memoryDim, 0.1);
        this.W_decision = rng.generateOrthogonalMatrix(16, workingDim + memoryDim, 0.1);
        this.W_memory = rng.generateOrthogonalMatrix(memoryDim, 16, 0.05);
        
        if(mode === 'neural' || mode === 'hyper') {
            this.W_resonance = rng.generateOrthogonalMatrix(memoryDim, 16, 0.1);
        }
        
        this.confidenceThreshold = perfMode === 'turbo' ? 0.85 : 0.7;
        this.hyperStrength = mode === 'hyper' ? 0.4 : (mode === 'neural' ? 0.2 : 0);
    }
    
    selectPattern(attentionResult, memory, step) {
        const focus = attentionResult.scores;
        const input = this._concat(focus, memory);
        
        let bestScore = -Infinity, bestPattern = 0;
        for(let p = 0; p < 16; p++) {
            let score = 0;
            for(let j = 0; j < input.length; j++) {
                score += input[j] * this.W_pattern[p][j];
            }
            if(score > bestScore) {
                bestScore = score;
                bestPattern = p;
            }
        }
        
        const final = mod(bestPattern + step % 5, 16);
        this.patternsUsed.add(final);
        return ACTIVATION_PATTERNS[final];
    }
    
    // ‚úÖ ADAPTIVE: All parameters dynamic from attention confidence + expert strength
    decide(attentionResult, memory, step, buffers = null) {
        const activePattern = this.selectPattern(attentionResult, memory, step);
        const focus = attentionResult.scores;
        const input = buffers?.input || this._concat(focus, memory);
        const headPrefs = attentionResult.headPrefs;
        const attentionConfidence = attentionResult.attentionConfidence || 0.5;
        
        const values = buffers?.values || new Float32Array(16);
        for(let i = 0; i < 16; i++) {
            let sum = 0;
            for(let j = 0; j < input.length; j++) {
                sum += input[j] * this.W_decision[i][j];
            }
            values[i] = tanh(sum);
        }
        
        const commands = [];
        for(let r = 0; r < 4; r++) {
            const b = r * 4;
            
            // ‚úÖ ADAPTIVE: Normalized base signal
            const baseDelta = tanh(values[b] * 10);
            const baseSpeed = tanh(values[b + 2] * 7);
            
            // ‚úÖ ADAPTIVE: Expert strength (not hardcoded multiplier)
            const expertStrength = headPrefs ? headPrefs.getStrength(b) : 0.5;
            const expertNoiseSensitivity = headPrefs ? headPrefs.getNoiseSensitivity(b) : 0.5;
            
            // ‚úÖ ADAPTIVE: Dynamic range from confidence + expert
            // Base: 7, Expert: +0-5, Confidence: +0-4 = Range 7-16
            const deltaRange = 7 + expertStrength * 5 + attentionConfidence * 4;
            const speedRange = 3 + expertStrength * 3 + attentionConfidence * 2;
            
            let delta = Math.floor(baseDelta * deltaRange);
            let speed = Math.floor(Math.abs(baseSpeed) * speedRange) + 1;
            speed = Math.max(1, Math.min(10, speed));
            
            const dir = values[b + 1] > 0 ? 1 : -1;
            
            // ‚úÖ ADAPTIVE: Noise from cross-head influence + expert sensitivity
            let noiseSum = 0;
            for(let j = 0; j < 16; j++) {
                const pref = headPrefs ? headPrefs.getPreference(j % 16) : null;
                noiseSum += values[j] * (pref ? pref[j % pref.length] : 0.1);
            }
            const noiseSensitivity = 3 + expertNoiseSensitivity * 4;
            const rotorNoise = tanh(noiseSum) * noiseSensitivity;
            delta += Math.floor(rotorNoise);
            
            let phase = 0, resonance = 0, hyperMod = 0;
            if(this.mode === 'neural' || this.mode === 'hyper') {
                phase = focus[r % focus.length] * Math.PI;
                const phaseMod = Math.floor(sin(phase * 2) * 3);
                delta += phaseMod;
                
                const freq = Math.abs((focus[0] || 0) - (focus[1] || 0)) * 2;
                resonance = sin(freq * Math.PI) * 2;
                speed += Math.floor(Math.abs(resonance));
                speed = Math.max(1, Math.min(10, speed));
                
                if(this.mode === 'hyper' && attentionResult.hyperMods) {
                    hyperMod = attentionResult.hyperMods[r % 4] || 0;
                    delta += Math.floor(hyperMod * 3);
                }
            }
            
            // ‚úÖ ADAPTIVE: Cross-head influence when confidence is low (boosts entropy)
            if(attentionConfidence < 0.4 && this.mode === 'hyper') {
                const neighborInfluence = (focus[(b+1)%16] + focus[(b+3)%16]) * 0.3;
                delta += Math.floor(tanh(neighborInfluence) * 2);
            }
            
            delta = Math.max(-15, Math.min(15, delta));
            
            commands.push({
                delta, dir, speed,
                active: activePattern[r] === 1,
                noise: rotorNoise.toFixed(2),
                phase: phase.toFixed(3),
                resonance: resonance.toFixed(3),
                hyperMod: hyperMod.toFixed(3),
                confidence: attentionConfidence.toFixed(2),
                dynRange: deltaRange.toFixed(1),
                expertStrength: expertStrength.toFixed(2)
            });
        }
        
        return { commands, values: Array.from(values), activePattern, attentionConfidence };
    }
    
    updateMemory(memory, decision, attentionResult = null, buffers = null) {
        const newMem = buffers?.memory || new Float32Array(this.memoryDim);
        
        if(this.mode === 'classic') {
            for(let i = 0; i < this.memoryDim; i++) {
                let sum = 0;
                for(let j = 0; j < 16; j++) {
                    sum += decision.values[j] * this.W_memory[i][j];
                }
                newMem[i] = memory[i] + tanh(sum) * 0.1;
            }
        } else {
            for(let i = 0; i < this.memoryDim; i++) {
                let sum = 0;
                for(let j = 0; j < 16; j++) {
                    sum += decision.values[j] * this.W_memory[i][j];
                }
                
                let resonanceFreq = 0;
                if(attentionResult?.scores) {
                    const scores = attentionResult.scores;
                    for(let j = 1; j < scores.length; j++) {
                        resonanceFreq += Math.abs(scores[j] - scores[j-1]);
                    }
                    resonanceFreq /= scores.length;
                }
                
                const resonance = sin(resonanceFreq * Math.PI) * 0.2;
                const dynamicStep = 0.05 + Math.abs(resonance) * 0.15;
                
                let resSum = 0;
                for(let j = 0; j < 16; j++) {
                    resSum += decision.values[j] * this.W_resonance[i][j];
                }
                
                newMem[i] = memory[i] + tanh(sum + resSum) * dynamicStep;
            }
        }
        
        return newMem;
    }
    
    _concat(a, b) {
        const result = new Float32Array(a.length + b.length);
        result.set(a, 0);
        result.set(b, a.length);
        return result;
    }
    
    getPatternsUsed() { return this.patternsUsed; }
    resetPatterns() { this.patternsUsed.clear(); }
}

class DriverBlock {
    constructor(dim, password, blockId, mode = 'classic', perfMode = 'quality', memoryRatio = 0.3) {
        this.dim = dim;
        this.mode = mode;
        this.perfMode = perfMode;
        this.workingDim = Math.floor(dim * (1 - memoryRatio));
        this.memoryDim = dim - this.workingDim;
        
        this.attention = new SixteenHeadAttention(this.workingDim, password, mode, perfMode);
        this.driver = new FlexibleDriver(password, this.workingDim, this.memoryDim, mode, perfMode);
        
        const rng = new SeededRandom(password + "_BLOCK_" + blockId);
        this.W_f = rng.generateOrthogonalMatrix(this.workingDim / 2, this.workingDim / 2, 0.1);
        this.W_g = rng.generateOrthogonalMatrix(this.workingDim / 2, this.workingDim / 2, 0.1);
    }
    
    forward(state, step, buffers = null) {
        const working = state.slice(0, this.workingDim);
        const memory = state.slice(this.workingDim);
        
        const attn = this.attention.forward(working, buffers);
        const decision = this.driver.decide(attn, memory, step, buffers);
        const newMem = this.driver.updateMemory(memory, decision, attn, buffers);
        
        const half = Math.floor(this.workingDim / 2);
        const x1 = working.slice(0, half);
        const x2 = working.slice(half);
        
        const f_out = new Float32Array(half);
        for(let i = 0; i < half; i++) {
            let sum = 0;
            const score = attn.scores[i % 16];
            
            const hyperMod = 1 + tanh(score * 2) * (this.mode === 'hyper' ? 0.3 : 0);
            
            if(this.mode === 'classic') {
                const mod = 1 + score * 0.5;
                for(let j = 0; j < half; j++) {
                    sum += x2[j] * this.W_f[i][j] * mod * hyperMod;
                }
            } else {
                const phase = score * Math.PI;
                const scale = (0.5 + 0.5 * sin(phase)) * hyperMod;
                const rotate = cos(phase) * 0.3;
                
                for(let j = 0; j < half; j++) {
                    sum += x2[j] * this.W_f[i][j] * scale;
                }
                if(i < x1.length) {
                    sum += x1[i] * rotate;
                }
            }
            f_out[i] = tanh(sum);
        }
        
        const y1 = x1.map((v, i) => v + f_out[i]);
        
        const g_out = new Float32Array(half);
        for(let i = 0; i < half; i++) {
            let sum = 0;
            for(let j = 0; j < half; j++) {
                sum += y1[j] * this.W_g[i][j];
            }
            g_out[i] = tanh(sum);
        }
        
        const y2 = x2.map((v, i) => v + g_out[i]);
        
        const newState = new Float32Array(this.dim);
        newState.set(y1, 0);
        newState.set(y2, half);
        newState.set(newMem, this.workingDim);
        
        return {
            state: newState,
            commands: decision.commands,
            attention: attn.scores,
            hyperMods: attn.hyperMods,
            patterns: this.driver.getPatternsUsed(),
            interference: this.attention.lastInterference,
            entropy: this.attention.lastEntropy,
            interferenceActive: this.attention.lastInterferenceActive,
            headPrefs: attn.headPrefs,
            attentionConfidence: attn.attentionConfidence
        };
    }
}

class RotorSystem {
    constructor(alphabet, password, mode = 'classic') {
        this.alphabet = alphabet;
        this.N = alphabet.length;
        this.mode = mode;
        
        this.charToIdx = {};
        for(let i = 0; i < this.N; i++) {
            this.charToIdx[alphabet[i]] = i;
        }
        
        const rng = new SeededRandom(password + "_ROTORS");
        this.rotors = [];
        this.rotorsInv = [];
        
        for(let i = 0; i < 4; i++) {
            const arr = alphabet.split('');
            for(let j = arr.length - 1; j > 0; j--) {
                const k = rng.nextInt(j + 1);
                [arr[j], arr[k]] = [arr[k], arr[j]];
            }
            this.rotors.push(arr);
            
            const inv = new Array(this.N);
            for(let pos = 0; pos < this.N; pos++) {
                inv[this.charToIdx[arr[pos]]] = pos;
            }
            this.rotorsInv.push(inv);
        }
        
        this.positions = [0, 0, 0, 0];
        this.phases = [0, 0, 0, 0];
        this.hyperMods = [0, 0, 0, 0];
    }
    
    reset() {
        this.positions = [0, 0, 0, 0];
        this.phases = [0, 0, 0, 0];
        this.hyperMods = [0, 0, 0, 0];
    }
    
    update(commands) {
        for(let r = 0; r < 4; r++) {
            if(!commands[r].active) continue;
            const c = commands[r];
            
            this.positions[r] = mod(
                this.positions[r] + c.delta * c.speed * c.dir, 
                this.N
            );
            
            if(this.mode === 'neural' || this.mode === 'hyper') {
                this.phases[r] = parseFloat(c.phase);
                this.hyperMods[r] = parseFloat(c.hyperMod || 0);
            }
        }
    }
    
    transform(idx) {
        for(let r = 0; r < 4; r++) {
            let pos = this.positions[r];
            
            if((this.mode === 'neural' || this.mode === 'hyper') && this.phases[r] !== 0) {
                const phaseShift = Math.floor(sin(this.phases[r]) * 2);
                pos = mod(pos + phaseShift, this.N);
            }
            
            const shifted = mod(idx + pos, this.N);
            const mapped = this.charToIdx[this.rotors[r][shifted]];
            idx = mod(mapped - pos, this.N);
        }
        return idx;
    }
    
    inverseTransform(idx) {
        for(let r = 3; r >= 0; r--) {
            let pos = this.positions[r];
            
            if((this.mode === 'neural' || this.mode === 'hyper') && this.phases[r] !== 0) {
                const phaseShift = Math.floor(sin(this.phases[r]) * 2);
                pos = mod(pos + phaseShift, this.N);
            }
            
            const shifted = mod(idx + pos, this.N);
            const mapped = this.rotorsInv[r][shifted];
            idx = mod(mapped - pos, this.N);
        }
        return idx;
    }
}

class EntropyAnalyzer {
    constructor(alphabet) {
        this.alphabet = alphabet;
        this.N = alphabet.length;
        this.charCounts = new Map();
        this.totalChars = 0;
        this.maxEntropy = Math.log2(this.N);
    }
    
    reset() {
        this.charCounts.clear();
        this.totalChars = 0;
    }
    
    addChar(char) {
        if(!this.alphabet.includes(char)) return;
        
        this.charCounts.set(char, (this.charCounts.get(char) || 0) + 1);
        this.totalChars++;
    }
    
    calculateLocalEntropy(text, windowSize = 16) {
        if(text.length < windowSize) return 0;
        
        const window = text.slice(-windowSize);
        const freq = new Map();
        
        for(const char of window) {
            if(this.alphabet.includes(char)) {
                freq.set(char, (freq.get(char) || 0) + 1);
            }
        }
        
        let entropy = 0;
        for(const count of freq.values()) {
            const p = count / windowSize;
            if(p > 0) {
                entropy -= p * Math.log2(p);
            }
        }
        
        return entropy;
    }
    
    calculateGlobalEntropy() {
        if(this.totalChars === 0) return 0;
        
        let entropy = 0;
        for(const count of this.charCounts.values()) {
            const p = count / this.totalChars;
            if(p > 0) {
                entropy -= p * Math.log2(p);
            }
        }
        
        return entropy;
    }
    
    getEntropyPercent() {
        const global = this.calculateGlobalEntropy();
        return (global / this.maxEntropy) * 100;
    }
}

class CryptoEngine {
    constructor(alphabet, password, mode = 'classic', perfMode = 'quality') {
        this.alphabet = alphabet;
        this.N = alphabet.length;
        this.mode = mode;
        this.perfMode = perfMode;
        
        this.dim = 338;
        this.blocks = 12;
        this.workingDim = Math.floor(this.dim * 0.7);
        this.memoryDim = this.dim - this.workingDim;
        
        this.buffers = new BufferPool(this.dim, this.workingDim, this.memoryDim);
        
        this.blocks_data = [];
        for(let b = 0; b < this.blocks; b++) {
            this.blocks_data.push(new DriverBlock(
                this.dim, password, b, mode, perfMode
            ));
        }
        
        const rng = new SeededRandom(password + "_INPUT");
        this.W_input = rng.generateOrthogonalMatrix(this.dim, 6, 0.3);
        
        this.rotors = new RotorSystem(alphabet, password, mode);
        this.cmdHashes = [];
        this.entropyAnalyzer = new EntropyAnalyzer(alphabet);
    }
    
    initState(step, prevCipher, context) {
        const input = [
            (step % 50) / 50,
            prevCipher / this.N,
            ...context.map(c => c / this.N)
        ];
        
        const state = new Float32Array(this.dim);
        for(let i = 0; i < this.dim; i++) {
            let sum = 0;
            for(let j = 0; j < 6; j++) {
                sum += input[j] * this.W_input[i][j];
            }
            state[i] = tanh(sum);
        }
        return state;
    }
    
    processState(state, step) {
        let current = state;
        let commands = null, attention = null, patterns = new Set();
        let interference = null, entropy = 0, interferenceActive = 0;
        let hyperMods = null, headPrefs = null, attentionConfidence = 0;
        
        const maxBlocks = this.perfMode === 'turbo' ? 8 : this.blocks;
        
        for(let b = 0; b < this.blocks; b++) {
            const result = this.blocks_data[b].forward(current, step, this.buffers);
            current = result.state;
            
            if(this.perfMode === 'turbo' && b >= maxBlocks - 1) {
                if(b < this.blocks - 1) {
                    current = Float32Array.from(current);
                }
            }
            
            if(b === this.blocks - 1) {
                commands = result.commands;
                attention = result.attention;
                patterns = result.patterns;
                interference = result.interference;
                entropy = result.entropy;
                interferenceActive = result.interferenceActive;
                hyperMods = result.hyperMods;
                headPrefs = result.headPrefs;
                attentionConfidence = result.attentionConfidence;
            }
        }
        
        return { 
            state: current, 
            commands, 
            attention, 
            patterns, 
            interference, 
            entropy, 
            interferenceActive,
            hyperMods,
            headPrefs,
            attentionConfidence
        };
    }
    
    _hashCommands(commands) {
        let hash = 0;
        for(const c of commands) {
            hash = ((hash << 5) - hash + c.delta + c.dir * 100 + c.speed * 1000) | 0;
            if(this.mode === 'hyper') {
                hash = ((hash << 3) - hash + Math.floor(c.hyperMod * 100)) | 0;
                hash = ((hash << 2) - hash + Math.floor(c.confidence * 100)) | 0;
            }
        }
        return hash >>> 0;
    }
    
    encrypt(text) {
        this.rotors.reset();
        this.cmdHashes = [];
        this.entropyAnalyzer.reset();
        
        let result = "", prevCipherIdx = 0, context = [0, 0, 0, 0];
        const logData = [], allPatterns = new Set();
        const interferenceLog = [];
        
        const startTime = performance.now();
        
        for(let i = 0; i < text.length; i++) {
            const char = text[i];
            const idx = this.rotors.charToIdx[char];
            
            if(idx === undefined) {
                result += char;
                continue;
            }
            
            const innState = this.initState(i, prevCipherIdx, context);
            const proc = this.processState(innState, i);
            
            this.rotors.update(proc.commands);
            const newIdx = this.rotors.transform(idx);
            const newChar = this.alphabet[newIdx];
            
            result += newChar;
            prevCipherIdx = newIdx;
            context = [context[1], context[2], context[3], newIdx];
            
            this.entropyAnalyzer.addChar(newChar);
            
            proc.patterns.forEach(p => allPatterns.add(p));
            if(proc.interference) interferenceLog.push(proc.interference);
            
            if(i % 3 === 0 || i < 3) {
                const localEntropy = this.entropyAnalyzer.calculateLocalEntropy(result);
                const globalEntropy = this.entropyAnalyzer.calculateGlobalEntropy();
                
                logData.push({
                    step: i, char, cipher: newChar,
                    commands: proc.commands.map(c => ({...c})),
                    positions: [...this.rotors.positions],
                    patternCount: allPatterns.size,
                    attention: proc.attention,
                    interference: proc.interference,
                    entropy: proc.entropy,
                    interferenceActive: proc.interferenceActive,
                    hyperMods: proc.hyperMods,
                    headPrefs: proc.headPrefs,
                    attentionConfidence: proc.attentionConfidence,
                    localEntropy,
                    globalEntropy,
                    entropyPercent: this.entropyAnalyzer.getEntropyPercent(),
                    cmdHash: this._hashCommands(proc.commands)
                });
            }
            this.cmdHashes.push(this._hashCommands(proc.commands));
        }
        
        const elapsed = performance.now() - startTime;
        const finalLocalEntropy = this.entropyAnalyzer.calculateLocalEntropy(result);
        const finalGlobalEntropy = this.entropyAnalyzer.calculateGlobalEntropy();
        const finalEntropyPercent = this.entropyAnalyzer.getEntropyPercent();
        
        return {
            text: result,
            logData,
            totalPatterns: allPatterns.size,
            interference: interferenceLog,
            time: elapsed,
            symbolsPerSec: (text.length / elapsed * 1000).toFixed(0),
            localEntropy: finalLocalEntropy,
            globalEntropy: finalGlobalEntropy,
            entropyPercent: finalEntropyPercent
        };
    }
    
    decrypt(text) {
        this.rotors.reset();
        this.entropyAnalyzer.reset();
        
        let result = "", prevCipherIdx = 0, context = [0, 0, 0, 0];
        const logData = [];
        
        for(let i = 0; i < text.length; i++) {
            const char = text[i];
            const idx = this.rotors.charToIdx[char];
            
            if(idx === undefined) {
                result += char;
                continue;
            }
            
            const innState = this.initState(i, prevCipherIdx, context);
            const proc = this.processState(innState, i);
            
            this.rotors.update(proc.commands);
            const newIdx = this.rotors.inverseTransform(idx);
            const newChar = this.alphabet[newIdx];
            
            result += newChar;
            prevCipherIdx = idx;
            context = [context[1], context[2], context[3], idx];
            
            const expectedHash = this.cmdHashes[i];
            const actualHash = this._hashCommands(proc.commands);
            if(expectedHash !== actualHash && this.perfMode === 'debug') {
                console.warn(`Hash mismatch at step ${i}`);
            }
            
            if(i % 3 === 0 || i < 3) {
                logData.push({
                    step: i, char, plain: newChar,
                    commands: proc.commands.map(c => ({...c})),
                    positions: [...this.rotors.positions],
                    attention: proc.attention,
                    hyperMods: proc.hyperMods
                });
            }
        }
        
        return { text: result, logData };
    }
    
    get charToIdx() {
        if(!this._charToIdx) {
            this._charToIdx = {};
            for(let i = 0; i < this.alphabet.length; i++) {
                this._charToIdx[this.alphabet[i]] = i;
            }
        }
        return this._charToIdx;
    }
}

const ACTIVATION_PATTERNS = [
    [0,0,0,0], [1,0,0,0], [0,1,0,0], [0,0,1,0], [0,0,0,1],
    [1,1,0,0], [1,0,1,0], [1,0,0,1], [0,1,1,0], [0,1,0,1],
    [0,0,1,1], [1,1,1,0], [1,1,0,1], [1,0,1,1], [0,1,1,1], [1,1,1,1]
];

const CHAR_HEIGHT = 28;
const ROTOR_COUNT = 4;

let engine = null;
let currentMode = 'classic';
let currentPerf = 'quality';

function setMode(mode) {
    currentMode = mode;
    document.getElementById('modeClassic').classList.toggle('active', mode === 'classic');
    document.getElementById('modeNeural').classList.toggle('active', mode === 'neural');
    document.getElementById('modeHyper').classList.toggle('active', mode === 'hyper');
    
    document.querySelectorAll('.hyper-row').forEach(el => {
        el.style.display = mode === 'hyper' ? 'flex' : 'none';
    });
    
    log(`üîÑ Mode: ${mode === 'classic' ? 'CLASSIC v17.3' : mode === 'neural' ? 'NEURAL v18.0' : 'HYPER v20.1 ADAPTIVE'}`, 'info');
    init();
}

function setPerf(mode) {
    currentPerf = mode;
    document.getElementById('perfQuality').classList.toggle('active', mode === 'quality');
    document.getElementById('perfTurbo').classList.toggle('active', mode === 'turbo');
    document.getElementById('perfDebug').classList.toggle('active', mode === 'debug');
    document.getElementById('perfIndicator').textContent = 
        mode === 'quality' ? 'üß† Quality' : mode === 'turbo' ? '‚ö° Turbo' : 'üîç Debug';
    log(`‚öôÔ∏è Performance: ${mode.toUpperCase()}`, 'perf');
    if(engine) init();
}

function init() {
    const alpha = document.getElementById('alphabet').value;
    const pass = document.getElementById('password').value;
    
    engine = null;
    engine = new CryptoEngine(alpha, pass, currentMode, currentPerf);
    renderRotors();
    
    if(currentMode === 'hyper') {
        log('üîÆ Adaptive Expert: Dynamic ranges from attention confidence', 'hyper');
        log('üìä Entropy Analysis: Real-time Shannon entropy monitoring', 'entropy');
        log('‚úÖ All modifications are deterministic and reversible', 'ok');
    } else if(currentMode === 'neural') {
        log('üß† Neural Dynamics: phase modulation + resonance + interference', 'phase');
    } else {
        log('üé° Classic mode: independent rotors', 'info');
    }
}

function renderRotors() {
    const container = document.getElementById('rotorViz');
    let html = '';
    
    for(let i = 0; i < ROTOR_COUNT; i++) {
        html += `<div class="rotor" id="rotor-${i}">`;
        html += `<div class="rotor-label">ROTOR ${i+1}<span class="rotor-phase" id="phase-${i}"></span><span class="rotor-hyper" id="hyper-${i}"></span></div>`;
        html += `<div class="rotor-display"><div class="rotor-tape" id="rotor-tape-${i}">`;
        
        const chars = engine.rotors.rotors[i];
        for(let k = 0; k < 3; k++) {
            chars.forEach((c, idx) => {
                html += `<div class="rotor-char" data-idx="${k * engine.N + idx}">${c}</div>`;
            });
        }
        html += `</div></div>`;
        html += `<div class="rotor-info" id="r${i}-info"></div>`;
        html += `<div class="rotor-resonance" id="res${i}-info"></div>`;
        html += `<div class="rotor-hyper-info" id="hyp${i}-info"></div>`;
        html += `</div>`;
    }
    container.innerHTML = html;
}

function updateRotors(commands, positions, attention, interference, hyperMods) {
    for(let r = 0; r < ROTOR_COUNT; r++) {
        const rotor = document.getElementById(`rotor-${r}`);
        const tape = document.getElementById(`rotor-tape-${r}`);
        const info = document.getElementById(`r${r}-info`);
        const phaseSpan = document.getElementById(`phase-${r}`);
        const hyperSpan = document.getElementById(`hyper-${r}`);
        const resSpan = document.getElementById(`res${r}-info`);
        const hypInfo = document.getElementById(`hyp${r}-info`);
        const chars = tape.querySelectorAll('.rotor-char');
        
        rotor.classList.toggle('active', commands[r].active);
        if(currentMode === 'neural' || currentMode === 'hyper') {
            rotor.classList.toggle('phase-active', Math.abs(parseFloat(commands[r].phase)) > 1);
        }
        if(currentMode === 'hyper') {
            rotor.classList.toggle('hyper-active', Math.abs(parseFloat(commands[r].hyperMod)) > 0.1);
        }
        
        let infoText = `POS:${positions[r]} Œî:${commands[r].delta} S:${commands[r].speed}`;
        if(currentPerf === 'debug') {
            infoText += ` C:${commands[r].confidence} R:${commands[r].dynRange}`;
        }
        info.textContent = infoText;
        
        if(currentMode === 'neural' || currentMode === 'hyper') {
            phaseSpan.textContent = `œÜ:${commands[r].phase}`;
            resSpan.textContent = `‚ö°${commands[r].resonance}`;
        } else {
            phaseSpan.textContent = '';
            resSpan.textContent = '';
        }
        
        if(currentMode === 'hyper') {
            hyperSpan.textContent = `üîÆ${commands[r].hyperMod}`;
            hypInfo.textContent = `Conf:${commands[r].confidence} Range:${commands[r].dynRange}`;
        } else {
            hyperSpan.textContent = '';
            hypInfo.textContent = '';
        }
        
        const scrollPos = -(positions[r] * CHAR_HEIGHT) + Math.floor(CHAR_HEIGHT * 1.5);
        tape.style.transform = `translateY(${scrollPos}px)`;
        
        chars.forEach(c => {
            c.classList.remove('active', 'interference', 'hyper-mod');
            const cidx = parseInt(c.dataset.idx) % engine.N;
            if(cidx === positions[r]) {
                c.classList.add('active');
                if((currentMode === 'neural' || currentMode === 'hyper') && interference?.[r]) {
                    const intVal = Math.abs(interference[r][0] || 0);
                    if(intVal > 0.05) c.classList.add('interference');
                }
                if(currentMode === 'hyper' && hyperMods?.[r]) {
                    if(Math.abs(hyperMods[r]) > 0.1) c.classList.add('hyper-mod');
                }
            }
        });
    }
}

function updateHeadPrefsGrid(headPrefs, attention) {
    if(!headPrefs || currentMode !== 'hyper') {
        document.getElementById('headPrefsGrid').innerHTML = '';
        return;
    }
    
    let html = '';
    for(let h = 0; h < 16; h++) {
        const spec = headPrefs.getSpecialization(h);
        const strength = headPrefs.getStrength(h);
        const score = attention?.[h] || 0;
        const isActive = Math.abs(score) > 0.3;
        
        html += `<div class="head-cell ${isActive ? 'hyper-active' : ''}">`;
        html += `<span class="spec">${spec.substring(0, 4)}</span>`;
        html += `<span class="strength">S:${strength.toFixed(2)}</span>`;
        html += `</div>`;
    }
    document.getElementById('headPrefsGrid').innerHTML = html;
}

function updateDynamicsPanel(logData, interference, hyperMods) {
    if(!logData?.length) return;
    
    const last = logData[logData.length - 1];
    
    if(last.commands) {
        const avgPhase = last.commands.reduce((sum, c) => sum + Math.abs(parseFloat(c.phase) || 0), 0) / 4;
        document.getElementById('phaseValue').textContent = avgPhase.toFixed(3);
        
        const avgRes = last.commands.reduce((sum, c) => sum + Math.abs(parseFloat(c.resonance) || 0), 0) / 4;
        document.getElementById('resonanceValue').textContent = avgRes.toFixed(3);
        
        if(currentMode === 'hyper') {
            const avgConf = last.commands.reduce((sum, c) => sum + parseFloat(c.confidence || 0), 0) / 4;
            document.getElementById('confidenceValue').textContent = avgConf.toFixed(3);
        }
    }
    
    if(last.localEntropy !== undefined) {
        document.getElementById('localEntropyValue').textContent = (last.localEntropy || 0).toFixed(2);
        document.getElementById('globalEntropyValue').textContent = (last.globalEntropy || 0).toFixed(2);
        
        const maxEntropy = Math.log2(36);
        const percent = ((last.globalEntropy || 0) / maxEntropy) * 100;
        document.getElementById('entropyBar').style.width = `${Math.min(100, percent)}%`;
        document.getElementById('entropyPercent').textContent = `${percent.toFixed(1)}% –æ—Ç –º–∞–∫—Å–∏–º—É–º–∞`;
    }
    
    if(interference?.length && (currentMode === 'neural' || currentMode === 'hyper')) {
        const grid = document.getElementById('interferenceGrid');
        const lastInterf = interference[interference.length - 1];
        
        if(lastInterf) {
            let html = '';
            const displaySize = 4;
            for(let h = 0; h < displaySize; h++) {
                for(let k = 0; k < displaySize; k++) {
                    const val = lastInterf[h]?.[k] || 0;
                    const active = Math.abs(val) > 0.05;
                    html += `<div class="interference-cell ${active ? 'active' : ''}">${val.toFixed(2)}</div>`;
                }
            }
            grid.innerHTML = html;
            
            let activeCount = 0;
            for(let h = 0; h < 16; h++) {
                for(let k = 0; k < 16; k++) {
                    if(lastInterf[h]?.[k] && Math.abs(lastInterf[h][k]) > 0.05) activeCount++;
                }
            }
            document.getElementById('interferenceValue').textContent = `${activeCount}/256`;
        }
    }
    
    updateHeadPrefsGrid(last.headPrefs, last.attention);
}

function copyOutput() {
    const text = document.getElementById('outputText').textContent;
    if(text && text !== '–û–∂–∏–¥–∞–Ω–∏–µ...') {
        navigator.clipboard.writeText(text).then(() => {
            log('‚úÖ Copied to clipboard', 'ok');
        });
    }
}

function run(mode) {
    const alpha = document.getElementById('alphabet').value;
    const pass = document.getElementById('password').value;
    const input = document.getElementById('inputText').value;
    
    if(!input.trim()) {
        alert('Please enter text to process');
        return;
    }
    
    engine = new CryptoEngine(alpha, pass, currentMode, currentPerf);
    const isEncrypt = mode === 'encrypt';
    
    const start = performance.now();
    const res = isEncrypt ? engine.encrypt(input) : engine.decrypt(input);
    const elapsed = performance.now() - start;
    
    document.getElementById('outputText').textContent = res.text;
    document.getElementById('statLen').textContent = `${input.length} ‚Üí ${res.text.length}`;
    document.getElementById('statTime').textContent = `${elapsed.toFixed(1)}ms (${res.symbolsPerSec || (input.length/elapsed*1000).toFixed(0)} sym/s)`;
    
    if(res.logData?.length) {
        const last = res.logData[res.logData.length - 1];
        updateRotors(last.commands, last.positions, last.attention, res.interference?.[0], last.hyperMods);
        document.getElementById('statPatterns').textContent = `${last.patternCount || 0}/16`;
        updateDynamicsPanel(res.logData, res.interference, last.hyperMods);
    }
    
    if(res.globalEntropy) {
        document.getElementById('globalEntropyValue').textContent = res.globalEntropy.toFixed(2);
        document.getElementById('localEntropyValue').textContent = (res.localEntropy || 0).toFixed(2);
        const maxEntropy = Math.log2(36);
        const percent = (res.globalEntropy / maxEntropy) * 100;
        document.getElementById('entropyBar').style.width = `${Math.min(100, percent)}%`;
        document.getElementById('entropyPercent').textContent = `${percent.toFixed(1)}% –æ—Ç –º–∞–∫—Å–∏–º—É–º–∞`;
    }
    
    log(`${isEncrypt ? 'üîí Encrypted' : 'üîì Decrypted'} ${input.length} symbols in ${elapsed.toFixed(1)}ms`, 'info');
    
    if(isEncrypt) {
        const testEngine = new CryptoEngine(alpha, pass, currentMode, currentPerf);
        const check = testEngine.decrypt(res.text);
        const ok = check.text === input;
        
        document.getElementById('statRev').textContent = ok ? '‚úÖ OK' : '‚ùå FAIL';
        document.getElementById('statRev').className = 'stat-value ' + (ok ? 'ok' : 'err');
        
        log(ok ? '‚úÖ Reversibility verified' : '‚ùå Reversibility FAILED!', ok ? 'ok' : 'err');
        
        if(currentMode === 'hyper' && res.logData?.[0]) {
            const avgConf = res.logData[0].commands.reduce((s, c) => s + parseFloat(c.confidence), 0) / 4;
            log(`üîÆ Confidence: ${avgConf.toFixed(2)} (Adaptive ranges active)`, 'hyper');
            log(`üìä Entropy: ${res.globalEntropy.toFixed(2)} bit/sym (${res.entropyPercent.toFixed(1)}%)`, 'entropy');
        }
    }
}

function runTest() {
    const alpha = document.getElementById('alphabet').value;
    const pass = document.getElementById('password').value;
    const input = document.getElementById('inputText').value || 'TEST123';
    
    log('üß™ Running reversibility test...', 'info');
    
    let current = input;
    const rounds = 3;
    let allPassed = true;
    
    for(let round = 0; round < rounds; round++) {
        const encEngine = new CryptoEngine(alpha, pass, currentMode, currentPerf);
        const encrypted = encEngine.encrypt(current);
        
        const decEngine = new CryptoEngine(alpha, pass, currentMode, currentPerf);
        const decrypted = decEngine.decrypt(encrypted.text);
        
        const passed = decrypted.text === current;
        allPassed = allPassed && passed;
        
        log(`Round ${round + 1}: ${passed ? '‚úÖ' : '‚ùå'} "${current}" ‚Üí "${encrypted.text}" ‚Üí "${decrypted.text}"`, passed ? 'ok' : 'err');
        
        if(passed && currentMode === 'hyper') {
            log(`  Entropy: ${encrypted.globalEntropy.toFixed(2)} bit/sym (${encrypted.entropyPercent.toFixed(1)}%)`, 'entropy');
        }
        
        current = encrypted.text;
    }
    
    log(allPassed ? `‚úÖ All ${rounds} rounds passed` : `‚ùå Test failed`, allPassed ? 'ok' : 'err');
}

function log(msg, type = 'info') {
    const container = document.getElementById('log');
    const entry = document.createElement('div');
    entry.className = `log-entry ${type}`;
    entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    container.insertBefore(entry, container.firstChild);
    
    while(container.children.length > 20) {
        container.removeChild(container.lastChild);
    }
}

window.addEventListener('load', () => {
    init();
    log('‚úÖ True ITN v20.1 Adaptive Expert initialized', 'ok');
    log(`üìä Optimizations: Dynamic expert ranges, Attention confidence, No hardcoded multipliers`, 'hyper');
    log(`üîí Reversibility: All weight modifications are deterministic from state`, 'ok');
});

document.addEventListener('keydown', (e) => {
    if(e.ctrlKey && e.key === 'Enter') {
        e.preventDefault();
        run('encrypt');
    } else if(e.ctrlKey && e.key === 'Backspace') {
        e.preventDefault();
        run('decrypt');
    }
});
</script>
</body>
</html>
