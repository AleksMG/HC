
                        <!DOCTYPE html>
                        <html lang="en">
                        <head>
                            <meta charset="UTF-8">
                            <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <style>
                body {
                  background-color: white; /* Ensure the iframe has a white background */
                }

                
              </style>
                        </head>
                        <body>
                            <!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ö° True ITN v17.3 ‚Äî Independent Rotors</title>
    <style>
        :root {
            --bg: #050510;
            --panel: #0f0f1a;
            --text: #e0e0e0;
            --primary: #00f2ff;
            --accent: #ff0055;
            --success: #00ff9d;
            --border: #2a2a40;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', sans-serif; }
        body { background: var(--bg); color: var(--text); padding: 30px; }
        .container { max-width: 1200px; margin: 0 auto; }

        header { text-align: center; margin-bottom: 40px; }
        h1 { color: var(--primary); font-size: 2.2rem; margin-bottom: 8px; text-shadow: 0 0 20px rgba(0,242,255,0.3); }
        .subtitle { color: #666; font-size: 0.95rem; }

        .main-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 25px; }
        @media (max-width: 1000px) { .main-grid { grid-template-columns: 1fr; } }

        .panel {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
        }

        .panel-title {
            color: var(--primary);
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .input-group { margin-bottom: 18px; }
        label { display: block; color: var(--primary); margin-bottom: 8px; font-weight: 600; font-size: 0.85rem; }
        
        input, textarea {
            width: 100%; background: #0a0a15; border: 2px solid var(--border);
            color: var(--text); padding: 14px; border-radius: 10px;
            font-size: 0.95rem; font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }
        input:focus, textarea:focus { 
            outline: none; 
            border-color: var(--primary);
            box-shadow: 0 0 15px rgba(0,242,255,0.15);
        }

        .controls { display: flex; gap: 12px; margin-top: 22px; }
        button {
            flex: 1; padding: 14px; border: none; border-radius: 10px;
            font-weight: 700; cursor: pointer; text-transform: uppercase;
            font-size: 0.9rem; transition: all 0.3s; letter-spacing: 0.5px;
        }
        .btn-enc { background: var(--primary); color: #000; }
        .btn-enc:hover { background: #fff; transform: translateY(-2px); box-shadow: 0 5px 20px rgba(0,242,255,0.4); }
        .btn-dec { background: var(--accent); color: #fff; }
        .btn-dec:hover { background: #ff5588; transform: translateY(-2px); box-shadow: 0 5px 20px rgba(255,0,85,0.4); }
        .btn-copy { 
            background: #1a1a2e; color: var(--text); 
            flex: 0.4; font-size: 0.85rem; border: 1px solid var(--border);
        }
        .btn-copy:hover { background: #2a2a40; }

        .output-box {
            background: #000;
            border: 2px solid var(--success);
            border-radius: 10px;
            padding: 18px;
            min-height: 100px;
            font-size: 1.05rem;
            word-break: break-all;
            color: var(--success);
            font-family: 'Courier New', monospace;
            margin-bottom: 15px;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            padding-top: 15px;
            border-top: 1px solid var(--border);
            font-size: 0.85rem;
        }
        .stat { color: #888; }
        .stat-value { color: var(--primary); font-weight: 700; }
        .stat-value.ok { color: var(--success); }
        .stat-value.err { color: var(--accent); }

        .rotor-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-top: 15px;
        }

        .rotor {
            background: #0a0a15;
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 12px;
            text-align: center;
            transition: all 0.3s;
        }

        .rotor.active { border-color: var(--primary); box-shadow: 0 0 15px rgba(0,242,255,0.15); }

        .rotor-label { color: var(--primary); font-size: 0.75rem; font-weight: 600; margin-bottom: 10px; }

        .rotor-display {
            height: 70px;
            overflow: hidden;
            background: #050510;
            border-radius: 6px;
            position: relative;
            mask-image: linear-gradient(to bottom, transparent, black 20%, black 80%, transparent);
            -webkit-mask-image: linear-gradient(to bottom, transparent, black 20%, black 80%, transparent);
        }

        .rotor-tape {
            position: absolute;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.4s ease;
        }

        .rotor-char {
            height: 30px;
            line-height: 30px;
            font-size: 1.1rem;
            font-weight: 700;
            color: #444;
        }

        .rotor-char.active {
            color: var(--success);
            text-shadow: 0 0 10px var(--success);
            transform: scale(1.4);
        }

        .rotor-info {
            margin-top: 10px;
            font-size: 0.7rem;
            color: #666;
            font-family: 'Courier New', monospace;
        }

        .log {
            background: #000;
            border: 1px solid #333;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            max-height: 140px;
            overflow-y: auto;
            font-size: 0.75rem;
            color: #666;
            font-family: 'Courier New', monospace;
        }

        .log-entry {
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 1px solid #111;
        }

        .log-entry.ok { color: var(--success); }
        .log-entry.err { color: var(--accent); }
        .log-entry.info { color: var(--primary); }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚ö° True ITN v17.3</h1>
            <p class="subtitle">Independent Rotor Values | True Asynchronous Rotation</p>
        </header>

        <div class="main-grid">
            <div class="panel">
                <div class="panel-title">üîê –í–•–û–î</div>
                
                <div class="input-group">
                    <label>üî§ –ê–õ–§–ê–í–ò–¢</label>
                    <input type="text" id="alphabet" value="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789">
                </div>

                <div class="input-group">
                    <label>üîë –ü–ê–†–û–õ–¨</label>
                    <input type="text" id="password" value="ITN_V17">
                </div>

                <div class="input-group">
                    <label>üìù –¢–ï–ö–°–¢</label>
                    <textarea id="inputText" rows="5" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç...">HELLO WORLD</textarea>
                </div>

                <div class="controls">
                    <button class="btn-enc" onclick="run('encrypt')">üîí –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                    <button class="btn-dec" onclick="run('decrypt')">üîì –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title">üìä –†–ï–ó–£–õ–¨–¢–ê–¢</div>
                
                <div class="output-box" id="outputText">–û–∂–∏–¥–∞–Ω–∏–µ...</div>
                
                <div class="controls">
                    <button class="btn-copy" onclick="copyOutput()">üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
                </div>

                <div class="stats-row">
                    <span class="stat">–î–ª–∏–Ω–∞: <span class="stat-value" id="statLen">0</span></span>
                    <span class="stat">–û–±—Ä–∞—Ç–∏–º–æ—Å—Ç—å: <span class="stat-value" id="statRev">-</span></span>
                    <span class="stat">–ü–∞—Ç—Ç–µ—Ä–Ω—ã: <span class="stat-value" id="statPatterns">0/16</span></span>
                    <span class="stat">–í—Ä–µ–º—è: <span class="stat-value" id="statTime">0ms</span></span>
                </div>

                <div class="panel-title" style="margin-top: 25px;">üé° –†–û–¢–û–†–´</div>
                <div class="rotor-grid" id="rotorViz"></div>

                <div class="log" id="log"></div>
            </div>
        </div>
    </div>

<script>
/**
 * TRUE ITN v17.3 ‚Äî INDEPENDENT ROTOR VALUES
 * 
 * –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –û–¢ v17.2:
 * ‚Ä¢ –ö–∞–∂–¥—ã–π —Ä–æ—Ç–æ—Ä –ø–æ–ª—É—á–∞–µ—Ç –ù–ï–ó–ê–í–ò–°–ò–ú–´–ï –∑–Ω–∞—á–µ–Ω–∏—è delta/speed
 * ‚Ä¢ –î–æ–±–∞–≤–ª–µ–Ω rotor-specific noise –¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ—Å—Ç–∏
 * ‚Ä¢ –¢–µ–ø–µ—Ä—å —Ä–æ—Ç–æ—Ä—ã –∫—Ä—É—Ç—è—Ç—Å—è –î–ï–ô–°–¢–í–ò–¢–ï–õ–¨–ù–û –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
 */

const tanh = x => Math.tanh(x);
const mod = (n, m) => ((n % m) + m) % m;

const ACTIVATION_PATTERNS = [
    [0,0,0,0], [1,0,0,0], [0,1,0,0], [0,0,1,0], [0,0,0,1],
    [1,1,0,0], [1,0,1,0], [1,0,0,1], [0,1,1,0], [0,1,0,1],
    [0,0,1,1], [1,1,1,0], [1,1,0,1], [1,0,1,1], [0,1,1,1], [1,1,1,1]
];

class SeededRandom {
    constructor(seedStr) {
        let h = 0x811c9dc5;
        for(let i=0; i<seedStr.length; i++) {
            h ^= seedStr.charCodeAt(i);
            h = Math.imul(h, 0x01000193);
        }
        this.seed = h >>> 0;
    }
    next() {
        this.seed = (this.seed * 1664525 + 1013904223) >>> 0;
        return this.seed / 0xFFFFFFFF;
    }
    nextInt(max) { return Math.floor(this.next() * max); }
}

class SixteenHeadAttention {
    constructor(dim, password) {
        this.dim = dim;
        this.numHeads = 16;
        this.headDim = Math.floor(dim / this.numHeads);
        const rng = new SeededRandom(password + "_ATTN");
        this.W_q = []; this.W_k = []; this.W_v = [];
        for(let h=0; h<this.numHeads; h++) {
            let Wq = [], Wk = [], Wv = [];
            for(let i=0; i<this.headDim; i++) {
                let rq = [], rk = [], rv = [];
                for(let j=0; j<dim; j++) {
                    rq.push((rng.next()*2-1)*0.05);
                    rk.push((rng.next()*2-1)*0.05);
                    rv.push((rng.next()*2-1)*0.05);
                }
                Wq.push(rq); Wk.push(rk); Wv.push(rv);
            }
            this.W_q.push(Wq); this.W_k.push(Wk); this.W_v.push(Wv);
        }
    }
    forward(state) {
        let outputs = [], scores = [];
        for(let h=0; h<this.numHeads; h++) {
            let Q = [], K = [], V = [];
            for(let i=0; i<this.headDim; i++) {
                let qs = 0, ks = 0, vs = 0;
                for(let j=0; j<this.dim; j++) {
                    qs += state[j] * this.W_q[h][i][j];
                    ks += state[j] * this.W_k[h][i][j];
                    vs += state[j] * this.W_v[h][i][j];
                }
                Q.push(tanh(qs)); K.push(tanh(ks)); V.push(tanh(vs));
            }
            let score = 0;
            for(let i=0; i<this.headDim; i++) score += Q[i] * K[i];
            score /= Math.sqrt(this.headDim);
            scores.push(tanh(score));
            for(let i=0; i<this.headDim; i++) outputs.push(V[i] * scores[h]);
        }
        return { output: outputs, scores };
    }
}

class FlexibleDriver {
    constructor(password, workingDim, memoryDim) {
        this.workingDim = workingDim;
        this.memoryDim = memoryDim;
        this.patternsUsed = new Set();
        const rng = new SeededRandom(password + "_DRIVER");
        this.W_pattern = [];
        this.W_decision = [];
        for(let i=0; i<16; i++) {
            let rp = [], rd = [];
            for(let j=0; j<workingDim + memoryDim; j++) {
                rp.push((rng.next()*2-1)*0.1);
                rd.push((rng.next()*2-1)*0.1);
            }
            this.W_pattern.push(rp);
            this.W_decision.push(rd);
        }
        this.W_memory = [];
        for(let i=0; i<memoryDim; i++) {
            let row = [];
            for(let j=0; j<16; j++) row.push((rng.next()*2-1)*0.05);
            this.W_memory.push(row);
        }
        
        // Independent rotor noise weights
        this.W_rotor_noise = [];
        for(let r=0; r<4; r++) {
            let row = [];
            for(let j=0; j<16; j++) {
                row.push((rng.next()*2-1)*0.3);  // Larger variance for independence
            }
            this.W_rotor_noise.push(row);
        }
    }
    
    selectPattern(attentionResult, memory, step) {
        const focus = attentionResult.scores;
        let input = [...focus, ...memory];
        let scores = [];
        for(let p=0; p<16; p++) {
            let sum = 0;
            for(let j=0; j<input.length; j++) sum += input[j] * this.W_pattern[p][j];
            scores.push(sum);
        }
        let max = scores[0], sel = 0;
        for(let p=1; p<16; p++) if(scores[p] > max) { max = scores[p]; sel = p; }
        const final = (sel + step % 5) % 16;
        this.patternsUsed.add(final);
        return ACTIVATION_PATTERNS[final];
    }
    
    decide(attentionResult, memory, step) {
        const activePattern = this.selectPattern(attentionResult, memory, step);
        const focus = attentionResult.scores;
        let input = [...focus, ...memory];
        let values = [];
        for(let i=0; i<16; i++) {
            let sum = 0;
            for(let j=0; j<input.length; j++) sum += input[j] * this.W_decision[i][j];
            values.push(tanh(sum));
        }
        
        let commands = [];
        for(let r=0; r<4; r++) {
            const b = r * 4;
            
            // Base values from neural network
            let delta = Math.floor(values[b] * 10);
            let dir = values[b+1] > 0 ? 1 : -1;
            let speed = Math.floor(Math.abs(values[b+2]) * 7) + 1;
            
            // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –î–æ–±–∞–≤–ª—è–µ–º –ù–ï–ó–ê–í–ò–°–ò–ú–´–ô —à—É–º –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ä–æ—Ç–æ—Ä–∞
            let noiseSum = 0;
            for(let j=0; j<16; j++) {
                noiseSum += values[j] * this.W_rotor_noise[r][j];
            }
            let rotorNoise = tanh(noiseSum) * 5;  // -5 to +5 independent noise
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º —à—É–º —Ç–æ–ª—å–∫–æ –∫ delta (–∫–∞–∂–¥—ã–π —Ä–æ—Ç–æ—Ä –ø–æ–ª—É—á–∞–µ—Ç —Ä–∞–∑–Ω–æ–µ)
            delta = Math.floor(delta + rotorNoise);
            
            // Clamp delta to reasonable range
            delta = Math.max(-10, Math.min(10, delta));
            
            commands.push({
                delta: delta,
                dir: dir,
                speed: speed,
                active: activePattern[r] === 1,
                noise: rotorNoise.toFixed(1)  // For visualization
            });
        }
        return { commands, values, activePattern };
    }
    
    updateMemory(memory, decision) {
        let newMem = [];
        for(let i=0; i<this.memoryDim; i++) {
            let sum = 0;
            for(let j=0; j<16; j++) sum += decision.values[j] * this.W_memory[i][j];
            newMem.push(memory[i] + tanh(sum) * 0.1);
        }
        return newMem;
    }
    getPatternsUsed() { return this.patternsUsed; }
}

class DriverBlock {
    constructor(dim, password, blockId, memoryRatio = 0.3) {
        this.dim = dim;
        this.workingDim = Math.floor(dim * (1 - memoryRatio));
        this.memoryDim = dim - this.workingDim;
        this.attention = new SixteenHeadAttention(this.workingDim, password);
        this.driver = new FlexibleDriver(password, this.workingDim, this.memoryDim);
        const rng = new SeededRandom(password + "_BLOCK_" + blockId);
        this.W_f = []; this.W_g = [];
        for(let i=0; i<this.workingDim; i++) {
            let rf = [], rg = [];
            for(let j=0; j<this.workingDim; j++) {
                rf.push((rng.next()*2-1)*0.1);
                rg.push((rng.next()*2-1)*0.1);
            }
            this.W_f.push(rf); this.W_g.push(rg);
        }
    }
    forward(state, step) {
        const working = state.slice(0, this.workingDim);
        const memory = state.slice(this.workingDim);
        const attn = this.attention.forward(working);
        const decision = this.driver.decide(attn, memory, step);
        const newMem = this.driver.updateMemory(memory, decision);
        const half = Math.floor(this.workingDim / 2);
        const x1 = working.slice(0, half);
        const x2 = working.slice(half);
        let f_out = [];
        for(let i=0; i<x1.length; i++) {
            let sum = 0;
            for(let j=0; j<x2.length; j++) {
                let mod = 1 + attn.scores[i % 16] * 0.5;
                sum += x2[j] * this.W_f[i][j] * mod;
            }
            f_out.push(tanh(sum));
        }
        const y1 = x1.map((v, i) => v + f_out[i]);
        let g_out = [];
        for(let i=0; i<x1.length; i++) {
            let sum = 0;
            for(let j=0; j<x1.length; j++) sum += y1[j] * this.W_g[i][j];
            g_out.push(tanh(sum));
        }
        const y2 = x2.map((v, i) => v + g_out[i]);
        return {
            state: [...y1, ...y2, ...newMem],
            commands: decision.commands,
            attention: attn.scores,
            patterns: this.driver.getPatternsUsed()
        };
    }
}

class CryptoEngine {
    constructor(alphabet, password) {
        this.alphabet = alphabet;
        this.N = alphabet.length;
        this.dim = 338;
        this.blocks = 12;
        this.blocks_data = [];
        for(let b=0; b<this.blocks; b++) {
            this.blocks_data.push(new DriverBlock(this.dim, password, b));
        }
        const rng = new SeededRandom(password + "_INPUT");
        this.W_input = [];
        for(let i=0; i<this.dim; i++) {
            let row = [];
            for(let j=0; j<6; j++) row.push((rng.next()*2-1)*0.3);
            this.W_input.push(row);
        }
        this.rotors = new RotorSystem(alphabet, password);
    }
    initState(step, prevCipher, context) {
        let input = [(step%50)/50, prevCipher/this.N, context[0]/this.N, context[1]/this.N, context[2]/this.N, context[3]/this.N];
        let state = [];
        for(let i=0; i<this.dim; i++) {
            let sum = 0;
            for(let j=0; j<6; j++) sum += input[j] * this.W_input[i][j];
            state.push(tanh(sum));
        }
        return state;
    }
    processState(state, step) {
        let current = state.slice();
        let commands = null, attention = null, patterns = new Set();
        for(let b=0; b<this.blocks; b++) {
            let result = this.blocks_data[b].forward(current, step);
            current = result.state;
            if(b === this.blocks - 1) {
                commands = result.commands;
                attention = result.attention;
                patterns = result.patterns;
            }
        }
        return { state: current, commands, attention, patterns };
    }
    encrypt(text) {
        this.rotors.reset();
        let result = "", prevCipherIdx = 0, context = [0,0,0,0];
        let logData = [], allPatterns = new Set();
        for(let i=0; i<text.length; i++) {
            let char = text[i], idx = this.alphabet.indexOf(char);
            if(idx === -1) { result += char; continue; }
            let innState = this.initState(i, prevCipherIdx, context);
            let proc = this.processState(innState, i);
            this.rotors.update(proc.commands);
            let newIdx = this.rotors.transform(idx);
            let newChar = this.alphabet[newIdx];
            result += newChar;
            prevCipherIdx = newIdx;
            context = [context[1], context[2], context[3], newIdx];
            proc.patterns.forEach(p => allPatterns.add(p));
            if(i % 3 === 0 || i < 3) {
                logData.push({ step: i, char, cipher: newChar, commands: proc.commands, positions: [...this.rotors.positions], patternCount: allPatterns.size });
            }
        }
        return { text: result, logData, totalPatterns: allPatterns.size };
    }
    decrypt(text) {
        this.rotors.reset();
        let result = "", prevCipherIdx = 0, context = [0,0,0,0];
        let logData = [];
        for(let i=0; i<text.length; i++) {
            let char = text[i], idx = this.alphabet.indexOf(char);
            if(idx === -1) { result += char; continue; }
            let innState = this.initState(i, prevCipherIdx, context);
            let proc = this.processState(innState, i);
            this.rotors.update(proc.commands);
            let newIdx = this.rotors.inverseTransform(idx);
            let newChar = this.alphabet[newIdx];
            result += newChar;
            prevCipherIdx = idx;
            context = [context[1], context[2], context[3], idx];
            if(i % 3 === 0 || i < 3) {
                logData.push({ step: i, char, plain: newChar, commands: proc.commands, positions: [...this.rotors.positions] });
            }
        }
        return { text: result, logData };
    }
}

class RotorSystem {
    constructor(alphabet, password) {
        this.alphabet = alphabet;
        this.N = alphabet.length;
        const rng = new SeededRandom(password + "_ROTORS");
        this.rotors = [];
        for(let i=0; i<4; i++) {
            let arr = this.alphabet.split('');
            for(let j=arr.length-1; j>0; j--) {
                const k = rng.nextInt(j+1);
                [arr[j], arr[k]] = [arr[k], arr[j]];
            }
            this.rotors.push(arr);
        }
        this.positions = [0,0,0,0];
    }
    reset() { this.positions = [0,0,0,0]; }
    update(commands) {
        for(let r=0; r<4; r++) {
            if(!commands[r].active) continue;
            const c = commands[r];
            this.positions[r] = mod(this.positions[r] + c.delta * c.speed * c.dir, this.N);
        }
    }
    transform(idx) {
        for(let r=0; r<4; r++) {
            let pos = this.positions[r];
            let shifted = mod(idx + pos, this.N);
            let mapped = this.alphabet.indexOf(this.rotors[r][shifted]);
            idx = mod(mapped - pos, this.N);
        }
        return idx;
    }
    inverseTransform(idx) {
        for(let r=3; r>=0; r--) {
            let pos = this.positions[r];
            let shifted = mod(idx + pos, this.N);
            let mapped = this.rotors[r].indexOf(this.alphabet[shifted]);
            idx = mod(mapped - pos, this.N);
        }
        return idx;
    }
}

let engine = null;
const CHAR_HEIGHT = 30;

function init() {
    const alpha = document.getElementById('alphabet').value;
    const pass = document.getElementById('password').value;
    engine = new CryptoEngine(alpha, pass);
    renderRotors();
    log("–ì–æ—Ç–æ–≤–æ. Independent rotor values enabled.", "info");
}

function renderRotors() {
    const container = document.getElementById('rotorViz');
    let html = '';
    for(let i=0; i<4; i++) {
        html += '<div class="rotor" id="rotor-'+i+'">';
        html += '<div class="rotor-label">ROTOR '+(i+1)+'</div>';
        html += '<div class="rotor-display"><div class="rotor-tape" id="rotor-tape-'+i+'">';
        let chars = engine.rotors.rotors[i];
        for(let k=0; k<3; k++) {
            chars.forEach((c, idx) => {
                html += '<div class="rotor-char" data-idx="'+(k*engine.N+idx)+'">'+c+'</div>';
            });
        }
        html += '</div></div>';
        html += '<div class="rotor-info" id="r'+i+'-info">POS: 0</div>';
        html += '</div>';
    }
    container.innerHTML = html;
}

function updateRotors(commands, positions) {
    for(let r=0; r<4; r++) {
        const rotor = document.getElementById('rotor-'+r);
        const tape = document.getElementById('rotor-tape-'+r);
        const info = document.getElementById('r'+r+'-info');
        const chars = tape.querySelectorAll('.rotor-char');
        
        rotor.classList.toggle('active', commands[r].active);
        info.innerText = 'POS: ' + positions[r] + ' | Œî:' + commands[r].delta + ' S:' + commands[r].speed;
        
        const scrollPos = -(positions[r] * CHAR_HEIGHT) + 20;
        tape.style.transform = 'translateY(' + scrollPos + 'px)';
        
        chars.forEach(c => {
            c.classList.remove('active');
            const cidx = parseInt(c.dataset.idx) % engine.N;
            if(cidx === positions[r]) c.classList.add('active');
        });
    }
}

function updateViz(logData) {
    if(!logData || logData.length === 0) return;
    const last = logData[logData.length - 1];
    updateRotors(last.commands, last.positions);
    document.getElementById('statPatterns').innerText = (last.patternCount || 0) + '/16';
}

function copyOutput() {
    const text = document.getElementById('outputText').innerText;
    if(text && text !== '–û–∂–∏–¥–∞–Ω–∏–µ...') {
        navigator.clipboard.writeText(text);
        log("‚úÖ –°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!", "ok");
    }
}

function run(mode) {
    const alpha = document.getElementById('alphabet').value;
    const pass = document.getElementById('password').value;
    const input = document.getElementById('inputText').value;
    
    if(!input) { alert("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç!"); return; }
    
    engine = new CryptoEngine(alpha, pass);
    const isEncrypt = mode === 'encrypt';
    
    const start = performance.now();
    const res = isEncrypt ? engine.encrypt(input) : engine.decrypt(input);
    const time = performance.now() - start;
    
    document.getElementById('outputText').innerText = res.text;
    document.getElementById('statLen').innerText = input.length + ' ‚Üí ' + res.text.length;
    document.getElementById('statTime').innerText = time.toFixed(1) + 'ms';
    
    updateViz(res.logData);
    
    log((isEncrypt ? 'üîí –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ' : 'üîì –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ') + ' ' + input.length + ' —Å–∏–º–≤–æ–ª–æ–≤', "info");
    
    if(isEncrypt) {
        const testEngine = new CryptoEngine(alpha, pass);
        const check = testEngine.decrypt(res.text);
        const ok = check.text === input;
        
        document.getElementById('statRev').innerText = ok ? '‚úÖ OK' : '‚ùå FAIL';
        document.getElementById('statRev').className = 'stat-value ' + (ok ? 'ok' : 'err');
        
        log(ok ? '‚úÖ –û–±—Ä–∞—Ç–∏–º–æ—Å—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞' : '‚ùå –û–®–ò–ë–ö–ê –æ–±—Ä–∞—Ç–∏–º–æ—Å—Ç–∏!', ok ? 'ok' : 'err');
        
        // Log rotor independence
        if(res.logData.length > 0) {
            const cmds = res.logData[0].commands;
            const deltas = cmds.map(c => c.delta).join(',');
            log('üé° Delta: [' + deltas + '] ‚Üê –†–æ—Ç–æ—Ä—ã –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã!', 'info');
        }
    }
}

function log(msg, type) {
    const c = document.getElementById('log');
    const d = document.createElement('div');
    d.className = 'log-entry ' + type;
    d.innerText = msg;
    c.insertBefore(d, c.firstChild);
    if(c.children.length > 10) c.removeChild(c.lastChild);
}

window.onload = init;
</script>
</body>
</html>



              <script>
                              // –ë–´–õ–û (–Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ):
for(let r=0; r<4; r++) {
    const b = r * 4;
    commands.push({
        delta: Math.floor(values[b] * 10),      // ‚Üê values[0], values[4], values[8]...
        speed: Math.floor(Math.abs(values[b+2]) * 7) + 1  // ‚Üê values[2], values[6]...
    });
}
// –ü—Ä–æ–±–ª–µ–º–∞: values[0], values[4], values[8] ‚Äî –≤—Å–µ –æ—Ç –æ–¥–Ω–æ–π –Ω–µ–π—Ä–æ—Å–µ—Ç–∏ ‚Üí –ø–æ—Ö–æ–∂–∏–µ!

// –°–¢–ê–õ–û (–ø—Ä–∞–≤–∏–ª—å–Ω–æ):
for(let r=0; r<4; r++) {
    const b = r * 4;
    commands.push({
        delta: Math.floor(values[b] * 10),
        speed: Math.floor(Math.abs(values[b+2]) * 7) + 1,
        // + –¥–æ–±–∞–≤–∏—Ç—å –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã–π —à—É–º –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ä–æ—Ç–æ—Ä–∞
        delta: Math.floor(values[b] * 10) + (step * r * 7) % 5 - 2
    });
}


              </script>
                        </body>
                        </html>       
