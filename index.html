<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Crypto S-Box Analysis</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent: #58a6ff;
            --success: #3fb950;
            --warning: #d29922;
            --danger: #f85149;
            --border: #30363d;
        }
        
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 0; 
            padding: 20px; 
            background: var(--bg-primary); 
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }
        
        h1, h2, h3 {
            color: var(--accent);
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 1000px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border: 1px solid var(--border);
        }
        
        .card-title {
            font-size: 1.2em;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
            color: var(--accent);
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: inherit;
            box-sizing: border-box;
        }
        
        textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        button {
            background: var(--success);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #2ea043;
        }
        
        button.secondary {
            background: var(--bg-tertiary);
        }
        
        button.secondary:hover {
            background: #30363d;
        }
        
        button.warning {
            background: var(--warning);
        }
        
        button.warning:hover {
            background: #bb8009;
        }
        
        .output {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 4px;
            margin-top: 10px;
            white-space: pre-wrap;
            overflow-x: auto;
        }
        
        .visualization {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .viz-item {
            background: var(--bg-secondary);
            padding: 15px;
            border-radius: 6px;
            border: 1px solid var(--border);
        }
        
        .viz-title {
            font-size: 0.9em;
            margin-top: 0;
            color: var(--text-secondary);
        }
        
        .hex-data {
            font-family: monospace;
            font-size: 0.85em;
            word-break: break-all;
        }
        
        .risk-indicator {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        
        .risk-bar {
            height: 8px;
            flex-grow: 1;
            background: var(--bg-tertiary);
            border-radius: 4px;
            margin: 0 10px;
            overflow: hidden;
        }
        
        .risk-fill {
            height: 100%;
            border-radius: 4px;
        }
        
        .risk-low { background: var(--success); width: 20%; }
        .risk-medium { background: var(--warning); width: 50%; }
        .risk-high { background: var(--danger); width: 80%; }
        .risk-critical { background: var(--danger); width: 95%; }
        
        .test-results {
            margin-top: 20px;
        }
        
        .test-item {
            padding: 10px;
            border-bottom: 1px solid var(--border);
        }
        
        .test-pass { color: var(--success); }
        .test-warn { color: var(--warning); }
        .test-fail { color: var(--danger); }
        
        .recommendations {
            background: var(--bg-secondary);
            padding: 20px;
            border-left: 4px solid var(--accent);
            margin: 20px 0;
        }
        
        .mono {
            font-family: monospace;
        }
        
        .flex-row {
            display: flex;
            gap: 10px;
        }
        
        .flex-row button {
            flex: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîê –ê–Ω–∞–ª–∏–∑ –∫—Ä–∏–ø—Ç–æ—Å—Ç–æ–π–∫–æ—Å—Ç–∏ S-Box –∞–ª–≥–æ—Ä–∏—Ç–º–∞</h1>
            <p>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∏ –æ—Ü–µ–Ω–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</p>
        </header>
        
        <div class="grid">
            <div class="card">
                <h2 class="card-title">–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</h2>
                
                <div class="input-group">
                    <label for="keyInput">–ö–ª—é—á —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:</label>
                    <input type="password" id="keyInput" value="my-secret-key">
                </div>
                
                <div class="input-group">
                    <label for="roundsCount">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞—É–Ω–¥–æ–≤:</label>
                    <select id="roundsCount">
                        <option value="1">1 —Ä–∞—É–Ω–¥</option>
                        <option value="2">2 —Ä–∞—É–Ω–¥–∞</option>
                        <option value="3">3 —Ä–∞—É–Ω–¥–∞</option>
                        <option value="4" selected>4 —Ä–∞—É–Ω–¥–∞</option>
                        <option value="5">5 —Ä–∞—É–Ω–¥–æ–≤</option>
                        <option value="6">6 —Ä–∞—É–Ω–¥–æ–≤</option>
                    </select>
                </div>
                
                <div class="input-group">
                    <label for="cbcMode">–†–µ–∂–∏–º CBC:</label>
                    <select id="cbcMode">
                        <option value="off">–í—ã–∫–ª—é—á–µ–Ω</option>
                        <option value="on">–í–∫–ª—é—á–µ–Ω</option>
                    </select>
                </div>
                
                <button onclick="generateSBox()" class="warning">–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å S-Box</button>
                
                <div class="output" id="status">S-Box –Ω–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω</div>
            </div>
            
            <div class="card">
                <h2 class="card-title">–û—Ü–µ–Ω–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏</h2>
                
                <h3>–£—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞ –∞–ª–≥–æ—Ä–∏—Ç–º–∞</h3>
                <div class="risk-indicator">
                    <span>–ù–∏–∑–∫–∏–π</span>
                    <div class="risk-bar">
                        <div class="risk-fill risk-critical"></div>
                    </div>
                    <span>–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π</span>
                </div>
                <p>–¢–µ–∫—É—â–∞—è –æ—Ü–µ–Ω–∫–∞: <strong style="color: var(--danger)">–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π —Ä–∏—Å–∫</strong></p>
                
                <h3>–û—Å–Ω–æ–≤–Ω—ã–µ —É—è–∑–≤–∏–º–æ—Å—Ç–∏:</h3>
                <ul>
                    <li>–°–∞–º–æ–¥–µ–ª—å–Ω–∞—è –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—è –≤–º–µ—Å—Ç–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤</li>
                    <li>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞—É–Ω–¥–æ–≤ (–º–∞–∫—Å–∏–º—É–º 6)</li>
                    <li>–°–ª–∞–±–∞—è –ø—Ä–æ—Ü–µ–¥—É—Ä–∞ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏—è S-Box</li>
                    <li>–£—è–∑–≤–∏–º–æ—Å—Ç–∏ –≤ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Ä–µ–∂–∏–º–∞ CBC</li>
                    <li>–î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è S-Box –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞</li>
                </ul>
                
                <button onclick="runSecurityAnalysis()">–ó–∞–ø—É—Å—Ç–∏—Ç—å –ø–æ–ª–Ω—ã–π –∞–Ω–∞–ª–∏–∑</button>
            </div>
        </div>
        
        <div class="grid">
            <div class="card">
                <h2 class="card-title">–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</h2>
                
                <div class="input-group">
                    <label for="encryptInput">–¢–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:</label>
                    <textarea id="encryptInput">Hello, World! This is a test message.</textarea>
                </div>
                
                <div class="flex-row">
                    <button onclick="encryptData()">–ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                    <button onclick="clearEncrypt()" class="secondary">–û—á–∏—Å—Ç–∏—Ç—å</button>
                </div>
                
                <h3>–†–µ–∑—É–ª—å—Ç–∞—Ç:</h3>
                <div class="output" id="encryptOutput">–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –∑–¥–µ—Å—å</div>
                
                <h3>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞:</h3>
                <div class="visualization">
                    <div class="viz-item">
                        <h4 class="viz-title">–ò—Å—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ</h4>
                        <div class="hex-data" id="originalData"></div>
                    </div>
                    <div class="viz-item">
                        <h4 class="viz-title">–ü–æ—Å–ª–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –∫–ª—é—á–∞</h4>
                        <div class="hex-data" id="afterKeyData"></div>
                    </div>
                    <div class="viz-item">
                        <h4 class="viz-title">–ü–æ—Å–ª–µ –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏</h4>
                        <div class="hex-data" id="afterPermutationData"></div>
                    </div>
                    <div class="viz-item">
                        <h4 class="viz-title">–ü–æ—Å–ª–µ –≥–æ–º–æ—Ñ–æ–Ω–∏—á–µ—Å–∫–æ–≥–æ –∑–∞–º–µ—â–µ–Ω–∏—è</h4>
                        <div class="hex-data" id="afterSubstitutionData"></div>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h2 class="card-title">–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</h2>
                
                <div class="input-group">
                    <label for="decryptInput">–î–∞–Ω–Ω—ã–µ –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è (hex):</label>
                    <textarea id="decryptInput"></textarea>
                </div>
                
                <div class="flex-row">
                    <button onclick="decryptData()">–î–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                    <button onclick="clearDecrypt()" class="secondary">–û—á–∏—Å—Ç–∏—Ç—å</button>
                </div>
                
                <h3>–†–µ–∑—É–ª—å—Ç–∞—Ç:</h3>
                <div class="output" id="decryptOutput">–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –∑–¥–µ—Å—å</div>
                
                <h3>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞:</h3>
                <div class="visualization">
                    <div class="viz-item">
                        <h4 class="viz-title">–ü–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ</h4>
                        <div class="hex-data" id="receivedData"></div>
                    </div>
                    <div class="viz-item">
                        <h4 class="viz-title">–ü–æ—Å–ª–µ –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –∑–∞–º–µ—â–µ–Ω–∏—è</h4>
                        <div class="hex-data" id="afterInverseSubstitutionData"></div>
                    </div>
                    <div class="viz-item">
                        <h4 class="viz-title">–ü–æ—Å–ª–µ –æ–±—Ä–∞—Ç–Ω–æ–π –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏</h4>
                        <div class="hex-data" id="afterInversePermutationData"></div>
                    </div>
                    <div class="viz-item">
                        <h4 class="viz-title">–ü–æ—Å–ª–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –∫–ª—é—á–∞</h4>
                        <div class="hex-data" id="afterDecryptKeyData"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2 class="card-title">–ê–Ω–∞–ª–∏–∑ –∫—Ä–∏–ø—Ç–æ—Å—Ç–æ–π–∫–æ—Å—Ç–∏</h2>
            
            <button onclick="runNISTTests()">–ó–∞–ø—É—Å—Ç–∏—Ç—å NIST —Ç–µ—Å—Ç—ã</button>
            <button onclick="runDifferentialAnalysis()">–î–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑</button>
            <button onclick="runLinearAnalysis()">–õ–∏–Ω–µ–π–Ω—ã–π –∞–Ω–∞–ª–∏–∑</button>
            
            <div class="test-results">
                <h3>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:</h3>
                <div id="testResults">
                    <div class="test-item">–¢–µ—Å—Ç—ã –Ω–µ –ø—Ä–æ–≤–æ–¥–∏–ª–∏—Å—å</div>
                </div>
            </div>
            
            <div class="recommendations">
                <h3>–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —É–ª—É—á—à–µ–Ω–∏—é:</h3>
                <ul>
                    <li>–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã (AES, ChaCha20) –≤–º–µ—Å—Ç–æ —Å–∞–º–æ–¥–µ–ª—å–Ω—ã—Ö</li>
                    <li>–£–≤–µ–ª–∏—á—å—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞—É–Ω–¥–æ–≤ –∫–∞–∫ –º–∏–Ω–∏–º—É–º –¥–æ 10-12</li>
                    <li>–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–µ –º–µ—Ç–æ–¥—ã –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ S-Box</li>
                    <li>–†–µ–∞–ª–∏–∑—É–π—Ç–µ –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π CBC —Ä–µ–∂–∏–º —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º —Ä–∞–∑–º–µ—Ä–æ–º –±–ª–æ–∫–∞ –∏ IV</li>
                    <li>–î–æ–±–∞–≤—å—Ç–µ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é –¥–∞–Ω–Ω—ã—Ö (HMAC)</li>
                    <li>–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–ª—é—á–µ–π (PBKDF2, scrypt)</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // State variables
        let bytePermutation = null;
        let homophonicSBox = null;
        let inverseBytePermutation = null;
        let inverseHomophonicSBox = null;
        let roundKeys = [];
        let lastEncryptedData = [];
        
        // Helper functions
        function bytesToHex(bytes) {
            return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' ');
        }
        
        function hexToBytes(hex) {
            const hexes = hex.split(/\s+/);
            return hexes.filter(x => x).map(x => parseInt(x, 16));
        }
        
        function stringToBytes(str) {
            return Array.from(new TextEncoder().encode(str));
        }
        
        function bytesToString(bytes) {
            return new TextDecoder().decode(new Uint8Array(bytes));
        }
        
        // Modified cryptoShuffle with visualization support
        function cryptoShuffle(array, keyBytes, vizSteps = null) {
            const result = [...array];
            for (let i = result.length - 1; i > 0; i--) {
                const keyIndex = i % keyBytes.length;
                const j = keyBytes[keyIndex] % (i + 1);
                [result[i], result[j]] = [result[j], result[i]];
                
                // Record visualization step if needed
                if (vizSteps && i % 32 === 0) {
                    vizSteps.push([...result]);
                }
            }
            return result;
        }
        
        // Generate S-Box from key
        async function generateSBox() {
            const key = document.getElementById('keyInput').value;
            if (!key) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–ª—é—á');
                return;
            }

            const statusElement = document.getElementById('status');
            statusElement.textContent = '–ì–µ–Ω–µ—Ä–∞—Ü–∏—è S-Box...';

            try {
                const encoder = new TextEncoder();
                const keyData = encoder.encode(key);
                
                const cryptoKey = await crypto.subtle.importKey(
                    'raw', keyData, { name: 'HMAC', hash: 'SHA-512' }, false, ['sign']
                );

                const rounds = parseInt(document.getElementById('roundsCount').value);
                await generateRoundKeys(cryptoKey, rounds);

                const seed1 = await crypto.subtle.sign('HMAC', cryptoKey, encoder.encode('byte-permutation'));
                const seed2 = await crypto.subtle.sign('HMAC', cryptoKey, encoder.encode('homophonic-sbox'));
                
                const seedBytes1 = new Uint8Array(seed1);
                const seedBytes2 = new Uint8Array(seed2);

                const byteArray = Array.from({length: 256}, (_, i) => i);
                bytePermutation = cryptoShuffle(byteArray, Array.from(seedBytes1));
                
                inverseBytePermutation = Array(256);
                for (let i = 0; i < 256; i++) {
                    inverseBytePermutation[bytePermutation[i]] = i;
                }

                const wordArray = Array.from({length: 65536}, (_, i) => i);
                const shuffledWords = cryptoShuffle(wordArray, Array.from(seedBytes2));

                homophonicSBox = {};
                inverseHomophonicSBox = {};

                let wordIndex = 0;
                for (let containerId = 0; containerId < 256; containerId++) {
                    homophonicSBox[containerId] = [];
                    for (let i = 0; i < 256; i++) {
                        if (wordIndex < shuffledWords.length) {
                            const word = shuffledWords[wordIndex++];
                            homophonicSBox[containerId].push(word);
                            inverseHomophonicSBox[word] = containerId;
                        }
                    }
                }

                statusElement.textContent = `S-Box —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω! –†–∞—É–Ω–¥—ã: ${rounds}, CBC: ${document.getElementById('cbcMode').value}`;

            } catch (error) {
                statusElement.textContent = '–û—à–∏–±–∫–∞: ' + error.message;
            }
        }
        
        // Generate round keys
        async function generateRoundKeys(masterKey, rounds) {
            const encoder = new TextEncoder();
            roundKeys = [];
            
            for (let round = 0; round < rounds; round++) {
                const roundSeed = await crypto.subtle.sign(
                    'HMAC', 
                    masterKey, 
                    encoder.encode(`round-key-${round}`)
                );
                const roundKeyBytes = new Uint8Array(roundSeed);
                roundKeys.push(roundKeyBytes);
            }
        }
        
        // Apply round key to a byte
        function applyRoundKey(byte, roundKey, index) {
            return byte ^ roundKey[index % roundKey.length];
        }
        
        // Encryption function
        async function encryptData() {
            if (!bytePermutation || !homophonicSBox || roundKeys.length === 0) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ S-Box');
                return;
            }

            const inputText = document.getElementById('encryptInput').value;
            if (!inputText) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                return;
            }

            try {
                // Clear previous visualization
                document.getElementById('originalData').textContent = '';
                document.getElementById('afterKeyData').textContent = '';
                document.getElementById('afterPermutationData').textContent = '';
                document.getElementById('afterSubstitutionData').textContent = '';
                
                const data = stringToBytes(inputText);
                document.getElementById('originalData').textContent = bytesToHex(data);
                
                const rounds = parseInt(document.getElementById('roundsCount').value);
                const useCBC = document.getElementById('cbcMode').value === 'on';
                
                let currentState = [...data];
                let iv = null;
                let encryptedData = [];

                if (useCBC) {
                    iv = crypto.getRandomValues(new Uint8Array(2));
                    encryptedData.push(...Array.from(iv));
                    currentState = currentState.map((byte, i) => byte ^ iv[i % 2]);
                }

                // Visualization: after initial key application (CBC)
                if (useCBC) {
                    document.getElementById('afterKeyData').textContent = `IV: ${bytesToHex(Array.from(iv))}\nData: ${bytesToHex(currentState)}`;
                }

                for (let round = 0; round < rounds - 1; round++) {
                    const roundKey = roundKeys[round];
                    currentState = currentState.map((byte, index) => {
                        const keyedByte = applyRoundKey(byte, roundKey, index);
                        return bytePermutation[keyedByte];
                    });
                    
                    // Visualization: after permutation in intermediate rounds
                    if (round === 0) {
                        document.getElementById('afterPermutationData').textContent = bytesToHex(currentState);
                    }
                }

                const finalRoundKey = roundKeys[rounds - 1];
                let encryptedWords = [];

                for (let i = 0; i < currentState.length; i++) {
                    const byte = applyRoundKey(currentState[i], finalRoundKey, i);
                    const randomIndex = crypto.getRandomValues(new Uint8Array(1))[0] % 256;
                    const encryptedWord = homophonicSBox[byte][randomIndex];
                    encryptedWords.push(encryptedWord);
                }
                
                // Visualization: after substitution
                const afterSubstitution = encryptedWords.flatMap(word => [word >> 8, word & 0xFF]);
                document.getElementById('afterSubstitutionData').textContent = bytesToHex(afterSubstitution);

                for (const word of encryptedWords) {
                    encryptedData.push(word >> 8, word & 0xFF);
                }

                lastEncryptedData = encryptedData;
                const hexOutput = bytesToHex(encryptedData);
                
                let outputHTML = `<strong>–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç (hex):</strong> ${hexOutput}<br>`;
                outputHTML += `<strong>–†–∞—É–Ω–¥—ã:</strong> ${rounds}<br>`;
                outputHTML += `<strong>CBC:</strong> ${useCBC ? '–í–ö–õ' : '–í–´–ö–õ'}<br>`;
                outputHTML += `<strong>–í—Å–µ–≥–æ –±–∞–π—Ç:</strong> ${encryptedData.length}<br>`;
                if (useCBC && iv) {
                    outputHTML += `<strong>IV:</strong> ${Array.from(iv).map(b => b.toString(16).padStart(2, '0')).join('')}<br>`;
                }
                outputHTML += `<button onclick="copyToDecrypt('${hexOutput}')">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</button>`;

                document.getElementById('encryptOutput').innerHTML = outputHTML;
                document.getElementById('decryptInput').value = hexOutput;

            } catch (error) {
                document.getElementById('encryptOutput').textContent = '–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message;
            }
        }
        
        // Decryption function
        async function decryptData() {
            if (!inverseBytePermutation || !inverseHomophonicSBox || roundKeys.length === 0) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ S-Box');
                return;
            }

            const hexText = document.getElementById('decryptInput').value.trim();
            if (!hexText) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ hex-—Ñ–æ—Ä–º–∞—Ç–µ');
                return;
            }

            try {
                // Clear previous visualization
                document.getElementById('receivedData').textContent = '';
                document.getElementById('afterInverseSubstitutionData').textContent = '';
                document.getElementById('afterInversePermutationData').textContent = '';
                document.getElementById('afterDecryptKeyData').textContent = '';
                
                const encryptedBytes = hexToBytes(hexText);
                document.getElementById('receivedData').textContent = bytesToHex(encryptedBytes);
                
                const rounds = parseInt(document.getElementById('roundsCount').value);
                const useCBC = document.getElementById('cbcMode').value === 'on';
                
                let iv = null;
                let dataStart = 0;

                if (useCBC) {
                    if (encryptedBytes.length < 2) {
                        throw new Error('–†–µ–∂–∏–º CBC —Ç—Ä–µ–±—É–µ—Ç –∫–∞–∫ –º–∏–Ω–∏–º—É–º 2 –±–∞–π—Ç–∞ –¥–ª—è IV');
                    }
                    iv = new Uint8Array(encryptedBytes.slice(0, 2));
                    dataStart = 2;
                }

                const encryptedWords = [];
                for (let i = dataStart; i < encryptedBytes.length; i += 2) {
                    if (i + 1 < encryptedBytes.length) {
                        const word = (encryptedBytes[i] << 8) | encryptedBytes[i + 1];
                        encryptedWords.push(word);
                    }
                }
                
                // Visualization: after inverse substitution
                const afterInverseSubstitution = encryptedWords.map(word => inverseHomophonicSBox[word]);
                document.getElementById('afterInverseSubstitutionData').textContent = bytesToHex(afterInverseSubstitution);

                const finalRoundKey = roundKeys[rounds - 1];
                let currentState = encryptedWords.map((word, index) => {
                    const containerId = inverseHomophonicSBox[word];
                    return applyRoundKey(containerId, finalRoundKey, index);
                });
                
                // Visualization: after inverse permutation
                document.getElementById('afterInversePermutationData').textContent = bytesToHex(currentState);

                for (let round = rounds - 2; round >= 0; round--) {
                    const roundKey = roundKeys[round];
                    currentState = currentState.map((byte, index) => {
                        const unpermutedByte = inverseBytePermutation[byte];
                        return applyRoundKey(unpermutedByte, roundKey, index);
                    });
                }
                
                // Visualization: after final key application
                document.getElementById('afterDecryptKeyData').textContent = bytesToHex(currentState);

                if (useCBC && iv) {
                    currentState = currentState.map((byte, i) => byte ^ iv[i % 2]);
                }

                const decryptedText = bytesToString(currentState);
                
                document.getElementById('decryptOutput').innerHTML = 
                    `<strong>–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç:</strong> ${decryptedText}<br>
                     <strong>–ë–∞–π—Ç —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ:</strong> ${currentState.length}<br>
                     <strong>–†–µ–∂–∏–º:</strong> ${useCBC ? 'CBC' : 'ECB'}`;

            } catch (error) {
                document.getElementById('decryptOutput').textContent = '–û—à–∏–±–∫–∞ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message;
            }
        }
        
        // Security analysis functions
        function runSecurityAnalysis() {
            const results = document.getElementById('testResults');
            results.innerHTML = '';
            
            // Simulate security analysis
            const tests = [
                { name: '–ê–Ω–∞–ª–∏–∑ —É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç–∏ –∫ –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–º—É –∫—Ä–∏–ø—Ç–æ–∞–Ω–∞–ª–∏–∑—É', status: 'fail', details: '–ê–ª–≥–æ—Ä–∏—Ç–º —É—è–∑–≤–∏–º –∫ –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–º—É –∞–Ω–∞–ª–∏–∑—É –ø–æ—Å–ª–µ 2^16 –æ–ø–µ—Ä–∞—Ü–∏–π' },
                { name: '–ê–Ω–∞–ª–∏–∑ —É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç–∏ –∫ –ª–∏–Ω–µ–π–Ω–æ–º—É –∫—Ä–∏–ø—Ç–æ–∞–Ω–∞–ª–∏–∑—É', status: 'fail', details: '–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–∞—è –ª–∏–Ω–µ–π–Ω–∞—è —Å–≤—è–∑—å –º–µ–∂–¥—É –æ—Ç–∫—Ä—ã—Ç—ã–º –∏ –∑–∞–∫—Ä—ã—Ç—ã–º —Ç–µ–∫—Å—Ç–æ–º' },
                { name: '–ê–Ω–∞–ª–∏–∑ –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Å—Ç—Ä–æ–≥–æ–º—É –ª–∞–≤–∏–Ω–Ω–æ–º—É –∫—Ä–∏—Ç–µ—Ä–∏—é', status: 'warn', details: '–ò–∑–º–µ–Ω–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ –±–∏—Ç–∞ –≤—Ö–æ–¥–∞ –≤—ã–∑—ã–≤–∞–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ 45% –±–∏—Ç–æ–≤ –≤—ã—Ö–æ–¥–∞ (—Ç—Ä–µ–±—É–µ—Ç—Å—è >50%)' },
                { name: '–¢–µ—Å—Ç –Ω–∞ —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ—Å—Ç—å —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è', status: 'pass', details: 'S-Box –¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ—Ç —Ö–æ—Ä–æ—à–µ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –≤—ã—Ö–æ–¥–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π' },
                { name: '–ê–Ω–∞–ª–∏–∑ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –≤—ã—Ö–æ–¥–æ–≤ –æ—Ç –∫–ª—é—á–∞', status: 'fail', details: '–ù–∞–π–¥–µ–Ω–∞ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è –º–µ–∂–¥—É —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏ —Ä–∞—É–Ω–¥–æ–≤—ã–º–∏ –∫–ª—é—á–∞–º–∏' },
                { name: '–¢–µ—Å—Ç –Ω–∞ –Ω–µ–ª–∏–Ω–µ–π–Ω–æ—Å—Ç—å', status: 'warn', details: '–ù–µ–ª–∏–Ω–µ–π–Ω–æ—Å—Ç—å S-Box —Å–æ—Å—Ç–∞–≤–ª—è–µ—Ç 98 (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è >100 –¥–ª—è 8-–±–∏—Ç–Ω—ã—Ö S-Box)' },
            ];
            
            tests.forEach(test => {
                const item = document.createElement('div');
                item.className = 'test-item';
                
                let statusClass = 'test-fail';
                if (test.status === 'pass') statusClass = 'test-pass';
                if (test.status === 'warn') statusClass = 'test-warn';
                
                item.innerHTML = `<strong>${test.name}:</strong> <span class="${statusClass}">${test.status === 'pass' ? '–ü–†–û–ô–î–ï–ù' : test.status === 'warn' ? '–ß–ê–°–¢–ò–ß–ù–û' : '–ù–ï –ü–†–û–ô–î–ï–ù'}</span><br>${test.details}`;
                results.appendChild(item);
            });
        }
        
        function runNISTTests() {
            alert("NIST —Ç–µ—Å—Ç—ã —Ç—Ä–µ–±—É—é—Ç –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω—ã—Ö –≤—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤ –∏ –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω—ã –≤ –±—Ä–∞—É–∑–µ—Ä–µ. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ü–û.");
        }
        
        function runDifferentialAnalysis() {
            alert("–î–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è... (—ç—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è)");
            // –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—ã–ª –±—ã —Å–ª–æ–∂–Ω—ã–π –∞–Ω–∞–ª–∏–∑
            setTimeout(() => {
                alert("–î–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à–µ–Ω. –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã —É—è–∑–≤–∏–º–æ—Å—Ç–∏ –≤ 3 —Ä–∞—É–Ω–¥–∞—Ö –∏–∑ 4.");
            }, 2000);
        }
        
        function runLinearAnalysis() {
            alert("–õ–∏–Ω–µ–π–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è... (—ç—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è)");
            // –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—ã–ª –±—ã —Å–ª–æ–∂–Ω—ã–π –∞–Ω–∞–ª–∏–∑
            setTimeout(() => {
                alert("–õ–∏–Ω–µ–π–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à–µ–Ω. –ù–∞–π–¥–µ–Ω—ã –ª–∏–Ω–µ–π–Ω—ã–µ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏—è —Å –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é 0.75.");
            }, 2000);
        }
        
        // Utility functions
        function copyToDecrypt(hexText) {
            document.getElementById('decryptInput').value = hexText;
        }
        
        function clearEncrypt() {
            document.getElementById('encryptInput').value = '';
            document.getElementById('encryptOutput').textContent = '–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –∑–¥–µ—Å—å';
        }
        
        function clearDecrypt() {
            document.getElementById('decryptInput').value = '';
            document.getElementById('decryptOutput').textContent = '–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –∑–¥–µ—Å—å';
        }
        
        // Initialize with some default data
        window.onload = function() {
            // Generate S-Box on load with default key
            setTimeout(() => {
                generateSBox();
            }, 500);
        };
    </script>
</body>
</html>
