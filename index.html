<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –≥–æ–º–æ—Ñ–æ–Ω–∏—á–µ—Å–∫–∞—è –∫—Ä–∏–ø—Ç–æ—Å–∏—Å—Ç–µ–º–∞</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent: #58a6ff;
            --success: #3fb950;
            --warning: #d29922;
            --danger: #f85149;
            --border: #30363d;
        }
        
        body { 
            font-family: 'Consolas', 'Monaco', monospace; 
            margin: 0; 
            padding: 20px; 
            background: var(--bg-primary); 
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        .container { 
            max-width: 1600px; 
            margin: 0 auto; 
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }
        
        h1, h2, h3 {
            color: var(--accent);
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 1200px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border: 1px solid var(--border);
            margin-bottom: 20px;
        }
        
        .card-title {
            font-size: 1.2em;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
            color: var(--accent);
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: inherit;
            box-sizing: border-box;
        }
        
        textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        button {
            background: var(--success);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
            margin: 5px;
        }
        
        button:hover {
            background: #2ea043;
        }
        
        button.secondary {
            background: var(--bg-tertiary);
        }
        
        button.secondary:hover {
            background: #30363d;
        }
        
        button.warning {
            background: var(--warning);
        }
        
        button.warning:hover {
            background: #bb8009;
        }
        
        .output {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 4px;
            margin-top: 10px;
            white-space: pre-wrap;
            overflow-x: auto;
            font-family: monospace;
        }
        
        .analysis-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 1000px) {
            .analysis-panel {
                grid-template-columns: 1fr;
            }
        }
        
        .metric {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
        }
        
        .metric-title {
            font-size: 1em;
            margin-top: 0;
            color: var(--text-secondary);
        }
        
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--accent);
        }
        
        .test-results {
            margin-top: 20px;
        }
        
        .test-item {
            padding: 10px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
        }
        
        .test-pass { color: var(--success); }
        .test-warn { color: var(--warning); }
        .test-fail { color: var(--danger); }
        
        .recommendations {
            background: var(--bg-secondary);
            padding: 20px;
            border-left: 4px solid var(--accent);
            margin: 20px 0;
        }
        
        .mono {
            font-family: monospace;
        }
        
        .flex-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            margin-right: 5px;
        }
        
        .tab.active {
            background: var(--bg-secondary);
            border-color: var(--border);
            color: var(--accent);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .sbox-table {
            display: grid;
            grid-template-columns: repeat(17, 1fr);
            gap: 1px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 0.7em;
        }
        
        .sbox-header {
            background: var(--bg-tertiary);
            padding: 5px;
            text-align: center;
            font-weight: bold;
        }
        
        .sbox-cell {
            background: var(--bg-tertiary);
            padding: 5px;
            text-align: center;
        }
        
        .sbox-index {
            background: var(--bg-tertiary);
            padding: 5px;
            text-align: center;
            font-weight: bold;
        }
        
        .progress-bar {
            height: 20px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.5s;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîê –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –≥–æ–º–æ—Ñ–æ–Ω–∏—á–µ—Å–∫–∞—è –∫—Ä–∏–ø—Ç–æ—Å–∏—Å—Ç–µ–º–∞</h1>
            <p>–£–ª—É—á—à–µ–Ω–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–µ—Ä–µ–¥–æ–≤—ã—Ö –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏—Ö –ø—Ä–∏–Ω—Ü–∏–ø–æ–≤</p>
        </header>
        
        <div class="tabs">
            <div class="tab active" onclick="switchTab('encryption')">–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</div>
            <div class="tab" onclick="switchTab('analysis')">–ê–Ω–∞–ª–∏–∑</div>
            <div class="tab" onclick="switchTab('sbox')">S-Box –∞–Ω–∞–ª–∏–∑</div>
        </div>
        
        <div id="encryption" class="tab-content active">
            <div class="grid">
                <div class="card">
                    <h2 class="card-title">–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</h2>
                    
                    <div class="input-group">
                        <label for="keyInput">–ö–ª—é—á —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:</label>
                        <input type="password" id="keyInput" value="super-secure-key-with-high-entropy">
                    </div>
                    
                    <div class="input-group">
                        <label for="keyConfirmation">–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∫–ª—é—á–∞:</label>
                        <input type="password" id="keyConfirmation" value="super-secure-key-with-high-entropy">
                    </div>
                    
                    <div class="input-group">
                        <label for="pbkdf2Iterations">PBKDF2 –ò—Ç–µ—Ä–∞—Ü–∏–∏:</label>
                        <select id="pbkdf2Iterations">
                            <option value="100000">100,000 (—Å—Ç–∞–Ω–¥–∞—Ä—Ç)</option>
                            <option value="250000">250,000 (—É—Å–∏–ª–µ–Ω–Ω—ã–π)</option>
                            <option value="500000" selected>500,000 (–≤–æ–µ–Ω–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å)</option>
                            <option value="1000000">1,000,000 (–º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π)</option>
                        </select>
                    </div>
                    
                    <div class="input-group">
                        <label for="operationMode">–†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã:</label>
                        <select id="operationMode">
                            <option value="cbc" selected>CBC (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)</option>
                            <option value="cfb">CFB</option>
                            <option value="ofb">OFB</option>
                        </select>
                    </div>
                    
                    <button onclick="initializeCipher()" class="warning">–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —à–∏—Ñ—Ä</button>
                    
                    <div class="output" id="initStatus">–®–∏—Ñ—Ä –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω</div>
                </div>
                
                <div class="card">
                    <h2 class="card-title">–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö</h2>
                    
                    <div class="input-group">
                        <label for="inputData">–í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:</label>
                        <textarea id="inputData">–ö–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è, —Ç—Ä–µ–±—É—é—â–∞—è –≤—ã—Å—à–µ–≥–æ —É—Ä–æ–≤–Ω—è –∑–∞—â–∏—Ç—ã</textarea>
                    </div>
                    
                    <div class="flex-row">
                        <button onclick="encryptData()">–ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                        <button onclick="decryptData()">–î–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                        <button onclick="clearAll()" class="secondary">–û—á–∏—Å—Ç–∏—Ç—å</button>
                    </div>
                    
                    <h3>–†–µ–∑—É–ª—å—Ç–∞—Ç:</h3>
                    <div class="output" id="outputData">–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ—è–≤—è—Ç—Å—è –∑–¥–µ—Å—å</div>
                    
                    <h3>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏:</h3>
                    <div class="output" id="encryptionInfo">–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø—Ä–æ—Ü–µ—Å—Å–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</div>
                </div>
            </div>
        </div>
        
        <div id="analysis" class="tab-content">
            <div class="card">
                <h2 class="card-title">–ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑</h2>
                
                <div class="flex-row">
                    <button onclick="runEntropyAnalysis()">–ê–Ω–∞–ª–∏–∑ —ç–Ω—Ç—Ä–æ–ø–∏–∏</button>
                    <button onclick="runFrequencyTest()">–ß–∞—Å—Ç–æ—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑</button>
                    <button onclick="runAvalancheTest()">–¢–µ—Å—Ç –ª–∞–≤–∏–Ω–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞</button>
                    <button onclick="runRandomnessTests()">–¢–µ—Å—Ç—ã —Å–ª—É—á–∞–π–Ω–æ—Å—Ç–∏</button>
                </div>
                
                <div class="analysis-panel">
                    <div>
                        <h3>–ú–µ—Ç—Ä–∏–∫–∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö</h3>
                        
                        <div class="metric">
                            <div class="metric-title">–≠–Ω—Ç—Ä–æ–ø–∏—è –®–µ–Ω–Ω–æ–Ω–∞ (–±–∏—Ç/–±–∞–π—Ç)</div>
                            <div class="metric-value" id="shannonEntropy">0.00</div>
                        </div>
                        
                        <div class="metric">
                            <div class="metric-title">–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è (–±–∏—Ç/–±–∞–π—Ç)</div>
                            <div class="metric-value" id="minEntropy">0.00</div>
                        </div>
                        
                        <div class="metric">
                            <div class="metric-title">œá¬≤ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</div>
                            <div class="metric-value" id="chiSquare">0.00</div>
                        </div>
                        
                        <div class="metric">
                            <div class="metric-title">p-–∑–Ω–∞—á–µ–Ω–∏–µ</div>
                            <div class="metric-value" id="pValue">0.00</div>
                        </div>
                    </div>
                    
                    <div>
                        <h3>–°—Ç–∞—Ç–∏—Å—Ç–∏—á–µ—Å–∫–∏–µ —Ç–µ—Å—Ç—ã</h3>
                        <div class="test-results" id="statTestResults">
                            <div class="test-item">–¢–µ—Å—Ç—ã –Ω–µ –ø—Ä–æ–≤–æ–¥–∏–ª–∏—Å—å</div>
                        </div>
                    </div>
                </div>
                
                <h3>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∞–Ω–∞–ª–∏–∑–∞</h3>
                <div class="test-results" id="analysisResults">
                    <div class="test-item">–ê–Ω–∞–ª–∏–∑ –Ω–µ –ø—Ä–æ–≤–æ–¥–∏–ª—Å—è</div>
                </div>
            </div>
        </div>
        
        <div id="sbox" class="tab-content">
            <div class="card">
                <h2 class="card-title">–ê–Ω–∞–ª–∏–∑ S-Box</h2>
                
                <div class="flex-row">
                    <button onclick="analyzeSBox()">–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å S-Box</button>
                    <button onclick="visualizeSBox()">–í–∏–∑—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å S-Box</button>
                </div>
                
                <h3>–°–≤–æ–π—Å—Ç–≤–∞ S-Box</h3>
                <div class="test-results" id="sboxProperties">
                    <div class="test-item">S-Box –Ω–µ –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–ª—Å—è</div>
                </div>
                
                <h3>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è S-Box (–ø–µ—Ä–≤—ã–µ 16x16 –∑–Ω–∞—á–µ–Ω–∏–π)</h3>
                <div class="sbox-table" id="sboxTable">
                    <!-- –ë—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–æ —á–µ—Ä–µ–∑ JavaScript -->
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2 class="card-title">–ó–∞–∫–ª—é—á–µ–Ω–∏–µ</h2>
            
            <div class="recommendations">
                <h3>–û—Ü–µ–Ω–∫–∞ –∫—Ä–∏–ø—Ç–æ—Å—Ç–æ–π–∫–æ—Å—Ç–∏ —Å–∏—Å—Ç–µ–º—ã:</h3>
                
                <div class="metric">
                    <div class="metric-title">–°—Ç–æ–π–∫–æ—Å—Ç—å –∫ —á–∞—Å—Ç–æ—Ç–Ω–æ–º—É –∞–Ω–∞–ª–∏–∑—É</div>
                    <div class="metric-value" id="frequencyResistance">–ù–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ</div>
                </div>
                
                <div class="metric">
                    <div class="metric-title">–õ–∞–≤–∏–Ω–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç</div>
                    <div class="metric-value" id="avalancheEffect">–ù–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ</div>
                </div>
                
                <div class="metric">
                    <div class="metric-title">–≠–Ω—Ç—Ä–æ–ø–∏–π–Ω–∞—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å</div>
                    <div class="metric-value" id="entropyEfficiency">–ù–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ</div>
                </div>
                
                <div class="metric">
                    <div class="metric-title">–î–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —Å—Ç–æ–π–∫–æ—Å—Ç—å</div>
                    <div class="metric-value" id="differentialResistance">–ù–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ</div>
                </div>
                
                <p>–î–∞–Ω–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —É–ª—É—á—à–µ–Ω–Ω—ã–µ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–∏—Ç–∏–≤—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–∞—à–µ–π —Å–∏—Å—Ç–µ–º—ã —Å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–º–∏ enhancements –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏.</p>
            </div>
        </div>
    </div>

    <script>
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –∫—Ä–∏–ø—Ç–æ—Å–∏—Å—Ç–µ–º—ã
        let cipherInstance = null;
        let sBox = null;
        let inverseSBox = null;
        let lastOperationResult = null;
        
        // –ö–ª–∞—Å—Å –¥–ª—è –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–π –≥–æ–º–æ—Ñ–æ–Ω–∏—á–µ—Å–∫–æ–π –∫—Ä–∏–ø—Ç–æ—Å–∏—Å—Ç–µ–º—ã
        class ProfessionalHomophonicCipher {
            constructor() {
                this.sBox = null;
                this.inverseSBox = null;
                this.encryptionKey = null;
                this.initializationVector = null;
            }
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —à–∏—Ñ—Ä–∞ —Å –∫–ª—é—á–æ–º
            async initializeWithKey(passphrase, iterations = 500000) {
                try {
                    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º PBKDF2
                    const encoder = new TextEncoder();
                    const passphraseData = encoder.encode(passphrase);
                    
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Å–æ–ª—å –¥–ª—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ—Å—Ç–∏ (–ø–æ –≤–∞—à–µ–º—É —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—é)
                    const salt = await crypto.subtle.digest('SHA-256', passphraseData);
                    
                    const keyMaterial = await crypto.subtle.importKey(
                        'raw',
                        passphraseData,
                        { name: 'PBKDF2' },
                        false,
                        ['deriveKey']
                    );
                    
                    this.encryptionKey = await crypto.subtle.deriveKey(
                        {
                            name: 'PBKDF2',
                            salt: salt,
                            iterations: iterations,
                            hash: 'SHA-512'
                        },
                        keyMaterial,
                        { name: 'HMAC', hash: 'SHA-512', length: 512 },
                        false,
                        ['sign']
                    );
                    
                    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è S-Box –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞
                    await this.generateSBox();
                    
                    return true;
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏:', error);
                    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —à–∏—Ñ—Ä: ' + error.message);
                }
            }
            
            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è S-Box –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞ (—É–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
            async generateSBox() {
                try {
                    const encoder = new TextEncoder();
                    
                    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è seed –¥–ª—è S-Box –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞
                    const sboxSeed = await crypto.subtle.sign(
                        'HMAC', 
                        this.encryptionKey, 
                        encoder.encode('sbox-generation-seed')
                    );
                    
                    const sboxSeedBytes = new Uint8Array(sboxSeed);
                    
                    // –°–æ–∑–¥–∞–µ–º –º–∞—Å—Å–∏–≤ –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö 16-–±–∏—Ç–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π (0-65535)
                    const allHomophones = new Array(65536);
                    for (let i = 0; i < 65536; i++) {
                        allHomophones[i] = i;
                    }
                    
                    // –¢—â–∞—Ç–µ–ª—å–Ω–æ–µ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º HMAC –∫–∞–∫ CSPRNG
                    await this.fisherYatesShuffle(allHomophones, sboxSeedBytes);
                    
                    // –°–æ–∑–¥–∞–Ω–∏–µ S-Box 256x256
                    this.sBox = new Array(256);
                    this.inverseSBox = new Map();
                    
                    let homophoneIndex = 0;
                    for (let inputByte = 0; inputByte < 256; inputByte++) {
                        this.sBox[inputByte] = new Array(256);
                        for (let substitutionIndex = 0; substitutionIndex < 256; substitutionIndex++) {
                            const homophone = allHomophones[homophoneIndex++];
                            this.sBox[inputByte][substitutionIndex] = homophone;
                            this.inverseSBox.set(homophone, inputByte);
                        }
                    }
                    
                    return true;
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ S-Box:', error);
                    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å S-Box: ' + error.message);
                }
            }
            
            // –ê–ª–≥–æ—Ä–∏—Ç–º –§–∏—à–µ—Ä–∞-–ô–µ–π—Ç—Å–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º HMAC –∫–∞–∫ CSPRNG
            async fisherYatesShuffle(array, seedBytes) {
                const hmacKey = await crypto.subtle.importKey(
                    'raw',
                    seedBytes,
                    { name: 'HMAC', hash: 'SHA-512' },
                    false,
                    ['sign']
                );
                
                let counter = 0;
                let randomBuffer = new Uint8Array(0);
                let bufferPosition = 0;
                
                for (let i = array.length - 1; i > 0; i--) {
                    if (bufferPosition >= randomBuffer.length - 1) {
                        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–µ —Å–ª—É—á–∞–π–Ω—ã–µ –±–∞–π—Ç—ã –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
                        const counterData = new Uint8Array([counter++]);
                        randomBuffer = new Uint8Array(await crypto.subtle.sign('HMAC', hmacKey, counterData));
                        bufferPosition = 0;
                    }
                    
                    // –ü–æ–ª—É—á–∞–µ–º —Å–ª—É—á–∞–π–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ –±—É—Ñ–µ—Ä–∞
                    const randValue = (randomBuffer[bufferPosition] << 8) | randomBuffer[bufferPosition + 1];
                    bufferPosition += 2;
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º –∏–Ω–¥–µ–∫—Å –¥–ª—è –æ–±–º–µ–Ω–∞
                    const j = randValue % (i + 1);
                    
                    // –û–±–º–µ–Ω –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }
            
            // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
            async encrypt(plaintext, mode = 'cbc') {
                try {
                    const encoder = new TextEncoder();
                    const plaintextBytes = encoder.encode(plaintext);
                    
                    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è 16-–±–∞–π—Ç–Ω–æ–≥–æ IV
                    this.initializationVector = crypto.getRandomValues(new Uint8Array(16));
                    
                    let ciphertext = new Uint16Array(plaintextBytes.length);
                    let previousBlock = this.initializationVector;
                    
                    // –ü—Ä–æ—Ü–µ—Å—Å —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
                    for (let i = 0; i < plaintextBytes.length; i++) {
                        let byteToEncrypt = plaintextBytes[i];
                        
                        // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞ —Ä–∞–±–æ—Ç—ã
                        if (mode !== 'ecb') {
                            byteToEncrypt ^= previousBlock[i % 16];
                        }
                        
                        // –°–ª—É—á–∞–π–Ω—ã–π –≤—ã–±–æ—Ä –æ–º–æ—Ñ–æ–Ω–∞ –∏–∑ S-Box
                        const randomIndex = crypto.getRandomValues(new Uint8Array(1))[0];
                        const homophone = this.sBox[byteToEncrypt][randomIndex];
                        
                        ciphertext[i] = homophone;
                        
                        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–ª–æ–∫–∞ –¥–ª—è —Ä–µ–∂–∏–º–æ–≤ —Å –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑—å—é
                        if (mode === 'cbc') {
                            previousBlock = this.updateDiffusionBlock(previousBlock, homophone);
                        }
                    }
                    
                    // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∏—Ç–æ–≥–æ–≤–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
                    const result = new Uint8Array(16 + ciphertext.length * 2);
                    result.set(this.initializationVector, 0);
                    
                    const ciphertextBytes = new Uint8Array(ciphertext.buffer);
                    result.set(ciphertextBytes, 16);
                    
                    return result;
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:', error);
                    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ: ' + error.message);
                }
            }
            
            // –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
            async decrypt(ciphertext, mode = 'cbc') {
                try {
                    if (ciphertext.length < 16) {
                        throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö');
                    }
                    
                    // –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ IV –∏–∑ –Ω–∞—á–∞–ª–∞ –¥–∞–Ω–Ω—ã—Ö
                    const iv = ciphertext.slice(0, 16);
                    const encryptedData = ciphertext.slice(16);
                    
                    // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ Uint16Array –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ–º–æ—Ñ–æ–Ω–æ–≤
                    if (encryptedData.length % 2 !== 0) {
                        throw new Error('–ù–µ–≤–µ—Ä–Ω–∞—è –¥–ª–∏–Ω–∞ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö');
                    }
                    
                    const homophones = new Uint16Array(encryptedData.buffer, 0, encryptedData.length / 2);
                    const plaintext = new Uint8Array(homophones.length);
                    
                    let previousBlock = iv;
                    
                    // –ü—Ä–æ—Ü–µ—Å—Å –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
                    for (let i = 0; i < homophones.length; i++) {
                        const homophone = homophones[i];
                        
                        if (!this.inverseSBox.has(homophone)) {
                            throw new Error(`–ù–µ–≤–µ—Ä–Ω—ã–π –æ–º–æ—Ñ–æ–Ω –≤ –ø–æ–∑–∏—Ü–∏–∏ ${i}: ${homophone}`);
                        }
                        
                        let decryptedByte = this.inverseSBox.get(homophone);
                        
                        // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞ —Ä–∞–±–æ—Ç—ã
                        if (mode !== 'ecb') {
                            decryptedByte ^= previousBlock[i % 16];
                        }
                        
                        plaintext[i] = decryptedByte;
                        
                        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–ª–æ–∫–∞ –¥–ª—è —Ä–µ–∂–∏–º–æ–≤ —Å –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑—å—é
                        if (mode === 'cbc') {
                            previousBlock = this.updateDiffusionBlock(previousBlock, homophone);
                        }
                    }
                    
                    const decoder = new TextDecoder();
                    return decoder.decode(plaintext);
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:', error);
                    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –¥–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ: ' + error.message);
                }
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–ª–æ–∫–∞ –¥–∏—Ñ—Ñ—É–∑–∏–∏ (–ø–æ –≤–∞—à–µ–º—É –ø—Ä–∏–º–µ—Ä—É)
            updateDiffusionBlock(block, homophone) {
                const newBlock = new Uint8Array(16);
                const homophoneBytes = new Uint8Array([
                    (homophone >> 8) & 0xFF,
                    homophone & 0xFF
                ]);
                
                for (let i = 0; i < 16; i++) {
                    newBlock[i] = block[i] ^ homophoneBytes[i % 2];
                }
                
                return newBlock;
            }
            
            // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–æ–π—Å—Ç–≤ S-Box –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
            getSBoxProperties() {
                if (!this.sBox) return null;
                
                const properties = {
                    size: "256x256",
                    totalElements: 65536,
                    uniqueHomophones: new Set(),
                    byteCoverage: new Array(256).fill(0),
                    distribution: {}
                };
                
                // –ê–Ω–∞–ª–∏–∑ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –æ–º–æ—Ñ–æ–Ω–æ–≤
                for (let i = 0; i < 256; i++) {
                    for (let j = 0; j < 256; j++) {
                        const homophone = this.sBox[i][j];
                        properties.uniqueHomophones.add(homophone);
                        
                        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Å—Ç–∞—Ä—à–∏–º –±–∞–π—Ç–∞–º
                        const highByte = (homophone >> 8) & 0xFF;
                        properties.byteCoverage[highByte]++;
                        
                        // –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π
                        if (!properties.distribution[homophone]) {
                            properties.distribution[homophone] = 0;
                        }
                        properties.distribution[homophone]++;
                    }
                }
                
                properties.uniqueHomophonesCount = properties.uniqueHomophones.size;
                properties.uniformityScore = this.calculateUniformity(properties.distribution);
                
                return properties;
            }
            
            // –†–∞—Å—á–µ—Ç —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ—Å—Ç–∏ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
            calculateUniformity(distribution) {
                const values = Object.values(distribution);
                const expected = 256; // –ö–∞–∂–¥–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –≤—Å—Ç—Ä–µ—á–∞—Ç—å—Å—è 256 —Ä–∞–∑ –≤ –∏–¥–µ–∞–ª–µ
                
                let chiSquare = 0;
                for (const count of values) {
                    chiSquare += Math.pow(count - expected, 2) / expected;
                }
                
                return chiSquare;
            }
        }
        
        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
        function calculateShannonEntropy(data) {
            if (!data || data.length === 0) return 0;
            
            const frequencies = new Array(256).fill(0);
            for (const byte of data) {
                frequencies[byte]++;
            }
            
            let entropy = 0;
            for (let i = 0; i < 256; i++) {
                if (frequencies[i] > 0) {
                    const p = frequencies[i] / data.length;
                    entropy -= p * Math.log2(p);
                }
            }
            
            return entropy;
        }
        
        function calculateMinEntropy(data) {
            if (!data || data.length === 0) return 0;
            
            const frequencies = new Array(256).fill(0);
            for (const byte of data) {
                frequencies[byte]++;
            }
            
            const maxFrequency = Math.max(...frequencies);
            const maxProbability = maxFrequency / data.length;
            
            return -Math.log2(maxProbability);
        }
        
        function calculateChiSquare(data) {
            if (!data || data.length === 0) return { chiSquare: 0, pValue: 0 };
            
            const expected = data.length / 256;
            const frequencies = new Array(256).fill(0);
            
            for (const byte of data) {
                frequencies[byte]++;
            }
            
            let chiSquare = 0;
            for (let i = 0; i < 256; i++) {
                chiSquare += Math.pow(frequencies[i] - expected, 2) / expected;
            }
            
            // –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π —Ä–∞—Å—á–µ—Ç p-–∑–Ω–∞—á–µ–Ω–∏—è
            const degreesOfFreedom = 255;
            const pValue = Math.exp(-chiSquare / 2) * Math.pow(chiSquare / 2, degreesOfFreedom / 2 - 1) / 
                          (Math.sqrt(Math.PI * 2) * Math.pow(2, degreesOfFreedom / 2 - 1));
            
            return { chiSquare, pValue };
        }
        
        // –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º
        async function initializeCipher() {
            const key = document.getElementById('keyInput').value;
            const confirmation = document.getElementById('keyConfirmation').value;
            const iterations = parseInt(document.getElementById('pbkdf2Iterations').value);
            
            if (key !== confirmation) {
                alert('–ö–ª—é—á –∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç');
                return;
            }
            
            if (key.length < 12) {
                alert('–ö–ª—é—á –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—åËá≥Â∞ë 12 —Å–∏–º–≤–æ–ª–æ–≤');
                return;
            }
            
            try {
                document.getElementById('initStatus').textContent = '–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...';
                
                cipherInstance = new ProfessionalHomophonicCipher();
                await cipherInstance.initializeWithKey(key, iterations);
                
                document.getElementById('initStatus').textContent = '–®–∏—Ñ—Ä —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω';
                document.getElementById('initStatus').style.color = '#3fb950';
                
            } catch (error) {
                document.getElementById('initStatus').textContent = '–û—à–∏–±–∫–∞: ' + error.message;
                document.getElementById('initStatus').style.color = '#f85149';
            }
        }
        
        async function encryptData() {
            if (!cipherInstance) {
                alert('–°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ —à–∏—Ñ—Ä');
                return;
            }
            
            const inputText = document.getElementById('inputData').value;
            if (!inputText) {
                alert('–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                return;
            }
            
            const mode = document.getElementById('operationMode').value;
            
            try {
                const encryptedData = await cipherInstance.encrypt(inputText, mode);
                
                // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ hex –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                const hexResult = Array.from(encryptedData).map(b => 
                    b.toString(16).padStart(2, '0')).join(' ');
                
                document.getElementById('outputData').textContent = hexResult;
                
                // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
                lastOperationResult = encryptedData;
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏
                const info = `–†–µ–∂–∏–º: ${mode.toUpperCase()}\n` +
                             `–†–∞–∑–º–µ—Ä –¥–∞–Ω–Ω—ã—Ö: ${inputText.length} –±–∞–π—Ç\n` +
                             `–†–∞–∑–º–µ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞: ${encryptedData.length} –±–∞–π—Ç\n` +
                             `IV: ${Array.from(encryptedData.slice(0, 16)).map(b => 
                                 b.toString(16).padStart(2, '0')).join(' ')}`;
                
                document.getElementById('encryptionInfo').textContent = info;
                
            } catch (error) {
                document.getElementById('outputData').textContent = '–û—à–∏–±–∫–∞: ' + error.message;
            }
        }
        
        async function decryptData() {
            if (!cipherInstance) {
                alert('–°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ —à–∏—Ñ—Ä');
                return;
            }
            
            const inputText = document.getElementById('inputData').value;
            if (!inputText) {
                alert('–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                return;
            }
            
            const mode = document.getElementById('operationMode').value;
            
            try {
                // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ hex-—Å—Ç—Ä–æ–∫–∏ –æ–±—Ä–∞—Ç–Ω–æ –≤ –±–∞–π—Ç—ã
                const hexValues = inputText.trim().split(/\s+/);
                const byteArray = new Uint8Array(hexValues.map(h => parseInt(h, 16)));
                
                const decryptedText = await cipherInstance.decrypt(byteArray, mode);
                
                document.getElementById('outputData').textContent = decryptedText;
                
                // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
                const encoder = new TextEncoder();
                lastOperationResult = encoder.encode(decryptedText);
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏
                document.getElementById('encryptionInfo').textContent = 
                    `–†–µ–∂–∏–º: ${mode.toUpperCase()}\n` +
                    `–†–∞–∑–º–µ—Ä –¥–∞–Ω–Ω—ã—Ö: ${byteArray.length} –±–∞–π—Ç\n` +
                    `–†–∞–∑–º–µ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞: ${decryptedText.length} —Å–∏–º–≤–æ–ª–æ–≤`;
                
            } catch (error) {
                document.getElementById('outputData').textContent = '–û—à–∏–±–∫–∞: ' + error.message;
            }
        }
        
        function clearAll() {
            document.getElementById('inputData').value = '';
            document.getElementById('outputData').textContent = '';
            document.getElementById('encryptionInfo').textContent = '';
            document.getElementById('initStatus').textContent = '–®–∏—Ñ—Ä –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω';
            document.getElementById('initStatus').style.color = '';
            lastOperationResult = null;
        }
        
        function switchTab(tabName) {
            // –°–∫—Ä—ã—Ç—å –≤—Å–µ –≤–∫–ª–∞–¥–∫–∏
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // –ü–æ–∫–∞–∑–∞—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—É—é –≤–∫–ª–∞–¥–∫—É
            document.getElementById(tabName).classList.add('active');
            
            // –û–±–Ω–æ–≤–∏—Ç—å –∞–∫—Ç–∏–≤–Ω—É—é –∫–Ω–æ–ø–∫—É –≤–∫–ª–∞–¥–∫–∏
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            event.currentTarget.classList.add('active');
        }
        
        // –§—É–Ω–∫—Ü–∏–∏ –∞–Ω–∞–ª–∏–∑–∞
        function runEntropyAnalysis() {
            if (!lastOperationResult || lastOperationResult.length === 0) {
                alert('–°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∏–ª–∏ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ');
                return;
            }
            
            const shannonEntropy = calculateShannonEntropy(lastOperationResult);
            const minEntropy = calculateMinEntropy(lastOperationResult);
            const chiSquareResult = calculateChiSquare(lastOperationResult);
            
            document.getElementById('shannonEntropy').textContent = shannonEntropy.toFixed(6);
            document.getElementById('minEntropy').textContent = minEntropy.toFixed(6);
            document.getElementById('chiSquare').textContent = chiSquareResult.chiSquare.toFixed(2);
            document.getElementById('pValue').textContent = chiSquareResult.pValue.toFixed(6);
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∞–Ω–∞–ª–∏–∑–∞
            const analysisResults = document.getElementById('analysisResults');
            analysisResults.innerHTML = '';
            
            const tests = [
                { 
                    name: '–≠–Ω—Ç—Ä–æ–ø–∏—è –®–µ–Ω–Ω–æ–Ω–∞', 
                    value: shannonEntropy, 
                    pass: shannonEntropy > 7.9,
                    description: `–≠–Ω—Ç—Ä–æ–ø–∏—è: ${shannonEntropy.toFixed(6)} –±–∏—Ç/–±–∞–π—Ç (–∏–¥–µ–∞–ª: >7.9)`
                },
                { 
                    name: '–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è', 
                    value: minEntropy, 
                    pass: minEntropy > 7,
                    description: `–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è: ${minEntropy.toFixed(6)} –±–∏—Ç/–±–∞–π—Ç (–∏–¥–µ–∞–ª: >7)`
                },
                { 
                    name: 'œá¬≤ —Ç–µ—Å—Ç', 
                    value: chiSquareResult.chiSquare, 
                    pass: chiSquareResult.chiSquare > 200 && chiSquareResult.chiSquare < 300,
                    description: `œá¬≤: ${chiSquareResult.chiSquare.toFixed(2)} (–æ–∂–∏–¥–∞–µ—Ç—Å—è: 200-300)`
                }
            ];
            
            for (const test of tests) {
                const item = document.createElement('div');
                item.className = 'test-item';
                
                const statusClass = test.pass ? 'test-pass' : 'test-fail';
                const statusText = test.pass ? '–ü–†–û–ô–î–ï–ù' : '–ù–ï –ü–†–û–ô–î–ï–ù';
                
                item.innerHTML = `
                    <div>${test.name}</div>
                    <div class="${statusClass}">${statusText}</div>
                `;
                
                analysisResults.appendChild(item);
                
                const desc = document.createElement('div');
                desc.className = 'test-item';
                desc.innerHTML = test.description;
                analysisResults.appendChild(desc);
            }
        }
        
        function runFrequencyTest() {
            // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —á–∞—Å—Ç–æ—Ç–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
            alert('–ß–∞—Å—Ç–æ—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è...');
        }
        
        function runAvalancheTest() {
            // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ç–µ—Å—Ç–∞ –ª–∞–≤–∏–Ω–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞
            alert('–¢–µ—Å—Ç –ª–∞–≤–∏–Ω–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è...');
        }
        
        function runRandomnessTests() {
            // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ç–µ—Å—Ç–æ–≤ —Å–ª—É—á–∞–π–Ω–æ—Å—Ç–∏
            alert('–¢–µ—Å—Ç—ã —Å–ª—É—á–∞–π–Ω–æ—Å—Ç–∏ –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è...');
        }
        
        function analyzeSBox() {
            if (!cipherInstance) {
                alert('–°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ —à–∏—Ñ—Ä');
                return;
            }
            
            const properties = cipherInstance.getSBoxProperties();
            if (!properties) {
                alert('S-Box –Ω–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω');
                return;
            }
            
            const sboxProperties = document.getElementById('sboxProperties');
            sboxProperties.innerHTML = '';
            
            const props = [
                { name: '–†–∞–∑–º–µ—Ä S-Box', value: properties.size },
                { name: '–í—Å–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤', value: properties.totalElements },
                { name: '–£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –æ–º–æ—Ñ–æ–Ω–æ–≤', value: properties.uniqueHomophonesCount },
                { name: '–û—Ö–≤–∞—Ç –∑–Ω–∞—á–µ–Ω–∏–π', value: `${properties.uniqueHomophonesCount}/65536` },
                { name: '–†–∞–≤–Ω–æ–º–µ—Ä–Ω–æ—Å—Ç—å —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è', value: properties.uniformityScore.toFixed(2) }
            ];
            
            for (const prop of props) {
                const item = document.createElement('div');
                item.className = 'test-item';
                item.innerHTML = `
                    <div>${prop.name}</div>
                    <div>${prop.value}</div>
                `;
                sboxProperties.appendChild(item);
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–∫–ª—é—á–µ–Ω–∏—è
            document.getElementById('frequencyResistance').textContent = 
                properties.uniformityScore < 500 ? '–í—ã—Å–æ–∫–∞—è' : '–°—Ä–µ–¥–Ω—è—è';
            document.getElementById('entropyEfficiency').textContent = 
                properties.uniqueHomophonesCount === 65536 ? '–ò–¥–µ–∞–ª—å–Ω–∞—è' : '–•–æ—Ä–æ—à–∞—è';
        }
        
        function visualizeSBox() {
            if (!cipherInstance || !cipherInstance.sBox) {
                alert('S-Box –Ω–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω');
                return;
            }
            
            const sboxTable = document.getElementById('sboxTable');
            sboxTable.innerHTML = '';
            
            // –ó–∞–≥–æ–ª–æ–≤–æ–∫
            const emptyHeader = document.createElement('div');
            emptyHeader.className = 'sbox-header';
            sboxTable.appendChild(emptyHeader);
            
            for (let j = 0; j < 16; j++) {
                const header = document.createElement('div');
                header.className = 'sbox-header';
                header.textContent = j.toString(16).toUpperCase();
                sboxTable.appendChild(header);
            }
            
            // –î–∞–Ω–Ω—ã–µ S-Box (–ø–µ—Ä–≤—ã–µ 16x16 –∑–Ω–∞—á–µ–Ω–∏–π)
            for (let i = 0; i < 16; i++) {
                const rowHeader = document.createElement('div');
                rowHeader.className = 'sbox-header';
                rowHeader.textContent = i.toString(16).toUpperCase();
                sboxTable.appendChild(rowHeader);
                
                for (let j = 0; j < 16; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'sbox-cell';
                    
                    const byteValue = i * 16 + j;
                    const homophone = cipherInstance.sBox[byteValue][0]; // –ü–µ—Ä–≤—ã–π –æ–º–æ—Ñ–æ–Ω –¥–ª—è —è—á–µ–π–∫–∏
                    
                    cell.textContent = homophone.toString(16).padStart(4, '0');
                    cell.title = `S-Box[${byteValue}][0] = ${homophone}`;
                    
                    sboxTable.appendChild(cell);
                }
            }
        }
    </script>
</body>
</html>
