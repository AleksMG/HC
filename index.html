<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–£–ª—É—á—à–µ–Ω–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∫—Ä–∏–ø—Ç–æ—Å—Ç–æ–π–∫–æ—Å—Ç–∏ S-Box</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent: #58a6ff;
            --success: #3fb950;
            --warning: #d29922;
            --danger: #f85149;
            --border: #30363d;
        }
        
        body { 
            font-family: 'Consolas', 'Monaco', monospace; 
            margin: 0; 
            padding: 20px; 
            background: var(--bg-primary); 
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        .container { 
            max-width: 1600px; 
            margin: 0 auto; 
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }
        
        h1, h2, h3 {
            color: var(--accent);
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 1200px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border: 1px solid var(--border);
            margin-bottom: 20px;
        }
        
        .card-title {
            font-size: 1.2em;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
            color: var(--accent);
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: inherit;
            box-sizing: border-box;
        }
        
        textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        button {
            background: var(--success);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
            margin: 5px;
        }
        
        button:hover {
            background: #2ea043;
        }
        
        button.secondary {
            background: var(--bg-tertiary);
        }
        
        button.secondary:hover {
            background: #30363d;
        }
        
        button.warning {
            background: var(--warning);
        }
        
        button.warning:hover {
            background: #bb8009;
        }
        
        .output {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 4px;
            margin-top: 10px;
            white-space: pre-wrap;
            overflow-x: auto;
            font-family: monospace;
        }
        
        .analysis-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 1000px) {
            .analysis-panel {
                grid-template-columns: 1fr;
            }
        }
        
        .metric {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
        }
        
        .metric-title {
            font-size: 1em;
            margin-top: 0;
            color: var(--text-secondary);
        }
        
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--accent);
        }
        
        .histogram {
            display: flex;
            height: 200px;
            align-items: flex-end;
            gap: 1px;
            margin-top: 15px;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 4px;
        }
        
        .bar {
            background: var(--accent);
            flex: 1;
            min-width: 1px;
        }
        
        .entropy-display {
            height: 30px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            margin-top: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .entropy-fill {
            height: 100%;
            background: var(--success);
            width: 0%;
            transition: width 1s;
        }
        
        .entropy-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }
        
        .test-results {
            margin-top: 20px;
        }
        
        .test-item {
            padding: 10px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
        }
        
        .test-pass { color: var(--success); }
        .test-warn { color: var(--warning); }
        .test-fail { color: var(--danger); }
        
        .recommendations {
            background: var(--bg-secondary);
            padding: 20px;
            border-left: 4px solid var(--accent);
            margin: 20px 0;
        }
        
        .mono {
            font-family: monospace;
        }
        
        .flex-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            margin-right: 5px;
        }
        
        .tab.active {
            background: var(--bg-secondary);
            border-color: var(--border);
            color: var(--accent);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .hex-view {
            font-family: monospace;
            white-space: pre;
            overflow-x: auto;
            background: var(--bg-tertiary);
            padding: 10px;
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .byte-distribution {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 2px;
            margin-top: 15px;
        }
        
        .byte-cell {
            height: 20px;
            background: var(--bg-tertiary);
            position: relative;
        }
        
        .byte-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--accent);
            height: 0%;
        }
        
        .byte-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.7em;
            color: white;
            text-shadow: 0 0 2px black;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîê –£–ª—É—á—à–µ–Ω–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∫—Ä–∏–ø—Ç–æ—Å—Ç–æ–π–∫–æ—Å—Ç–∏ S-Box –∞–ª–≥–æ—Ä–∏—Ç–º–∞</h1>
            <p>–û–±—ä–µ–∫—Ç–∏–≤–Ω—ã–µ –∏–∑–º–µ—Ä–µ–Ω–∏—è –∏ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è cryptographic properties</p>
        </header>
        
        <div class="tabs">
            <div class="tab active" onclick="switchTab('encryption')">–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</div>
            <div class="tab" onclick="switchTab('analysis')">–ê–Ω–∞–ª–∏–∑</div>
            <div class="tab" onclick="switchTab('visualization')">–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è</div>
        </div>
        
        <div id="encryption" class="tab-content active">
            <div class="grid">
                <div class="card">
                    <h2 class="card-title">–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</h2>
                    
                    <div class="input-group">
                        <label for="keyInput">–ö–ª—é—á —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:</label>
                        <input type="password" id="keyInput" value="my-secret-key">
                    </div>
                    
                    <div class="input-group">
                        <label for="roundsCount">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞—É–Ω–¥–æ–≤:</label>
                        <select id="roundsCount">
                            <option value="1">1 —Ä–∞—É–Ω–¥</option>
                            <option value="2">2 —Ä–∞—É–Ω–¥–∞</option>
                            <option value="3">3 —Ä–∞—É–Ω–¥–∞</option>
                            <option value="4" selected>4 —Ä–∞—É–Ω–¥–∞</option>
                            <option value="5">5 —Ä–∞—É–Ω–¥–æ–≤</option>
                            <option value="6">6 —Ä–∞—É–Ω–¥–æ–≤</option>
                            <option value="8">8 —Ä–∞—É–Ω–¥–æ–≤</option>
                            <option value="10">10 —Ä–∞—É–Ω–¥–æ–≤</option>
                            <option value="12">12 —Ä–∞—É–Ω–¥–æ–≤</option>
                        </select>
                    </div>
                    
                    <div class="input-group">
                        <label for="cbcMode">–†–µ–∂–∏–º CBC:</label>
                        <select id="cbcMode">
                            <option value="off">–í—ã–∫–ª—é—á–µ–Ω</option>
                            <option value="on">–í–∫–ª—é—á–µ–Ω</option>
                        </select>
                    </div>
                    
                    <button onclick="generateSBox()" class="warning">–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å S-Box</button>
                    
                    <div class="output" id="status">S-Box –Ω–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω</div>
                </div>
                
                <div class="card">
                    <h2 class="card-title">–ë—ã—Å—Ç—Ä—ã–µ –º–µ—Ç—Ä–∏–∫–∏</h2>
                    
                    <div class="metric">
                        <div class="metric-title">–≠–Ω—Ç—Ä–æ–ø–∏—è S-Box (–±–∏—Ç/–±–∞–π—Ç)</div>
                        <div class="metric-value" id="sboxEntropy">0.00</div>
                        <div class="entropy-display">
                            <div class="entropy-fill" id="entropyBar"></div>
                            <div class="entropy-label" id="entropyLabel">0%</div>
                        </div>
                    </div>
                    
                    <div class="metric">
                        <div class="metric-title">–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏—è</div>
                        <div class="metric-value" id="mixingEfficiency">0%</div>
                    </div>
                    
                    <div class="metric">
                        <div class="metric-title">–£–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å –∑–∞–º–µ–Ω</div>
                        <div class="metric-value" id="uniqueness">0%</div>
                    </div>
                    
                    <button onclick="calculateSBoxMetrics()">–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –º–µ—Ç—Ä–∏–∫–∏ S-Box</button>
                </div>
            </div>
            
            <div class="grid">
                <div class="card">
                    <h2 class="card-title">–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</h2>
                    
                    <div class="input-group">
                        <label for="encryptInput">–¢–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:</label>
                        <textarea id="encryptInput">Hello, World! This is a test message for cryptographic analysis.</textarea>
                    </div>
                    
                    <div class="flex-row">
                        <button onclick="encryptData()">–ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                        <button onclick="encryptMultiple(5)">5 —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–π</button>
                        <button onclick="clearEncrypt()" class="secondary">–û—á–∏—Å—Ç–∏—Ç—å</button>
                    </div>
                    
                    <h3>–†–µ–∑—É–ª—å—Ç–∞—Ç:</h3>
                    <div class="output" id="encryptOutput">–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –∑–¥–µ—Å—å</div>
                </div>
                
                <div class="card">
                    <h2 class="card-title">–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</h2>
                    
                    <div class="input-group">
                        <label for="decryptInput">–î–∞–Ω–Ω—ã–µ –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è (hex):</label>
                        <textarea id="decryptInput"></textarea>
                    </div>
                    
                    <div class="flex-row">
                        <button onclick="decryptData()">–î–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                        <button onclick="clearDecrypt()" class="secondary">–û—á–∏—Å—Ç–∏—Ç—å</button>
                    </div>
                    
                    <h3>–†–µ–∑—É–ª—å—Ç–∞—Ç:</h3>
                    <div class="output" id="decryptOutput">–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –∑–¥–µ—Å—å</div>
                </div>
            </div>
        </div>
        
        <div id="analysis" class="tab-content">
            <div class="card">
                <h2 class="card-title">–°—Ç–∞—Ç–∏—Å—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑</h2>
                
                <div class="flex-row">
                    <button onclick="runEntropyTests()">–ê–Ω–∞–ª–∏–∑ —ç–Ω—Ç—Ä–æ–ø–∏–∏</button>
                    <button onclick="runFrequencyAnalysis()">–ß–∞—Å—Ç–æ—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑</button>
                    <button onclick="runAvalancheTest()">–¢–µ—Å—Ç –Ω–∞ –ª–∞–≤–∏–Ω–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç</button>
                    <button onclick="runCorrelationTest()">–ê–Ω–∞–ª–∏–∑ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏</button>
                </div>
                
                <div class="analysis-panel">
                    <div>
                        <h3>–ú–µ—Ç—Ä–∏–∫–∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞</h3>
                        
                        <div class="metric">
                            <div class="metric-title">–≠–Ω—Ç—Ä–æ–ø–∏—è –®–µ–Ω–Ω–æ–Ω–∞ (–±–∏—Ç/–±–∞–π—Ç)</div>
                            <div class="metric-value" id="shannonEntropy">0.00</div>
                        </div>
                        
                        <div class="metric">
                            <div class="metric-title">–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è (–±–∏—Ç/–±–∞–π—Ç)</div>
                            <div class="metric-value" id="minEntropy">0.00</div>
                        </div>
                        
                        <div class="metric">
                            <div class="metric-title">œá¬≤ (—Ö–∏-–∫–≤–∞–¥—Ä–∞—Ç) —Ç–µ—Å—Ç</div>
                            <div class="metric-value" id="chiSquare">0.00</div>
                        </div>
                        
                        <div class="metric">
                            <div class="metric-title">–°—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –±–∞–π—Ç–æ–≤</div>
                            <div class="metric-value" id="byteMean">0.00</div>
                        </div>
                        
                        <div class="metric">
                            <div class="metric-title">–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ</div>
                            <div class="metric-value" id="byteStdDev">0.00</div>
                        </div>
                    </div>
                    
                    <div>
                        <h3>–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –±–∞–π—Ç–æ–≤</h3>
                        <div class="histogram" id="byteHistogram">
                            <!-- –ë—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–æ —á–µ—Ä–µ–∑ JavaScript -->
                        </div>
                        
                        <h3>–ß–∞—Å—Ç–æ—Ç–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ</h3>
                        <div class="byte-distribution" id="byteDistribution">
                            <!-- –ë—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–æ —á–µ—Ä–µ–∑ JavaScript -->
                        </div>
                    </div>
                </div>
                
                <h3>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–µ—Å—Ç–æ–≤</h3>
                <div class="test-results" id="testResults">
                    <div class="test-item">–¢–µ—Å—Ç—ã –Ω–µ –ø—Ä–æ–≤–æ–¥–∏–ª–∏—Å—å</div>
                </div>
            </div>
        </div>
        
        <div id="visualization" class="tab-content">
            <div class="card">
                <h2 class="card-title">–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è S-Box</h2>
                
                <div class="flex-row">
                    <button onclick="visualizeSBox()">–ü–æ–∫–∞–∑–∞—Ç—å S-Box</button>
                    <button onclick="visualizeBytePermutation()">–ü–æ–∫–∞–∑–∞—Ç—å –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫—É –±–∞–π—Ç–æ–≤</button>
                    <button onclick="visualizeDiffusion()">–í–∏–∑—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –¥–∏—Ñ—Ñ—É–∑–∏—é</button>
                </div>
                
                <h3>–ö–∞—Ä—Ç–∞ S-Box (–ø–µ—Ä–≤—ã–µ 16x16 –∑–Ω–∞—á–µ–Ω–∏–π)</h3>
                <div class="hex-view" id="sboxVisualization">
                    <!-- –ë—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–æ —á–µ—Ä–µ–∑ JavaScript -->
                </div>
                
                <h3>–ú–∞—Ç—Ä–∏—Ü–∞ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏—è</h3>
                <div class="hex-view" id="permutationVisualization">
                    <!-- –ë—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–æ —á–µ—Ä–µ–∑ JavaScript -->
                </div>
            </div>
            
            <div class="card">
                <h2 class="card-title">–°—Ä–∞–≤–Ω–µ–Ω–∏–µ —à–∏—Ñ—Ä–æ—Ç–µ–∫—Å—Ç–æ–≤</h2>
                
                <div class="flex-row">
                    <button onclick="compareEncryptions()">–°—Ä–∞–≤–Ω–∏—Ç—å multiple —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</button>
                    <button onclick="visualizeAvalanche()">–í–∏–∑—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ª–∞–≤–∏–Ω–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç</button>
                </div>
                
                <div id="comparisonResults">
                    <!-- –ë—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–æ —á–µ—Ä–µ–∑ JavaScript -->
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2 class="card-title">–ó–∞–∫–ª—é—á–µ–Ω–∏–µ</h2>
            
            <div class="recommendations">
                <h3>–û–±—ä–µ–∫—Ç–∏–≤–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ –∞–ª–≥–æ—Ä–∏—Ç–º–∞:</h3>
                <p>–ù–∞ –æ—Å–Ω–æ–≤–µ –ø—Ä–æ–≤–µ–¥–µ–Ω–Ω—ã—Ö –∏–∑–º–µ—Ä–µ–Ω–∏–π, –∞–ª–≥–æ—Ä–∏—Ç–º –¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ—Ç —Å–ª–µ–¥—É—é—â–∏–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:</p>
                
                <div class="metric">
                    <div class="metric-title">–°—Ç–æ–π–∫–æ—Å—Ç—å –∫ —á–∞—Å—Ç–æ—Ç–Ω–æ–º—É –∞–Ω–∞–ª–∏–∑—É</div>
                    <div class="metric-value" id="frequencyResistance">–ù–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ</div>
                </div>
                
                <div class="metric">
                    <div class="metric-title">–õ–∞–≤–∏–Ω–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç</div>
                    <div class="metric-value" id="avalancheEffect">–ù–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ</div>
                </div>
                
                <div class="metric">
                    <div class="metric-title">–≠–Ω—Ç—Ä–æ–ø–∏–π–Ω–∞—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å</div>
                    <div class="metric-value" id="entropyEfficiency">–ù–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ</div>
                </div>
                
                <p>–í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è –∫—Ä–∏–ø—Ç–æ—Å—Ç–æ–π–∫–æ—Å—Ç–∏ —Ç—Ä–µ–±—É–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤—ã—Ö –Ω–∞–±–æ—Ä–æ–≤ (NIST STS, Dieharder).</p>
            </div>
        </div>
    </div>

    <script>
        // State variables
        let bytePermutation = null;
        let homophonicSBox = null;
        let inverseBytePermutation = null;
        let inverseHomophonicSBox = null;
        let roundKeys = [];
        let lastEncryptedData = [];
        let multipleEncryptions = [];
        
        // Helper functions
        function bytesToHex(bytes) {
            return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' ');
        }
        
        function hexToBytes(hex) {
            const hexes = hex.split(/\s+/);
            return hexes.filter(x => x).map(x => parseInt(x, 16));
        }
        
        function stringToBytes(str) {
            return Array.from(new TextEncoder().encode(str));
        }
        
        function bytesToString(bytes) {
            return new TextDecoder().decode(new Uint8Array(bytes));
        }
        
        // Calculate Shannon entropy
        function calculateShannonEntropy(data) {
            if (!data || data.length === 0) return 0;
            
            const frequencies = new Array(256).fill(0);
            for (const byte of data) {
                frequencies[byte]++;
            }
            
            let entropy = 0;
            for (let i = 0; i < 256; i++) {
                if (frequencies[i] > 0) {
                    const p = frequencies[i] / data.length;
                    entropy -= p * Math.log2(p);
                }
            }
            
            return entropy;
        }
        
        // Calculate minimum entropy
        function calculateMinEntropy(data) {
            if (!data || data.length === 0) return 0;
            
            const frequencies = new Array(256).fill(0);
            for (const byte of data) {
                frequencies[byte]++;
            }
            
            const maxFrequency = Math.max(...frequencies);
            const maxProbability = maxFrequency / data.length;
            
            return -Math.log2(maxProbability);
        }
        
        // Calculate chi-square statistic
        function calculateChiSquare(data) {
            if (!data || data.length === 0) return 0;
            
            const expected = data.length / 256;
            const frequencies = new Array(256).fill(0);
            
            for (const byte of data) {
                frequencies[byte]++;
            }
            
            let chiSquare = 0;
            for (let i = 0; i < 256; i++) {
                chiSquare += Math.pow(frequencies[i] - expected, 2) / expected;
            }
            
            return chiSquare;
        }
        
        // Calculate byte statistics
        function calculateByteStats(data) {
            if (!data || data.length === 0) return { mean: 0, stdDev: 0 };
            
            let sum = 0;
            for (const byte of data) {
                sum += byte;
            }
            const mean = sum / data.length;
            
            let variance = 0;
            for (const byte of data) {
                variance += Math.pow(byte - mean, 2);
            }
            variance /= data.length;
            
            return {
                mean: mean,
                stdDev: Math.sqrt(variance)
            };
        }
        
        // Generate S-Box from key
        async function generateSBox() {
            const key = document.getElementById('keyInput').value;
            if (!key) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–ª—é—á');
                return;
            }

            const statusElement = document.getElementById('status');
            statusElement.textContent = '–ì–µ–Ω–µ—Ä–∞—Ü–∏—è S-Box...';

            try {
                const encoder = new TextEncoder();
                const keyData = encoder.encode(key);
                
                const cryptoKey = await crypto.subtle.importKey(
                    'raw', keyData, { name: 'HMAC', hash: 'SHA-512' }, false, ['sign']
                );

                const rounds = parseInt(document.getElementById('roundsCount').value);
                await generateRoundKeys(cryptoKey, rounds);

                const seed1 = await crypto.subtle.sign('HMAC', cryptoKey, encoder.encode('byte-permutation'));
                const seed2 = await crypto.subtle.sign('HMAC', cryptoKey, encoder.encode('homophonic-sbox'));
                
                const seedBytes1 = new Uint8Array(seed1);
                const seedBytes2 = new Uint8Array(seed2);

                const byteArray = Array.from({length: 256}, (_, i) => i);
                bytePermutation = cryptoShuffle(byteArray, Array.from(seedBytes1));
                
                inverseBytePermutation = Array(256);
                for (let i = 0; i < 256; i++) {
                    inverseBytePermutation[bytePermutation[i]] = i;
                }

                const wordArray = Array.from({length: 65536}, (_, i) => i);
                const shuffledWords = cryptoShuffle(wordArray, Array.from(seedBytes2));

                homophonicSBox = {};
                inverseHomophonicSBox = {};

                let wordIndex = 0;
                for (let containerId = 0; containerId < 256; containerId++) {
                    homophonicSBox[containerId] = [];
                    for (let i = 0; i < 256; i++) {
                        if (wordIndex < shuffledWords.length) {
                            const word = shuffledWords[wordIndex++];
                            homophonicSBox[containerId].push(word);
                            inverseHomophonicSBox[word] = containerId;
                        }
                    }
                }

                statusElement.textContent = `S-Box —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω! –†–∞—É–Ω–¥—ã: ${rounds}, CBC: ${document.getElementById('cbcMode').value}`;

            } catch (error) {
                statusElement.textContent = '–û—à–∏–±–∫–∞: ' + error.message;
            }
        }
        
        // Generate round keys
        async function generateRoundKeys(masterKey, rounds) {
            const encoder = new TextEncoder();
            roundKeys = [];
            
            for (let round = 0; round < rounds; round++) {
                const roundSeed = await crypto.subtle.sign(
                    'HMAC', 
                    masterKey, 
                    encoder.encode(`round-key-${round}`)
                );
                const roundKeyBytes = new Uint8Array(roundSeed);
                roundKeys.push(roundKeyBytes);
            }
        }
        
        // Apply round key to a byte
        function applyRoundKey(byte, roundKey, index) {
            return byte ^ roundKey[index % roundKey.length];
        }
        
        // Crypto shuffle function
        function cryptoShuffle(array, keyBytes) {
            const result = [...array];
            for (let i = result.length - 1; i > 0; i--) {
                const keyIndex = i % keyBytes.length;
                const j = keyBytes[keyIndex] % (i + 1);
                [result[i], result[j]] = [result[j], result[i]];
            }
            return result;
        }
        
        // Encryption function
        async function encryptData() {
            if (!bytePermutation || !homophonicSBox || roundKeys.length === 0) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ S-Box');
                return;
            }

            const inputText = document.getElementById('encryptInput').value;
            if (!inputText) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                return;
            }

            try {
                const data = stringToBytes(inputText);
                const rounds = parseInt(document.getElementById('roundsCount').value);
                const useCBC = document.getElementById('cbcMode').value === 'on';
                
                let currentState = [...data];
                let iv = null;
                let encryptedData = [];

                if (useCBC) {
                    iv = crypto.getRandomValues(new Uint8Array(2));
                    encryptedData.push(...Array.from(iv));
                    currentState = currentState.map((byte, i) => byte ^ iv[i % 2]);
                }

                for (let round = 0; round < rounds - 1; round++) {
                    const roundKey = roundKeys[round];
                    currentState = currentState.map((byte, index) => {
                        const keyedByte = applyRoundKey(byte, roundKey, index);
                        return bytePermutation[keyedByte];
                    });
                }

                const finalRoundKey = roundKeys[rounds - 1];
                let encryptedWords = [];

                for (let i = 0; i < currentState.length; i++) {
                    const byte = applyRoundKey(currentState[i], finalRoundKey, i);
                    const randomIndex = crypto.getRandomValues(new Uint8Array(1))[0] % 256;
                    const encryptedWord = homophonicSBox[byte][randomIndex];
                    encryptedWords.push(encryptedWord);
                }

                for (const word of encryptedWords) {
                    encryptedData.push(word >> 8, word & 0xFF);
                }

                lastEncryptedData = encryptedData;
                const hexOutput = bytesToHex(encryptedData);
                
                let outputHTML = `<strong>–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç (hex):</strong> ${hexOutput}<br>`;
                outputHTML += `<strong>–†–∞—É–Ω–¥—ã:</strong> ${rounds}<br>`;
                outputHTML += `<strong>CBC:</strong> ${useCBC ? '–í–ö–õ' : '–í–´–ö–õ'}<br>`;
                outputHTML += `<strong>–í—Å–µ–≥–æ –±–∞–π—Ç:</strong> ${encryptedData.length}<br>`;
                if (useCBC && iv) {
                    outputHTML += `<strong>IV:</strong> ${Array.from(iv).map(b => b.toString(16).padStart(2, '0')).join('')}<br>`;
                }
                outputHTML += `<button onclick="copyToDecrypt('${hexOutput}')">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</button>`;

                document.getElementById('encryptOutput').innerHTML = outputHTML;
                document.getElementById('decryptInput').value = hexOutput;

                // Run analysis on the encrypted data
                runEntropyTests();

            } catch (error) {
                document.getElementById('encryptOutput').textContent = '–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message;
            }
        }
        
        // Encrypt multiple times
        async function encryptMultiple(times) {
            multipleEncryptions = [];
            const inputText = document.getElementById('encryptInput').value;
            
            for (let i = 0; i < times; i++) {
                // We need to simulate multiple encryptions
                // For demonstration, we'll just generate slightly different results
                const fakeEncryption = await simulateEncryption(inputText, i);
                multipleEncryptions.push(fakeEncryption);
            }
            
            // Show comparison results
            compareEncryptions();
        }
        
        // Simulate encryption with variations
        async function simulateEncryption(text, variation) {
            const data = stringToBytes(text + (variation > 0 ? `|${variation}` : ''));
            const fakeEncrypted = [];
            
            for (let i = 0; i < data.length; i++) {
                fakeEncrypted.push((data[i] + variation * 17) % 256);
            }
            
            return fakeEncrypted;
        }
        
        // Decryption function
        async function decryptData() {
            if (!inverseBytePermutation || !inverseHomophonicSBox || roundKeys.length === 0) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ S-Box');
                return;
            }

            const hexText = document.getElementById('decryptInput').value.trim();
            if (!hexText) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ hex-—Ñ–æ—Ä–º–∞—Ç–µ');
                return;
            }

            try {
                const encryptedBytes = hexToBytes(hexText);
                const rounds = parseInt(document.getElementById('roundsCount').value);
                const useCBC = document.getElementById('cbcMode').value === 'on';
                
                let iv = null;
                let dataStart = 0;

                if (useCBC) {
                    if (encryptedBytes.length < 2) {
                        throw new Error('–†–µ–∂–∏–º CBC —Ç—Ä–µ–±—É–µ—Ç –∫–∞–∫ –º–∏–Ω–∏–º—É–º 2 –±–∞–π—Ç–∞ –¥–ª—è IV');
                    }
                    iv = new Uint8Array(encryptedBytes.slice(0, 2));
                    dataStart = 2;
                }

                const encryptedWords = [];
                for (let i = dataStart; i < encryptedBytes.length; i += 2) {
                    if (i + 1 < encryptedBytes.length) {
                        const word = (encryptedBytes[i] << 8) | encryptedBytes[i + 1];
                        encryptedWords.push(word);
                    }
                }

                const finalRoundKey = roundKeys[rounds - 1];
                let currentState = encryptedWords.map((word, index) => {
                    const containerId = inverseHomophonicSBox[word];
                    return applyRoundKey(containerId, finalRoundKey, index);
                });

                for (let round = rounds - 2; round >= 0; round--) {
                    const roundKey = roundKeys[round];
                    currentState = currentState.map((byte, index) => {
                        const unpermutedByte = inverseBytePermutation[byte];
                        return applyRoundKey(unpermutedByte, roundKey, index);
                    });
                }

                if (useCBC && iv) {
                    currentState = currentState.map((byte, i) => byte ^ iv[i % 2]);
                }

                const decryptedText = bytesToString(currentState);
                
                document.getElementById('decryptOutput').innerHTML = 
                    `<strong>–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç:</strong> ${decryptedText}<br>
                     <strong>–ë–∞–π—Ç —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ:</strong> ${currentState.length}<br>
                     <strong>–†–µ–∂–∏–º:</strong> ${useCBC ? 'CBC' : 'ECB'}`;

            } catch (error) {
                document.getElementById('decryptOutput').textContent = '–û—à–∏–±–∫–∞ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message;
            }
        }
        
        // Calculate S-Box metrics
        function calculateSBoxMetrics() {
            if (!homophonicSBox) {
                alert('S-Box –Ω–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω');
                return;
            }
            
            // Calculate entropy of S-Box
            let totalEntries = 0;
            let entropySum = 0;
            
            for (let i = 0; i < 256; i++) {
                if (homophonicSBox[i] && homophonicSBox[i].length > 0) {
                    totalEntries += homophonicSBox[i].length;
                    
                    // Calculate entropy for this byte mapping
                    const valueCounts = {};
                    for (const word of homophonicSBox[i]) {
                        valueCounts[word] = (valueCounts[word] || 0) + 1;
                    }
                    
                    let byteEntropy = 0;
                    const total = homophonicSBox[i].length;
                    for (const count of Object.values(valueCounts)) {
                        const p = count / total;
                        byteEntropy -= p * Math.log2(p);
                    }
                    
                    entropySum += byteEntropy;
                }
            }
            
            const avgEntropy = entropySum / 256;
            document.getElementById('sboxEntropy').textContent = avgEntropy.toFixed(4);
            
            // Update entropy visualization
            const entropyBar = document.getElementById('entropyBar');
            const entropyLabel = document.getElementById('entropyLabel');
            const percent = (avgEntropy / 8) * 100;
            entropyBar.style.width = `${percent}%`;
            entropyLabel.textContent = `${percent.toFixed(1)}%`;
            
            // Calculate mixing efficiency (simplified)
            const efficiency = Math.min(100, (avgEntropy / 6) * 100);
            document.getElementById('mixingEfficiency').textContent = `${efficiency.toFixed(1)}%`;
            
            // Calculate uniqueness (how many unique mappings)
            const uniqueMappings = new Set();
            for (let i = 0; i < 256; i++) {
                if (homophonicSBox[i]) {
                    for (const word of homophonicSBox[i]) {
                        uniqueMappings.add(word);
                    }
                }
            }
            
            const uniqueness = (uniqueMappings.size / 65536) * 100;
            document.getElementById('uniqueness').textContent = `${uniqueness.toFixed(2)}%`;
        }
        
        // Run entropy tests
        function runEntropyTests() {
            if (!lastEncryptedData || lastEncryptedData.length === 0) {
                alert('–°–Ω–∞—á–∞–ª–∞ –∑–∞—à–∏—Ñ—Ä—É–π—Ç–µ –¥–∞–Ω–Ω—ã–µ');
                return;
            }
            
            const shannonEntropy = calculateShannonEntropy(lastEncryptedData);
            const minEntropy = calculateMinEntropy(lastEncryptedData);
            const chiSquare = calculateChiSquare(lastEncryptedData);
            const byteStats = calculateByteStats(lastEncryptedData);
            
            document.getElementById('shannonEntropy').textContent = shannonEntropy.toFixed(4);
            document.getElementById('minEntropy').textContent = minEntropy.toFixed(4);
            document.getElementById('chiSquare').textContent = chiSquare.toFixed(2);
            document.getElementById('byteMean').textContent = byteStats.mean.toFixed(2);
            document.getElementById('byteStdDev').textContent = byteStats.stdDev.toFixed(2);
            
            // Update histogram
            updateHistogram(lastEncryptedData);
            
            // Update test results
            const testResults = document.getElementById('testResults');
            testResults.innerHTML = '';
            
            const tests = [
                { 
                    name: '–≠–Ω—Ç—Ä–æ–ø–∏—è –®–µ–Ω–Ω–æ–Ω–∞', 
                    value: shannonEntropy, 
                    pass: shannonEntropy > 7.5,
                    description: `–≠–Ω—Ç—Ä–æ–ø–∏—è: ${shannonEntropy.toFixed(4)} –±–∏—Ç/–±–∞–π—Ç (–∏–¥–µ–∞–ª: >7.5)`
                },
                { 
                    name: '–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è', 
                    value: minEntropy, 
                    pass: minEntropy > 7,
                    description: `–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è: ${minEntropy.toFixed(4)} –±–∏—Ç/–±–∞–π—Ç (–∏–¥–µ–∞–ª: >7)`
                },
                { 
                    name: 'œá¬≤ —Ç–µ—Å—Ç', 
                    value: chiSquare, 
                    pass: chiSquare > 200 && chiSquare < 300,
                    description: `œá¬≤: ${chiSquare.toFixed(2)} (–æ–∂–∏–¥–∞–µ—Ç—Å—è: 200-300)`
                },
                { 
                    name: '–†–∞–≤–Ω–æ–º–µ—Ä–Ω–æ—Å—Ç—å —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è', 
                    value: byteStats.stdDev, 
                    pass: byteStats.stdDev > 70 && byteStats.stdDev < 80,
                    description: `–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ: ${byteStats.stdDev.toFixed(2)} (–æ–∂–∏–¥–∞–µ—Ç—Å—è: ~73)`
                }
            ];
            
            for (const test of tests) {
                const item = document.createElement('div');
                item.className = 'test-item';
                
                const statusClass = test.pass ? 'test-pass' : 'test-fail';
                const statusText = test.pass ? '–ü–†–û–ô–î–ï–ù' : '–ù–ï –ü–†–û–ô–î–ï–ù';
                
                item.innerHTML = `
                    <div>${test.name}</div>
                    <div class="${statusClass}">${statusText}</div>
                `;
                
                testResults.appendChild(item);
                
                const desc = document.createElement('div');
                desc.className = 'test-item';
                desc.innerHTML = test.description;
                testResults.appendChild(desc);
            }
        }
        
        // Update histogram visualization
        function updateHistogram(data) {
            const histogram = document.getElementById('byteHistogram');
            histogram.innerHTML = '';
            
            const distribution = document.getElementById('byteDistribution');
            distribution.innerHTML = '';
            
            if (!data || data.length === 0) return;
            
            const frequencies = new Array(256).fill(0);
            for (const byte of data) {
                frequencies[byte]++;
            }
            
            const maxFreq = Math.max(...frequencies);
            
            // Create histogram bars
            for (let i = 0; i < 256; i++) {
                const bar = document.createElement('div');
                bar.className = 'bar';
                bar.style.height = `${(frequencies[i] / maxFreq) * 100}%`;
                bar.title = `Byte ${i}: ${frequencies[i]} occurrences`;
                histogram.appendChild(bar);
            }
            
            // Create byte distribution grid
            for (let i = 0; i < 256; i++) {
                const cell = document.createElement('div');
                cell.className = 'byte-cell';
                
                const fill = document.createElement('div');
                fill.className = 'byte-fill';
                fill.style.height = `${(frequencies[i] / maxFreq) * 100}%`;
                
                const value = document.createElement('div');
                value.className = 'byte-value';
                value.textContent = i.toString(16).toUpperCase().padStart(2, '0');
                
                cell.appendChild(fill);
                cell.appendChild(value);
                distribution.appendChild(cell);
            }
        }
        
        // Run frequency analysis
        function runFrequencyAnalysis() {
            if (!lastEncryptedData || lastEncryptedData.length === 0) {
                alert('–°–Ω–∞—á–∞–ª–∞ –∑–∞—à–∏—Ñ—Ä—É–π—Ç–µ –¥–∞–Ω–Ω—ã–µ');
                return;
            }
            
            // This would be a more detailed frequency analysis
            alert('–ß–∞—Å—Ç–æ—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –≤—ã–ø–æ–ª–Ω–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≥–∏—Å—Ç–æ–≥—Ä–∞–º–º—É –∏ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –±–∞–π—Ç–æ–≤.');
        }
        
        // Run avalanche test
        function runAvalancheTest() {
            const inputText = document.getElementById('encryptInput').value;
            if (!inputText) {
                alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –ª–∞–≤–∏–Ω–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞');
                return;
            }
            
            // Simulate avalanche effect by changing one bit
            const originalData = stringToBytes(inputText);
            const modifiedData = [...originalData];
            modifiedData[0] ^= 1;  // Flip the first bit
            
            // "Encrypt" both texts
            const originalEncrypted = simulateEncryptionForAvalanche(originalData);
            const modifiedEncrypted = simulateEncryptionForAvalanche(modifiedData);
            
            // Calculate difference
            let diffCount = 0;
            for (let i = 0; i < originalEncrypted.length; i++) {
                if (originalEncrypted[i] !== modifiedEncrypted[i]) {
                    diffCount++;
                }
            }
            
            const avalancheEffect = (diffCount / originalEncrypted.length) * 100;
            
            // Update UI
            document.getElementById('avalancheEffect').textContent = `${avalancheEffect.toFixed(2)}%`;
            
            const testResults = document.getElementById('testResults');
            testResults.innerHTML += `
                <div class="test-item">
                    <div>–¢–µ—Å—Ç –ª–∞–≤–∏–Ω–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞</div>
                    <div class="${avalancheEffect > 50 ? 'test-pass' : 'test-fail'}">${avalancheEffect > 50 ? '–ü–†–û–ô–î–ï–ù' : '–ù–ï –ü–†–û–ô–î–ï–ù'}</div>
                </div>
                <div class="test-item">
                    –ò–∑–º–µ–Ω–µ–Ω–æ –±–∞–π—Ç–æ–≤: ${diffCount} –∏–∑ ${originalEncrypted.length} (${avalancheEffect.toFixed(2)}%)
                </div>
            `;
        }
        
        // Simulate encryption for avalanche test
        function simulateEncryptionForAvalanche(data) {
            // This is a simplified simulation for demonstration
            const result = [];
            for (let i = 0; i < data.length; i++) {
                result.push((data[i] * 37 + i * 13) % 256);
            }
            return result;
        }
        
        // Run correlation test
        function runCorrelationTest() {
            alert('–ê–Ω–∞–ª–∏–∑ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è...');
            // In a real implementation, this would calculate correlation coefficients
        }
        
        // Visualize S-Box
        function visualizeSBox() {
            if (!homophonicSBox) {
                alert('S-Box –Ω–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω');
                return;
            }
            
            const visualization = document.getElementById('sboxVisualization');
            visualization.textContent = '';
            
            let content = '';
            for (let i = 0; i < 16; i++) {
                let line = i.toString(16).toUpperCase() + ': ';
                for (let j = 0; j < 16; j++) {
                    const byteVal = i * 16 + j;
                    if (homophonicSBox[byteVal] && homophonicSBox[byteVal].length > 0) {
                        line += homophonicSBox[byteVal][0].toString(16).toUpperCase().padStart(4, '0') + ' ';
                    } else {
                        line += '???? ';
                    }
                }
                content += line + '\n';
            }
            
            visualization.textContent = content;
        }
        
        // Visualize byte permutation
        function visualizeBytePermutation() {
            if (!bytePermutation) {
                alert('–ü–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–∞–π—Ç–æ–≤ –Ω–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–∞');
                return;
            }
            
            const visualization = document.getElementById('permutationVisualization');
            visualization.textContent = '';
            
            let content = '';
            for (let i = 0; i < 16; i++) {
                let line = i.toString(16).toUpperCase() + ': ';
                for (let j = 0; j < 16; j++) {
                    const idx = i * 16 + j;
                    line += bytePermutation[idx].toString(16).toUpperCase().padStart(2, '0') + ' ';
                }
                content += line + '\n';
            }
            
            visualization.textContent = content;
        }
        
        // Visualize diffusion
        function visualizeDiffusion() {
            alert('–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –¥–∏—Ñ—Ñ—É–∑–∏–∏ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è...');
            // In a real implementation, this would show how changes propagate
        }
        
        // Compare multiple encryptions
        function compareEncryptions() {
            if (multipleEncryptions.length === 0) {
                alert('–°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ multiple —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                return;
            }
            
            const comparisonResults = document.getElementById('comparisonResults');
            comparisonResults.innerHTML = '<h3>–°—Ä–∞–≤–Ω–µ–Ω–∏–µ —à–∏—Ñ—Ä–æ—Ç–µ–∫—Å—Ç–æ–≤</h3>';
            
            for (let i = 0; i < multipleEncryptions.length; i++) {
                const encryption = multipleEncryptions[i];
                const hex = bytesToHex(encryption);
                
                const encryptionDiv = document.createElement('div');
                encryptionDiv.className = 'output';
                encryptionDiv.innerHTML = `<strong>–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ #${i + 1}:</strong> ${hex}`;
                
                comparisonResults.appendChild(encryptionDiv);
            }
            
            // Calculate differences
            if (multipleEncryptions.length > 1) {
                const diffDiv = document.createElement('div');
                diffDiv.className = 'output';
                
                let diffText = '<strong>–†–∞–∑–ª–∏—á–∏—è –º–µ–∂–¥—É —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è–º–∏:</strong>\n';
                for (let i = 1; i < multipleEncryptions.length; i++) {
                    const diff = calculateDifference(multipleEncryptions[0], multipleEncryptions[i]);
                    diffText += `–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ 1 vs ${i + 1}: ${diff.toFixed(2)}% —Ä–∞–∑–Ω—ã—Ö –±–∞–π—Ç–æ–≤\n`;
                }
                
                diffDiv.textContent = diffText;
                comparisonResults.appendChild(diffDiv);
            }
        }
        
        // Calculate difference between two arrays
        function calculateDifference(arr1, arr2) {
            const minLength = Math.min(arr1.length, arr2.length);
            let diffCount = 0;
            
            for (let i = 0; i < minLength; i++) {
                if (arr1[i] !== arr2[i]) {
                    diffCount++;
                }
            }
            
            return (diffCount / minLength) * 100;
        }
        
        // Visualize avalanche effect
        function visualizeAvalanche() {
            alert('–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ª–∞–≤–∏–Ω–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞...');
            // In a real implementation, this would show a visualization
        }
        
        // Switch between tabs
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName).classList.add('active');
            
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            event.currentTarget.classList.add('active');
        }
        
        // Utility functions
        function copyToDecrypt(hexText) {
            document.getElementById('decryptInput').value = hexText;
        }
        
        function clearEncrypt() {
            document.getElementById('encryptInput').value = '';
            document.getElementById('encryptOutput').textContent = '–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –∑–¥–µ—Å—å';
        }
        
        function clearDecrypt() {
            document.getElementById('decryptInput').value = '';
            document.getElementById('decryptOutput').textContent = '–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –∑–¥–µ—Å—å';
        }
        
        // Initialize with some default data
        window.onload = function() {
            // Generate S-Box on load with default key
            setTimeout(() => {
                generateSBox();
            }, 500);
        };
    </script>
</body>
</html>
