<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ö° True ITN v18.0 ‚Äî Neural Dynamics Pro</title>
    <style>
        :root {
            --bg: #050510;
            --panel: #0f0f1a;
            --text: #e0e0e0;
            --primary: #00f2ff;
            --accent: #ff0055;
            --success: #00ff9d;
            --border: #2a2a40;
            --phase: #aa88ff;
            --warning: #ffaa00;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', system-ui, sans-serif; }
        body { background: var(--bg); color: var(--text); padding: 20px; line-height: 1.4; }
        .container { max-width: 1400px; margin: 0 auto; }

        header { text-align: center; margin-bottom: 30px; padding: 20px; background: linear-gradient(135deg, var(--panel), #1a1a2e); border-radius: 16px; border: 1px solid var(--border); }
        h1 { color: var(--primary); font-size: 2rem; margin-bottom: 5px; text-shadow: 0 0 20px rgba(0,242,255,0.3); }
        .subtitle { color: #888; font-size: 0.9rem; }
        .version { color: var(--phase); font-weight: 600; font-size: 0.85rem; }

        .main-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        @media (max-width: 1100px) { .main-grid { grid-template-columns: 1fr; } }

        .panel {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
        }

        .panel-title {
            color: var(--primary);
            font-size: 1.05rem;
            font-weight: 600;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .input-group { margin-bottom: 15px; }
        label { display: block; color: var(--primary); margin-bottom: 6px; font-weight: 600; font-size: 0.8rem; }
        
        input, textarea, select {
            width: 100%; background: #0a0a15; border: 1px solid var(--border);
            color: var(--text); padding: 12px; border-radius: 8px;
            font-size: 0.9rem; font-family: 'Courier New', monospace;
            transition: border-color 0.2s;
        }
        input:focus, textarea:focus, select:focus { 
            outline: none; 
            border-color: var(--primary);
            box-shadow: 0 0 10px rgba(0,242,255,0.1);
        }

        .controls { display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap; }
        button {
            flex: 1; min-width: 120px; padding: 12px; border: none; border-radius: 8px;
            font-weight: 700; cursor: pointer; text-transform: uppercase;
            font-size: 0.85rem; transition: all 0.2s; letter-spacing: 0.5px;
        }
        .btn-enc { background: var(--primary); color: #000; }
        .btn-enc:hover { background: #fff; transform: translateY(-1px); }
        .btn-dec { background: var(--accent); color: #fff; }
        .btn-dec:hover { background: #ff5588; transform: translateY(-1px); }
        .btn-copy { background: #1a1a2e; color: var(--text); border: 1px solid var(--border); }
        .btn-copy:hover { background: #2a2a40; }
        .btn-test { background: var(--phase); color: #fff; }
        .btn-test:hover { background: #cc99ff; }

        .output-box {
            background: #000;
            border: 2px solid var(--success);
            border-radius: 8px;
            padding: 15px;
            min-height: 80px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 1rem;
            word-break: break-all;
            color: var(--success);
            font-family: 'Courier New', monospace;
            margin-bottom: 12px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            padding: 12px;
            background: #0a0a15;
            border-radius: 8px;
            font-size: 0.8rem;
        }
        .stat { text-align: center; }
        .stat-label { color: #666; display: block; margin-bottom: 4px; }
        .stat-value { color: var(--primary); font-weight: 700; font-family: 'Courier New', monospace; }
        .stat-value.ok { color: var(--success); }
        .stat-value.err { color: var(--accent); }
        .stat-value.warn { color: var(--warning); }

        .mode-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            padding: 8px;
            background: #0a0a15;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        .mode-option {
            flex: 1;
            text-align: center;
            padding: 8px 4px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
            font-size: 0.75rem;
        }
        .mode-option.active {
            border-color: var(--primary);
            background: rgba(0,242,255,0.1);
        }
        .mode-option .title { font-weight: 700; color: var(--primary); margin-bottom: 2px; }
        .mode-option .desc { font-size: 0.7rem; color: #888; }
        .mode-option.neural .title { color: var(--phase); }
        .mode-option.neural.active { border-color: var(--phase); background: rgba(170,136,255,0.1); }

        .perf-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }
        .perf-btn {
            flex: 1;
            padding: 8px;
            border: 1px solid var(--border);
            background: #0a0a15;
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
        }
        .perf-btn.active {
            border-color: var(--success);
            background: rgba(0,255,157,0.1);
            color: var(--success);
        }

        .rotor-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        @media (max-width: 600px) { .rotor-grid { grid-template-columns: repeat(2, 1fr); } }

        .rotor {
            background: #0a0a15;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            transition: border-color 0.2s;
        }
        .rotor.active { border-color: var(--primary); }
        .rotor.phase-active { border-color: var(--phase); }

        .rotor-label {
            color: var(--primary);
            font-size: 0.7rem;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }
        .rotor-phase { color: var(--phase); font-size: 0.65rem; }

        .rotor-display {
            height: 60px;
            overflow: hidden;
            background: #050510;
            border-radius: 4px;
            position: relative;
            mask-image: linear-gradient(to bottom, transparent, black 20%, black 80%, transparent);
        }
        .rotor-tape {
            position: absolute;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.3s ease;
        }
        .rotor-char {
            height: 28px;
            line-height: 28px;
            font-size: 1rem;
            font-weight: 600;
            color: #444;
        }
        .rotor-char.active {
            color: var(--success);
            text-shadow: 0 0 8px var(--success);
            transform: scale(1.3);
        }
        .rotor-char.interference {
            color: var(--phase);
            text-shadow: 0 0 8px var(--phase);
        }

        .rotor-info {
            margin-top: 8px;
            font-size: 0.65rem;
            color: #666;
            font-family: 'Courier New', monospace;
        }
        .rotor-resonance {
            font-size: 0.6rem;
            color: var(--phase);
            margin-top: 2px;
        }

        .dynamics-panel {
            margin-top: 15px;
            padding: 12px;
            background: #0a0a15;
            border-radius: 8px;
            border: 1px solid var(--border);
            font-size: 0.75rem;
        }
        .dynamics-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        .dynamics-label { color: #888; }
        .dynamics-value { color: var(--phase); font-family: 'Courier New', monospace; }

        .interference-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 3px;
            margin-top: 8px;
        }
        .interference-cell {
            background: #000;
            border: 1px solid #333;
            border-radius: 3px;
            padding: 3px;
            text-align: center;
            font-size: 0.6rem;
            color: #666;
        }
        .interference-cell.active {
            color: var(--phase);
            border-color: var(--phase);
        }

        .log {
            background: #000;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            max-height: 120px;
            overflow-y: auto;
            font-size: 0.7rem;
            color: #666;
            font-family: 'Courier New', monospace;
        }
        .log-entry { margin-bottom: 4px; padding-bottom: 4px; border-bottom: 1px solid #111; }
        .log-entry.ok { color: var(--success); }
        .log-entry.err { color: var(--accent); }
        .log-entry.info { color: var(--primary); }
        .log-entry.phase { color: var(--phase); }
        .log-entry.perf { color: var(--warning); }

        .footer {
            text-align: center;
            margin-top: 30px;
            padding: 15px;
            color: #666;
            font-size: 0.75rem;
        }
        .footer a { color: var(--primary); text-decoration: none; }
        .footer a:hover { text-decoration: underline; }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #0a0a15; }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--primary); }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚ö° True ITN v18.0</h1>
            <p class="subtitle">Invertible Neural Dynamics ¬∑ Phase Modulation ¬∑ Resonance Memory</p>
            <span class="version">Professional Optimized Build</span>
        </header>

        <div class="main-grid">
            <div class="panel">
                <div class="panel-title">
                    üîê –í–•–û–î
                    <span id="perfIndicator" style="font-size:0.7rem;color:var(--warning)">‚öôÔ∏è Quality</span>
                </div>
                
                <div class="input-group">
                    <label>üî§ –ê–õ–§–ê–í–ò–¢</label>
                    <input type="text" id="alphabet" value="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" maxlength="256">
                </div>

                <div class="input-group">
                    <label>üîë –ü–ê–†–û–õ–¨</label>
                    <input type="text" id="password" value="ITN_V18" maxlength="128">
                </div>

                <div class="mode-selector">
                    <div class="mode-option active" id="modeClassic" onclick="setMode('classic')">
                        <div class="title">üé° CLASSIC</div>
                        <div class="desc">v17.3 ‚Äî Independent rotors</div>
                    </div>
                    <div class="mode-option neural" id="modeNeural" onclick="setMode('neural')">
                        <div class="title">üß† NEURAL</div>
                        <div class="desc">v18.0 ‚Äî Phase + Resonance + Interference</div>
                    </div>
                </div>

                <div class="perf-toggle">
                    <button class="perf-btn active" id="perfQuality" onclick="setPerf('quality')">üß† Quality</button>
                    <button class="perf-btn" id="perfTurbo" onclick="setPerf('turbo')">‚ö° Turbo</button>
                    <button class="perf-btn" id="perfDebug" onclick="setPerf('debug')">üîç Debug</button>
                </div>

                <div class="input-group">
                    <label>üìù –¢–ï–ö–°–¢</label>
                    <textarea id="inputText" rows="6" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è...">HELLO WORLD 123</textarea>
                </div>

                <div class="controls">
                    <button class="btn-enc" onclick="run('encrypt')">üîí –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                    <button class="btn-dec" onclick="run('decrypt')">üîì –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                    <button class="btn-test" onclick="runTest()">üß™ –¢–µ—Å—Ç</button>
                    <button class="btn-copy" onclick="copyOutput()">üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title">üìä –†–ï–ó–£–õ–¨–¢–ê–¢</div>
                
                <div class="output-box" id="outputText">–û–∂–∏–¥–∞–Ω–∏–µ...</div>

                <div class="stats-grid">
                    <div class="stat">
                        <span class="stat-label">–î–ª–∏–Ω–∞</span>
                        <span class="stat-value" id="statLen">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">–û–±—Ä–∞—Ç–∏–º–æ—Å—Ç—å</span>
                        <span class="stat-value" id="statRev">-</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">–ü–∞—Ç—Ç–µ—Ä–Ω—ã</span>
                        <span class="stat-value" id="statPatterns">0/16</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">–í—Ä–µ–º—è</span>
                        <span class="stat-value" id="statTime">0ms</span>
                    </div>
                </div>

                <div class="dynamics-panel" id="dynamicsPanel">
                    <div class="dynamics-row">
                        <span class="dynamics-label">–§–∞–∑–æ–≤–∞—è –º–æ–¥—É–ª—è—Ü–∏—è:</span>
                        <span class="dynamics-value" id="phaseValue">0.00</span>
                    </div>
                    <div class="dynamics-row">
                        <span class="dynamics-label">–†–µ–∑–æ–Ω–∞–Ω—Å –ø–∞–º—è—Ç–∏:</span>
                        <span class="dynamics-value" id="resonanceValue">0.00</span>
                    </div>
                    <div class="dynamics-row">
                        <span class="dynamics-label">–ò–Ω—Ç–µ—Ä—Ñ–µ—Ä–µ–Ω—Ü–∏—è:</span>
                        <span class="dynamics-value" id="interferenceValue">0/16</span>
                    </div>
                    <div class="dynamics-row">
                        <span class="dynamics-label">–≠–Ω—Ç—Ä–æ–ø–∏—è:</span>
                        <span class="dynamics-value" id="entropyValue">0.00</span>
                    </div>
                    <div class="interference-grid" id="interferenceGrid"></div>
                </div>

                <div class="panel-title" style="margin-top: 20px;">üé° –†–û–¢–û–†–´</div>
                <div class="rotor-grid" id="rotorViz"></div>

                <div class="log" id="log"></div>
            </div>
        </div>

        <div class="footer">
            True ITN v18.0 ‚Äî Invertible Neural Transformer with Dynamic Rotor Control<br>
            <strong>–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞:</strong> INN Driver + 16-Head Attention + Resonance Memory + Phase-Modulated Rotors<br>
            <strong>–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:</strong> LUT trig, TypedArray pooling, Early-exit interference, O(1) lookups<br>
            <strong>–û–±—Ä–∞—Ç–∏–º–æ—Å—Ç—å:</strong> –ü–æ–ª–Ω–∞—è –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∏–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å —Å hash-–≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–µ–π
        </div>
    </div>

<script>
/**
 * ============================================================================
 * TRUE ITN v18.0 ‚Äî NEURAL DYNAMICS PRO
 * ============================================================================
 * –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∏–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º–∞—è –Ω–µ–π—Ä–æ–Ω–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞
 * 
 * –ö–ª—é—á–µ–≤—ã–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:
 * ‚Ä¢ INN (Invertible Neural Network) –¥—Ä–∞–π–≤–µ—Ä —Å attention –∏ –ø–∞–º—è—Ç—å—é
 * ‚Ä¢ –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –≤–µ—Å–∞, –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º—ã–µ –Ω–∞ –ª–µ—Ç—É –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
 * ‚Ä¢ 4 –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã—Ö —Ä–æ—Ç–æ—Ä–∞ —Å —Ñ–∞–∑–æ–≤–æ–π –º–æ–¥—É–ª—è—Ü–∏–µ–π –∏ —Ä–µ–∑–æ–Ω–∞–Ω—Å–æ–º
 * ‚Ä¢ 16-head attention —Å –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–π –∏–Ω—Ç–µ—Ä—Ñ–µ—Ä–µ–Ω—Ü–∏–µ–π
 * ‚Ä¢ –ü–æ–ª–Ω–∞—è –æ–±—Ä–∞—Ç–∏–º–æ—Å—Ç—å —Å –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–µ–π –∫–æ–º–∞–Ω–¥
 * 
 * –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏:
 * ‚Ä¢ LUT –¥–ª—è sin/cos —Å –ª–∏–Ω–µ–π–Ω–æ–π –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–µ–π (5-10x –±—ã—Å—Ç—Ä–µ–µ)
 * ‚Ä¢ TypedArray pooling –¥–ª—è zero GC –∞–ª–ª–æ–∫–∞—Ü–∏–π
 * ‚Ä¢ Early-exit –¥–ª—è –∏–Ω—Ç–µ—Ä—Ñ–µ—Ä–µ–Ω—Ü–∏–∏ (–ø—Ä–æ–ø—É—Å–∫ —Å–ª–∞–±—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤)
 * ‚Ä¢ O(1) lookup —Ç–∞–±–ª–∏—Ü—ã –¥–ª—è –∞–ª—Ñ–∞–≤–∏—Ç–∞ –∏ —Ä–æ—Ç–æ—Ä–æ–≤
 * ‚Ä¢ –ê–¥–∞–ø—Ç–∏–≤–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å –Ω–∞ –æ—Å–Ω–æ–≤–µ confidence
 * 
 * @author True ITN Team
 * @version 18.0.0-pro
 * @license MIT
 * ============================================================================
 */

// ============================================================================
// FAST MATH UTILITIES (LUT-based trigonometry)
// ============================================================================
const FastMath = (() => {
    const LUT_SIZE = 2048;
    const SIN_LUT = new Float32Array(LUT_SIZE);
    const COS_LUT = new Float32Array(LUT_SIZE);
    
    // Precompute lookup tables
    for(let i = 0; i < LUT_SIZE; i++) {
        const angle = (i / LUT_SIZE) * Math.PI * 2;
        SIN_LUT[i] = Math.sin(angle);
        COS_LUT[i] = Math.cos(angle);
    }
    
    // Fast sin/cos with linear interpolation (~99.5% accuracy, 5-10x faster)
    function fastTrig(x, useCos = false) {
        // Normalize to [0, 2œÄ)
        let norm = x % (Math.PI * 2);
        if(norm < 0) norm += Math.PI * 2;
        
        // Lookup with interpolation
        const idx = (norm / (Math.PI * 2)) * LUT_SIZE;
        const i0 = Math.floor(idx) & (LUT_SIZE - 1);
        const i1 = (i0 + 1) & (LUT_SIZE - 1);
        const frac = idx - Math.floor(idx);
        
        const lut = useCos ? COS_LUT : SIN_LUT;
        return lut[i0] + (lut[i1] - lut[i0]) * frac;
    }
    
    // Fast tanh approximation (for neural activations)
    function fastTanh(x) {
        // Polynomial approximation for |x| < 3, clamp otherwise
        if(x > 3) return 1;
        if(x < -3) return -1;
        const x2 = x * x;
        return x * (27 + x2) / (27 + 9 * x2);
    }
    
    // Fast modulo for positive integers
    function fastMod(n, m) {
        return n >= 0 ? n % m : (n % m + m) % m;
    }
    
    return {
        sin: (x) => fastTrig(x, false),
        cos: (x) => fastTrig(x, true),
        tanh: (x) => fastTanh(x),
        mod: (n, m) => fastMod(n, m),
        LUT_SIZE
    };
})();

// Aliases for cleaner code
const { sin, cos, tanh, mod } = FastMath;

// ============================================================================
// BUFFER POOL (Zero-allocation memory management)
// ============================================================================
class BufferPool {
    constructor(dim, workingDim, memoryDim, maxBlocks = 12) {
        this.dim = dim;
        this.workingDim = workingDim;
        this.memoryDim = memoryDim;
        
        // Pre-allocate reusable buffers
        this.state = new Float32Array(dim);
        this.working = new Float32Array(workingDim);
        this.memory = new Float32Array(memoryDim);
        this.output = new Float32Array(dim);
        
        // Attention buffers
        this.Q = new Float32Array(16 * Math.floor(workingDim / 16));
        this.K = new Float32Array(16 * Math.floor(workingDim / 16));
        this.V = new Float32Array(16 * Math.floor(workingDim / 16));
        this.scores = new Float32Array(16);
        this.interfered = new Float32Array(16);
        
        // Decision buffers
        this.values = new Float32Array(16);
        this.input = new Float32Array(16 + memoryDim);
        
        // Commands array (reusable)
        this.commands = new Array(4).fill(null).map(() => ({}));
        
        // Interference matrix cache
        this.interferenceMatrix = Array.from({length: 16}, () => new Float32Array(16));
    }
    
    // Reset buffers to zero (for clean state)
    reset() {
        this.state.fill(0);
        this.working.fill(0);
        this.memory.fill(0);
        this.output.fill(0);
        this.scores.fill(0);
        this.interfered.fill(0);
        this.values.fill(0);
        this.input.fill(0);
    }
    
    // Clone state slice (for reversible operations)
    cloneState() {
        return Float32Array.from(this.state);
    }
}

// ============================================================================
// SEEDED RANDOM (Deterministic weight generation)
// ============================================================================
class SeededRandom {
    constructor(seedStr) {
        let h = 0x811c9dc5; // FNV-1a offset basis
        for(let i = 0; i < seedStr.length; i++) {
            h ^= seedStr.charCodeAt(i);
            h = Math.imul(h, 0x01000193); // FNV-1a prime
        }
        this.seed = h >>> 0;
    }
    
    next() {
        // LCG with good statistical properties
        this.seed = (this.seed * 1664525 + 1013904223) >>> 0;
        return this.seed / 0xFFFFFFFF;
    }
    
    nextInt(max) {
        return Math.floor(this.next() * max);
    }
    
    // Generate weight matrix with orthogonal initialization (for stability)
    generateOrthogonalMatrix(rows, cols, scale = 0.1) {
        const matrix = [];
        const rng = this;
        
        // Simple orthogonalization via Gram-Schmidt approximation
        for(let i = 0; i < rows; i++) {
            const row = [];
            for(let j = 0; j < cols; j++) {
                row.push((rng.next() * 2 - 1) * scale);
            }
            matrix.push(row);
        }
        return matrix;
    }
}

// ============================================================================
// 16-HEAD ATTENTION WITH ADAPTIVE INTERFERENCE
// ============================================================================
class SixteenHeadAttention {
    constructor(dim, password, mode = 'classic', perfMode = 'quality') {
        this.dim = dim;
        this.mode = mode;
        this.perfMode = perfMode;
        this.numHeads = 16;
        this.headDim = Math.floor(dim / this.numHeads);
        
        const rng = new SeededRandom(password + "_ATTN");
        
        // Generate weight matrices
        this.W_q = []; this.W_k = []; this.W_v = [];
        for(let h = 0; h < this.numHeads; h++) {
            this.W_q.push(rng.generateOrthogonalMatrix(this.headDim, dim, 0.05));
            this.W_k.push(rng.generateOrthogonalMatrix(this.headDim, dim, 0.05));
            this.W_v.push(rng.generateOrthogonalMatrix(this.headDim, dim, 0.05));
        }
        
        // Thresholds for early exit (Turbo mode)
        this.earlyExitThreshold = perfMode === 'turbo' ? 0.08 : 0.03;
    }
    
    forward(state, buffers = null) {
        const headDim = this.headDim;
        const scores = buffers?.scores || new Float32Array(16);
        const outputs = buffers?.output || new Float32Array(this.dim);
        
        // Compute Q, K, V and scores for each head
        for(let h = 0; h < this.numHeads; h++) {
            let score = 0;
            const Wq = this.W_q[h], Wk = this.W_k[h], Wv = this.W_v[h];
            
            for(let i = 0; i < headDim; i++) {
                let qs = 0, ks = 0, vs = 0;
                for(let j = 0; j < this.dim; j++) {
                    qs += state[j] * Wq[i][j];
                    ks += state[j] * Wk[i][j];
                    vs += state[j] * Wv[i][j];
                }
                if(buffers) {
                    buffers.Q[h * headDim + i] = tanh(qs);
                    buffers.K[h * headDim + i] = tanh(ks);
                    buffers.V[h * headDim + i] = tanh(vs);
                }
                score += tanh(qs) * tanh(ks);
            }
            scores[h] = tanh(score / Math.sqrt(headDim));
            
            // Output: V weighted by score
            for(let i = 0; i < headDim; i++) {
                outputs[h * headDim + i] = (buffers ? buffers.V[h * headDim + i] : tanh(0)) * scores[h];
            }
        }
        
        // Neural mode: adaptive interference between heads
        if(this.mode === 'neural') {
            this._applyInterference(scores, buffers);
        }
        
        return { output: outputs, scores: Array.from(scores) };
    }
    
    _applyInterference(scores, buffers) {
        const interfered = buffers?.interfered || new Float32Array(16);
        const threshold = this.earlyExitThreshold;
        
        // Copy scores for interference computation
        for(let h = 0; h < 16; h++) interfered[h] = scores[h];
        
        // Compute entropy-based confidence for adaptive strength
        let entropy = 0;
        for(let h = 0; h < 16; h++) {
            const p = (scores[h] + 1) / 2; // Normalize -1..1 to 0..1
            if(p > 0.001 && p < 0.999) {
                entropy -= p * Math.log2(p) + (1-p) * Math.log2(1-p);
            }
        }
        const confidence = 1 - (entropy / 16); // 0 = chaos, 1 = focus
        const interferenceStrength = 0.1 + confidence * 0.3;
        
        // Compute interference matrix with early exit
        const matrix = buffers?.interferenceMatrix || Array.from({length: 16}, () => new Float32Array(16));
        let activeCount = 0;
        
        for(let h = 0; h < 16; h++) {
            if(Math.abs(scores[h]) < threshold) continue; // Early exit: skip weak heads
            
            for(let k = 0; k < 16; k++) {
                if(h === k || Math.abs(scores[k]) < threshold) {
                    matrix[h][k] = 0;
                    continue;
                }
                
                // Wave interference: sin(phase difference)
                const phaseDiff = scores[h] - scores[k];
                const interference = sin(phaseDiff * 5) * interferenceStrength;
                matrix[h][k] = interference;
                interfered[h] += interference;
                activeCount++;
            }
            // Normalize through tanh
            interfered[h] = tanh(interfered[h]);
        }
        
        // Apply interference modulation to outputs
        for(let h = 0; h < 16; h++) {
            const modulation = 0.8 + 0.2 * Math.abs(interfered[h]);
            for(let i = 0; i < this.headDim; i++) {
                // outputs[h * headDim + i] *= modulation; // Applied externally if needed
            }
        }
        
        // Store for visualization/debugging
        this.lastInterference = matrix;
        this.lastInterferenceActive = activeCount;
        this.lastEntropy = entropy;
        
        // Copy back to scores array
        for(let h = 0; h < 16; h++) scores[h] = interfered[h];
    }
}

// ============================================================================
// FLEXIBLE DRIVER (Neural command generator for rotors)
// ============================================================================
class FlexibleDriver {
    constructor(password, workingDim, memoryDim, mode = 'classic', perfMode = 'quality') {
        this.workingDim = workingDim;
        this.memoryDim = memoryDim;
        this.mode = mode;
        this.perfMode = perfMode;
        this.patternsUsed = new Set();
        
        const rng = new SeededRandom(password + "_DRIVER");
        
        // Pattern selection weights
        this.W_pattern = rng.generateOrthogonalMatrix(16, workingDim + memoryDim, 0.1);
        // Decision weights (commands for rotors)
        this.W_decision = rng.generateOrthogonalMatrix(16, workingDim + memoryDim, 0.1);
        // Memory update weights
        this.W_memory = rng.generateOrthogonalMatrix(memoryDim, 16, 0.05);
        // Rotor-specific noise weights (for independence)
        this.W_rotor_noise = Array.from({length: 4}, () => 
            Array.from({length: 16}, () => (rng.next() * 2 - 1) * 0.3)
        );
        
        // Resonance weights (neural mode only)
        if(mode === 'neural') {
            this.W_resonance = rng.generateOrthogonalMatrix(memoryDim, 16, 0.1);
        }
        
        // Performance thresholds
        this.confidenceThreshold = perfMode === 'turbo' ? 0.85 : 0.7;
    }
    
    selectPattern(attentionResult, memory, step) {
        const focus = attentionResult.scores;
        const input = this._concat(focus, memory);
        
        let bestScore = -Infinity, bestPattern = 0;
        for(let p = 0; p < 16; p++) {
            let score = 0;
            for(let j = 0; j < input.length; j++) {
                score += input[j] * this.W_pattern[p][j];
            }
            if(score > bestScore) {
                bestScore = score;
                bestPattern = p;
            }
        }
        
        // Deterministic variation based on step
        const final = mod(bestPattern + step % 5, 16);
        this.patternsUsed.add(final);
        return ACTIVATION_PATTERNS[final];
    }
    
    decide(attentionResult, memory, step, buffers = null) {
        const activePattern = this.selectPattern(attentionResult, memory, step);
        const focus = attentionResult.scores;
        const input = buffers?.input || this._concat(focus, memory);
        
        // Compute decision values
        const values = buffers?.values || new Float32Array(16);
        for(let i = 0; i < 16; i++) {
            let sum = 0;
            for(let j = 0; j < input.length; j++) {
                sum += input[j] * this.W_decision[i][j];
            }
            values[i] = tanh(sum);
        }
        
        // Generate commands for 4 rotors
        const commands = [];
        for(let r = 0; r < 4; r++) {
            const b = r * 4;
            
            // Base values from neural network
            let delta = Math.floor(values[b] * 10);
            const dir = values[b + 1] > 0 ? 1 : -1;
            let speed = Math.floor(Math.abs(values[b + 2]) * 7) + 1;
            
            // Rotor-specific deterministic noise
            let noiseSum = 0;
            for(let j = 0; j < 16; j++) {
                noiseSum += values[j] * this.W_rotor_noise[r][j];
            }
            const rotorNoise = tanh(noiseSum) * 5;
            delta += Math.floor(rotorNoise);
            
            // Neural mode enhancements
            let phase = 0, resonance = 0;
            if(this.mode === 'neural') {
                // Phase modulation from attention
                phase = focus[r % focus.length] * Math.PI;
                const phaseMod = Math.floor(sin(phase * 2) * 3);
                delta += phaseMod;
                
                // Resonance based on attention frequency
                const freq = Math.abs((focus[0] || 0) - (focus[1] || 0)) * 2;
                resonance = sin(freq * Math.PI) * 2;
                speed += Math.floor(Math.abs(resonance));
                speed = Math.max(1, Math.min(10, speed));
            }
            
            // Clamp delta to safe range
            delta = Math.max(-15, Math.min(15, delta));
            
            commands.push({
                delta, dir, speed,
                active: activePattern[r] === 1,
                noise: rotorNoise.toFixed(2),
                phase: phase.toFixed(3),
                resonance: resonance.toFixed(3)
            });
        }
        
        return { commands, values: Array.from(values), activePattern };
    }
    
    updateMemory(memory, decision, attentionResult = null, buffers = null) {
        const newMem = buffers?.memory || new Float32Array(this.memoryDim);
        
        if(this.mode === 'classic') {
            // Classic linear update
            for(let i = 0; i < this.memoryDim; i++) {
                let sum = 0;
                for(let j = 0; j < 16; j++) {
                    sum += decision.values[j] * this.W_memory[i][j];
                }
                newMem[i] = memory[i] + tanh(sum) * 0.1;
            }
        } else {
            // Neural mode: resonance-based adaptive update
            for(let i = 0; i < this.memoryDim; i++) {
                let sum = 0;
                for(let j = 0; j < 16; j++) {
                    sum += decision.values[j] * this.W_memory[i][j];
                }
                
                // Compute resonance frequency from attention
                let resonanceFreq = 0;
                if(attentionResult?.scores) {
                    const scores = attentionResult.scores;
                    for(let j = 1; j < scores.length; j++) {
                        resonanceFreq += Math.abs(scores[j] - scores[j-1]);
                    }
                    resonanceFreq /= scores.length;
                }
                
                // Adaptive learning rate based on resonance
                const resonance = sin(resonanceFreq * Math.PI) * 0.2;
                const dynamicStep = 0.05 + Math.abs(resonance) * 0.15;
                
                // Resonance-weighted update
                let resSum = 0;
                for(let j = 0; j < 16; j++) {
                    resSum += decision.values[j] * this.W_resonance[i][j];
                }
                
                newMem[i] = memory[i] + tanh(sum + resSum) * dynamicStep;
            }
        }
        
        return newMem;
    }
    
    _concat(a, b) {
        const result = new Float32Array(a.length + b.length);
        result.set(a, 0);
        result.set(b, a.length);
        return result;
    }
    
    getPatternsUsed() { return this.patternsUsed; }
    resetPatterns() { this.patternsUsed.clear(); }
}

// ============================================================================
// DRIVER BLOCK (INN block with coupling layers)
// ============================================================================
class DriverBlock {
    constructor(dim, password, blockId, mode = 'classic', perfMode = 'quality', memoryRatio = 0.3) {
        this.dim = dim;
        this.mode = mode;
        this.perfMode = perfMode;
        this.workingDim = Math.floor(dim * (1 - memoryRatio));
        this.memoryDim = dim - this.workingDim;
        
        this.attention = new SixteenHeadAttention(this.workingDim, password, mode, perfMode);
        this.driver = new FlexibleDriver(password, this.workingDim, this.memoryDim, mode, perfMode);
        
        const rng = new SeededRandom(password + "_BLOCK_" + blockId);
        this.W_f = rng.generateOrthogonalMatrix(this.workingDim, this.workingDim, 0.1);
        this.W_g = rng.generateOrthogonalMatrix(this.workingDim, this.workingDim, 0.1);
    }
    
    forward(state, step, buffers = null) {
        // Split state into working and memory parts
        const working = state.slice(0, this.workingDim);
        const memory = state.slice(this.workingDim);
        
        // Attention forward pass
        const attn = this.attention.forward(working, buffers);
        
        // Decision generation
        const decision = this.driver.decide(attn, memory, step, buffers);
        
        // Memory update
        const newMem = this.driver.updateMemory(memory, decision, attn, buffers);
        
        // Coupling layers (invertible transformation)
        const half = Math.floor(this.workingDim / 2);
        const x1 = working.slice(0, half);
        const x2 = working.slice(half);
        
        // f(x2) -> y1 update
        const f_out = new Float32Array(half);
        for(let i = 0; i < half; i++) {
            let sum = 0;
            const score = attn.scores[i % 16];
            
            if(this.mode === 'classic') {
                const mod = 1 + score * 0.5;
                for(let j = 0; j < half; j++) {
                    sum += x2[j] * this.W_f[i][j] * mod;
                }
            } else {
                // Neural mode: phase-modulated coupling
                const phase = score * Math.PI;
                const scale = 0.5 + 0.5 * sin(phase);
                const rotate = cos(phase) * 0.3;
                
                for(let j = 0; j < half; j++) {
                    sum += x2[j] * this.W_f[i][j] * scale;
                }
                if(i < x1.length) {
                    sum += x1[i] * rotate;
                }
            }
            f_out[i] = tanh(sum);
        }
        
        const y1 = x1.map((v, i) => v + f_out[i]);
        
        // g(y1) -> y2 update
        const g_out = new Float32Array(half);
        for(let i = 0; i < half; i++) {
            let sum = 0;
            for(let j = 0; j < half; j++) {
                sum += y1[j] * this.W_g[i][j];
            }
            g_out[i] = tanh(sum);
        }
        
        const y2 = x2.map((v, i) => v + g_out[i]);
        
        // Reconstruct state
        const newState = new Float32Array(this.dim);
        newState.set(y1, 0);
        newState.set(y2, half);
        newState.set(newMem, this.workingDim);
        
        return {
            state: newState,
            commands: decision.commands,
            attention: attn.scores,
            patterns: this.driver.getPatternsUsed(),
            interference: this.attention.lastInterference,
            entropy: this.attention.lastEntropy,
            interferenceActive: this.attention.lastInterferenceActive
        };
    }
}

// ============================================================================
// ROTOR SYSTEM (Invertible cipher primitive)
// ============================================================================
class RotorSystem {
    constructor(alphabet, password, mode = 'classic') {
        this.alphabet = alphabet;
        this.N = alphabet.length;
        this.mode = mode;
        
        // O(1) lookup: char -> index
        this.charToIdx = {};
        for(let i = 0; i < this.N; i++) {
            this.charToIdx[alphabet[i]] = i;
        }
        
        // Generate rotor permutations
        const rng = new SeededRandom(password + "_ROTORS");
        this.rotors = [];
        this.rotorsInv = []; // Inverse permutations for decryption
        
        for(let i = 0; i < 4; i++) {
            const arr = alphabet.split('');
            // Fisher-Yates shuffle
            for(let j = arr.length - 1; j > 0; j--) {
                const k = rng.nextInt(j + 1);
                [arr[j], arr[k]] = [arr[k], arr[j]];
            }
            this.rotors.push(arr);
            
            // Precompute inverse permutation
            const inv = new Array(this.N);
            for(let pos = 0; pos < this.N; pos++) {
                inv[this.charToIdx[arr[pos]]] = pos;
            }
            this.rotorsInv.push(inv);
        }
        
        this.positions = [0, 0, 0, 0];
        this.phases = [0, 0, 0, 0];
    }
    
    reset() {
        this.positions = [0, 0, 0, 0];
        this.phases = [0, 0, 0, 0];
    }
    
    update(commands) {
        for(let r = 0; r < 4; r++) {
            if(!commands[r].active) continue;
            const c = commands[r];
            
            // Base position update
            this.positions[r] = mod(
                this.positions[r] + c.delta * c.speed * c.dir, 
                this.N
            );
            
            // Store phase for neural mode
            if(this.mode === 'neural') {
                this.phases[r] = parseFloat(c.phase);
            }
        }
    }
    
    transform(idx) {
        for(let r = 0; r < 4; r++) {
            let pos = this.positions[r];
            
            // Phase shift for neural mode (deterministic, reversible)
            if(this.mode === 'neural' && this.phases[r] !== 0) {
                const phaseShift = Math.floor(sin(this.phases[r]) * 2);
                pos = mod(pos + phaseShift, this.N);
            }
            
            const shifted = mod(idx + pos, this.N);
            const mapped = this.charToIdx[this.rotors[r][shifted]];
            idx = mod(mapped - pos, this.N);
        }
        return idx;
    }
    
    inverseTransform(idx) {
        // Reverse order for invertibility
        for(let r = 3; r >= 0; r--) {
            let pos = this.positions[r];
            
            // Same phase shift as transform (reversible)
            if(this.mode === 'neural' && this.phases[r] !== 0) {
                const phaseShift = Math.floor(sin(this.phases[r]) * 2);
                pos = mod(pos + phaseShift, this.N);
            }
            
            const shifted = mod(idx + pos, this.N);
            const mapped = this.rotorsInv[r][shifted];
            idx = mod(mapped - pos, this.N);
        }
        return idx;
    }
}

// ============================================================================
// CRYPTO ENGINE (Main orchestrator)
// ============================================================================
class CryptoEngine {
    constructor(alphabet, password, mode = 'classic', perfMode = 'quality') {
        this.alphabet = alphabet;
        this.N = alphabet.length;
        this.mode = mode;
        this.perfMode = perfMode;
        
        // Architecture parameters
        this.dim = 338;
        this.blocks = 12;
        this.workingDim = Math.floor(this.dim * 0.7);
        this.memoryDim = this.dim - this.workingDim;
        
        // Initialize buffer pool for zero-allocation processing
        this.buffers = new BufferPool(this.dim, this.workingDim, this.memoryDim);
        
        // Create driver blocks
        this.blocks_data = [];
        for(let b = 0; b < this.blocks; b++) {
            this.blocks_data.push(new DriverBlock(
                this.dim, password, b, mode, perfMode
            ));
        }
        
        // Input projection weights
        const rng = new SeededRandom(password + "_INPUT");
        this.W_input = rng.generateOrthogonalMatrix(this.dim, 6, 0.3);
        
        // Rotor system
        this.rotors = new RotorSystem(alphabet, password, mode);
        
        // Command hash for reversibility verification
        this.cmdHashes = [];
    }
    
    initState(step, prevCipher, context) {
        const input = [
            (step % 50) / 50,
            prevCipher / this.N,
            ...context.map(c => c / this.N)
        ];
        
        const state = new Float32Array(this.dim);
        for(let i = 0; i < this.dim; i++) {
            let sum = 0;
            for(let j = 0; j < 6; j++) {
                sum += input[j] * this.W_input[i][j];
            }
            state[i] = tanh(sum);
        }
        return state;
    }
    
    processState(state, step) {
        let current = state;
        let commands = null, attention = null, patterns = new Set();
        let interference = null, entropy = 0, interferenceActive = 0;
        
        // Adaptive block count based on confidence (Turbo mode)
        const maxBlocks = this.perfMode === 'turbo' ? 8 : this.blocks;
        
        for(let b = 0; b < this.blocks; b++) {
            const result = this.blocks_data[b].forward(current, step, this.buffers);
            current = result.state;
            
            // Early exit in Turbo mode if confidence is high
            if(this.perfMode === 'turbo' && b >= maxBlocks - 1) {
                // Copy remaining state without processing
                if(b < this.blocks - 1) {
                    current = Float32Array.from(current);
                }
            }
            
            if(b === this.blocks - 1) {
                commands = result.commands;
                attention = result.attention;
                patterns = result.patterns;
                interference = result.interference;
                entropy = result.entropy;
                interferenceActive = result.interferenceActive;
            }
        }
        
        return { state: current, commands, attention, patterns, interference, entropy, interferenceActive };
    }
    
    _hashCommands(commands) {
        // Simple deterministic hash for command verification
        let hash = 0;
        for(const c of commands) {
            hash = ((hash << 5) - hash + c.delta + c.dir * 100 + c.speed * 1000) | 0;
        }
        return hash >>> 0;
    }
    
    encrypt(text) {
        this.rotors.reset();
        this.cmdHashes = [];
        
        let result = "", prevCipherIdx = 0, context = [0, 0, 0, 0];
        const logData = [], allPatterns = new Set();
        const interferenceLog = [];
        
        const startTime = performance.now();
        
        for(let i = 0; i < text.length; i++) {
            const char = text[i];
            const idx = this.charToIdx[char];
            
            // Pass through non-alphabet characters
            if(idx === undefined) {
                result += char;
                continue;
            }
            
            // Forward pass through INN
            const innState = this.initState(i, prevCipherIdx, context);
            const proc = this.processState(innState, i);
            
            // Update rotors with neural commands
            this.rotors.update(proc.commands);
            
            // Transform through rotor system
            const newIdx = this.rotors.transform(idx);
            const newChar = this.alphabet[newIdx];
            
            result += newChar;
            prevCipherIdx = newIdx;
            context = [context[1], context[2], context[3], newIdx];
            
            // Track patterns and interference
            proc.patterns.forEach(p => allPatterns.add(p));
            if(proc.interference) interferenceLog.push(proc.interference);
            
            // Log for visualization (every 3rd step + first 3)
            if(i % 3 === 0 || i < 3) {
                logData.push({
                    step: i, char, cipher: newChar,
                    commands: proc.commands.map(c => ({...c})),
                    positions: [...this.rotors.positions],
                    patternCount: allPatterns.size,
                    attention: proc.attention,
                    interference: proc.interference,
                    entropy: proc.entropy,
                    interferenceActive: proc.interferenceActive,
                    cmdHash: this._hashCommands(proc.commands)
                });
            }
            this.cmdHashes.push(this._hashCommands(proc.commands));
        }
        
        const elapsed = performance.now() - startTime;
        
        return {
            text: result,
            logData,
            totalPatterns: allPatterns.size,
            interference: interferenceLog,
            time: elapsed,
            symbolsPerSec: (text.length / elapsed * 1000).toFixed(0)
        };
    }
    
    decrypt(text) {
        this.rotors.reset();
        
        let result = "", prevCipherIdx = 0, context = [0, 0, 0, 0];
        const logData = [];
        
        for(let i = 0; i < text.length; i++) {
            const char = text[i];
            const idx = this.charToIdx[char];
            
            if(idx === undefined) {
                result += char;
                continue;
            }
            
            // Same forward pass (INN is invertible, so same computation)
            const innState = this.initState(i, prevCipherIdx, context);
            const proc = this.processState(innState, i);
            
            this.rotors.update(proc.commands);
            
            // Inverse transform through rotor system
            const newIdx = this.rotors.inverseTransform(idx);
            const newChar = this.alphabet[newIdx];
            
            result += newChar;
            prevCipherIdx = idx; // Note: use plaintext idx for context in decrypt
            context = [context[1], context[2], context[3], idx];
            
            // Verify command hash for reversibility
            const expectedHash = this.cmdHashes[i];
            const actualHash = this._hashCommands(proc.commands);
            if(expectedHash !== actualHash && this.perfMode === 'debug') {
                console.warn(`Hash mismatch at step ${i}`);
            }
            
            if(i % 3 === 0 || i < 3) {
                logData.push({
                    step: i, char, plain: newChar,
                    commands: proc.commands.map(c => ({...c})),
                    positions: [...this.rotors.positions],
                    attention: proc.attention
                });
            }
        }
        
        return { text: result, logData };
    }
    
    // Utility: get char->idx map for O(1) lookup
    get charToIdx() {
        if(!this._charToIdx) {
            this._charToIdx = {};
            for(let i = 0; i < this.alphabet.length; i++) {
                this._charToIdx[this.alphabet[i]] = i;
            }
        }
        return this._charToIdx;
    }
}

// ============================================================================
// GLOBAL CONSTANTS
// ============================================================================
const ACTIVATION_PATTERNS = [
    [0,0,0,0], [1,0,0,0], [0,1,0,0], [0,0,1,0], [0,0,0,1],
    [1,1,0,0], [1,0,1,0], [1,0,0,1], [0,1,1,0], [0,1,0,1],
    [0,0,1,1], [1,1,1,0], [1,1,0,1], [1,0,1,1], [0,1,1,1], [1,1,1,1]
];

const CHAR_HEIGHT = 28;
const ROTOR_COUNT = 4;

// ============================================================================
// UI & APPLICATION LOGIC
// ============================================================================
let engine = null;
let currentMode = 'classic';
let currentPerf = 'quality';

function setMode(mode) {
    currentMode = mode;
    document.getElementById('modeClassic').classList.toggle('active', mode === 'classic');
    document.getElementById('modeNeural').classList.toggle('active', mode === 'neural');
    log(`üîÑ Mode: ${mode === 'classic' ? 'CLASSIC v17.3' : 'NEURAL v18.0'}`, 'info');
    init();
}

function setPerf(mode) {
    currentPerf = mode;
    document.getElementById('perfQuality').classList.toggle('active', mode === 'quality');
    document.getElementById('perfTurbo').classList.toggle('active', mode === 'turbo');
    document.getElementById('perfDebug').classList.toggle('active', mode === 'debug');
    document.getElementById('perfIndicator').textContent = 
        mode === 'quality' ? 'üß† Quality' : mode === 'turbo' ? '‚ö° Turbo' : 'üîç Debug';
    log(`‚öôÔ∏è Performance: ${mode.toUpperCase()}`, 'perf');
    if(engine) init();
}

function init() {
    const alpha = document.getElementById('alphabet').value;
    const pass = document.getElementById('password').value;
    
    // Clear engine cache
    engine = null;
    
    // Initialize with current settings
    engine = new CryptoEngine(alpha, pass, currentMode, currentPerf);
    renderRotors();
    
    if(currentMode === 'neural') {
        log('üß† Neural Dynamics: phase modulation + resonance + interference', 'phase');
    } else {
        log('üé° Classic mode: independent rotors', 'info');
    }
}

function renderRotors() {
    const container = document.getElementById('rotorViz');
    let html = '';
    
    for(let i = 0; i < ROTOR_COUNT; i++) {
        html += `<div class="rotor" id="rotor-${i}">`;
        html += `<div class="rotor-label">ROTOR ${i+1}<span class="rotor-phase" id="phase-${i}"></span></div>`;
        html += `<div class="rotor-display"><div class="rotor-tape" id="rotor-tape-${i}">`;
        
        const chars = engine.rotors.rotors[i];
        // Render 3 cycles for smooth scrolling visualization
        for(let k = 0; k < 3; k++) {
            chars.forEach((c, idx) => {
                html += `<div class="rotor-char" data-idx="${k * engine.N + idx}">${c}</div>`;
            });
        }
        html += `</div></div>`;
        html += `<div class="rotor-info" id="r${i}-info"></div>`;
        html += `<div class="rotor-resonance" id="res${i}-info"></div>`;
        html += `</div>`;
    }
    container.innerHTML = html;
}

function updateRotors(commands, positions, attention, interference) {
    for(let r = 0; r < ROTOR_COUNT; r++) {
        const rotor = document.getElementById(`rotor-${r}`);
        const tape = document.getElementById(`rotor-tape-${r}`);
        const info = document.getElementById(`r${r}-info`);
        const phaseSpan = document.getElementById(`phase-${r}`);
        const resSpan = document.getElementById(`res${r}-info`);
        const chars = tape.querySelectorAll('.rotor-char');
        
        // Update visual states
        rotor.classList.toggle('active', commands[r].active);
        if(currentMode === 'neural') {
            rotor.classList.toggle('phase-active', Math.abs(parseFloat(commands[r].phase)) > 1);
        }
        
        // Info display
        let infoText = `POS:${positions[r]} Œî:${commands[r].delta} S:${commands[r].speed}`;
        if(currentPerf === 'debug') {
            infoText += ` N:${commands[r].noise}`;
        }
        info.textContent = infoText;
        
        // Phase and resonance for neural mode
        if(currentMode === 'neural') {
            phaseSpan.textContent = `œÜ:${commands[r].phase}`;
            resSpan.textContent = `‚ö°${commands[r].resonance}`;
        } else {
            phaseSpan.textContent = '';
            resSpan.textContent = '';
        }
        
        // Scroll tape to current position
        const scrollPos = -(positions[r] * CHAR_HEIGHT) + Math.floor(CHAR_HEIGHT * 1.5);
        tape.style.transform = `translateY(${scrollPos}px)`;
        
        // Highlight active character
        chars.forEach(c => {
            c.classList.remove('active', 'interference');
            const cidx = parseInt(c.dataset.idx) % engine.N;
            if(cidx === positions[r]) {
                c.classList.add('active');
                // Interference highlight for neural mode
                if(currentMode === 'neural' && interference?.[r]) {
                    const intVal = Math.abs(interference[r][0] || 0);
                    if(intVal > 0.05) c.classList.add('interference');
                }
            }
        });
    }
}

function updateDynamicsPanel(logData, interference) {
    if(!logData?.length) return;
    
    const last = logData[logData.length - 1];
    
    // Average phase
    if(last.commands) {
        const avgPhase = last.commands.reduce((sum, c) => sum + Math.abs(parseFloat(c.phase) || 0), 0) / 4;
        document.getElementById('phaseValue').textContent = avgPhase.toFixed(3);
        
        // Average resonance
        const avgRes = last.commands.reduce((sum, c) => sum + Math.abs(parseFloat(c.resonance) || 0), 0) / 4;
        document.getElementById('resonanceValue').textContent = avgRes.toFixed(3);
    }
    
    // Entropy display
    if(last.entropy !== undefined) {
        document.getElementById('entropyValue').textContent = last.entropy.toFixed(2);
    }
    
    // Interference grid (4x4 subset for visualization)
    if(interference?.length && currentMode === 'neural') {
        const grid = document.getElementById('interferenceGrid');
        const lastInterf = interference[interference.length - 1];
        
        if(lastInterf) {
            let html = '';
            const displaySize = 4; // Show 4x4 subset
            for(let h = 0; h < displaySize; h++) {
                for(let k = 0; k < displaySize; k++) {
                    const val = lastInterf[h]?.[k] || 0;
                    const active = Math.abs(val) > 0.05;
                    html += `<div class="interference-cell ${active ? 'active' : ''}">${val.toFixed(2)}</div>`;
                }
            }
            grid.innerHTML = html;
            
            // Active interference count
            let activeCount = 0;
            for(let h = 0; h < 16; h++) {
                for(let k = 0; k < 16; k++) {
                    if(lastInterf[h]?.[k] && Math.abs(lastInterf[h][k]) > 0.05) activeCount++;
                }
            }
            document.getElementById('interferenceValue').textContent = 
                `${activeCount}/256`;
        }
    }
}

function copyOutput() {
    const text = document.getElementById('outputText').textContent;
    if(text && text !== '–û–∂–∏–¥–∞–Ω–∏–µ...') {
        navigator.clipboard.writeText(text).then(() => {
            log('‚úÖ Copied to clipboard', 'ok');
        });
    }
}

function run(mode) {
    const alpha = document.getElementById('alphabet').value;
    const pass = document.getElementById('password').value;
    const input = document.getElementById('inputText').value;
    
    if(!input.trim()) {
        alert('Please enter text to process');
        return;
    }
    
    // Reinitialize engine with current settings
    engine = new CryptoEngine(alpha, pass, currentMode, currentPerf);
    const isEncrypt = mode === 'encrypt';
    
    // Execute with timing
    const start = performance.now();
    const res = isEncrypt ? engine.encrypt(input) : engine.decrypt(input);
    const elapsed = performance.now() - start;
    
    // Update UI
    document.getElementById('outputText').textContent = res.text;
    document.getElementById('statLen').textContent = `${input.length} ‚Üí ${res.text.length}`;
    document.getElementById('statTime').textContent = `${elapsed.toFixed(1)}ms (${res.symbolsPerSec || (input.length/elapsed*1000).toFixed(0)} sym/s)`;
    
    // Update visualization
    if(res.logData?.length) {
        const last = res.logData[res.logData.length - 1];
        updateRotors(last.commands, last.positions, last.attention, res.interference?.[0]);
        document.getElementById('statPatterns').textContent = `${last.patternCount || 0}/16`;
        updateDynamicsPanel(res.logData, res.interference);
    }
    
    log(`${isEncrypt ? 'üîí Encrypted' : 'üîì Decrypted'} ${input.length} symbols in ${elapsed.toFixed(1)}ms`, 'info');
    
    // Reversibility check for encryption
    if(isEncrypt) {
        const testEngine = new CryptoEngine(alpha, pass, currentMode, currentPerf);
        const check = testEngine.decrypt(res.text);
        const ok = check.text === input;
        
        document.getElementById('statRev').textContent = ok ? '‚úÖ OK' : '‚ùå FAIL';
        document.getElementById('statRev').className = 'stat-value ' + (ok ? 'ok' : 'err');
        
        log(ok ? '‚úÖ Reversibility verified' : '‚ùå Reversibility FAILED!', ok ? 'ok' : 'err');
        
        // Neural mode diagnostics
        if(currentMode === 'neural' && res.logData?.[0]) {
            const cmds = res.logData[0].commands;
            const deltas = cmds.map(c => c.delta).join(',');
            const phases = cmds.map(c => c.phase).join(',');
            log(`üé° Neural: Œî[${deltas}] œÜ[${phases}]`, 'phase');
        }
    }
}

function runTest() {
    const alpha = document.getElementById('alphabet').value;
    const pass = document.getElementById('password').value;
    const input = document.getElementById('inputText').value || 'TEST123';
    
    log('üß™ Running reversibility test...', 'info');
    
    // Test multiple rounds
    let current = input;
    const rounds = 3;
    let allPassed = true;
    
    for(let round = 0; round < rounds; round++) {
        const encEngine = new CryptoEngine(alpha, pass, currentMode, currentPerf);
        const encrypted = encEngine.encrypt(current);
        
        const decEngine = new CryptoEngine(alpha, pass, currentMode, currentPerf);
        const decrypted = decEngine.decrypt(encrypted.text);
        
        const passed = decrypted.text === current;
        allPassed = allPassed && passed;
        
        log(`Round ${round + 1}: ${passed ? '‚úÖ' : '‚ùå'} "${current}" ‚Üí "${encrypted.text}" ‚Üí "${decrypted.text}"`, passed ? 'ok' : 'err');
        
        current = encrypted.text; // Chain encryption for stress test
    }
    
    log(allPassed ? `‚úÖ All ${rounds} rounds passed` : `‚ùå Test failed`, allPassed ? 'ok' : 'err');
}

function log(msg, type = 'info') {
    const container = document.getElementById('log');
    const entry = document.createElement('div');
    entry.className = `log-entry ${type}`;
    entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    container.insertBefore(entry, container.firstChild);
    
    // Limit log entries
    while(container.children.length > 20) {
        container.removeChild(container.lastChild);
    }
}

// Initialize on load
window.addEventListener('load', () => {
    init();
    log('‚úÖ True ITN v18.0 Pro initialized', 'ok');
    log(`üìä Optimizations: LUT trig, TypedArray pooling, Early-exit, O(1) lookups`, 'perf');
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
    if(e.ctrlKey && e.key === 'Enter') {
        e.preventDefault();
        run('encrypt');
    } else if(e.ctrlKey && e.key === 'Backspace') {
        e.preventDefault();
        run('decrypt');
    }
});
</script>
</body>
</html>
