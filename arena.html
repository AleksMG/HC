<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ö° HC Arena v18.1 ‚Äî –ü–õ–ê–í–ù–û–ï –î–í–ò–ñ–ï–ù–ò–ï</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Courier New', monospace; }
        body { background: #0a0a15; color: #fff; display: flex; flex-direction: column; align-items: center; padding: 20px; min-height: 100vh; }
        h1 { color: #00f2ff; margin-bottom: 10px; text-shadow: 0 0 20px rgba(0,242,255,0.5); }
        .badge { background: linear-gradient(90deg, #00f2ff, #00ff9d, #ff0055); color: #000; padding: 5px 15px; border-radius: 20px; font-weight: bold; font-size: 0.8rem; margin-bottom: 15px; }
        #arena { border: 2px solid #00f2ff; background: #050510; border-radius: 8px; }
        .controls { margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
        button { padding: 12px 24px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; text-transform: uppercase; transition: all 0.3s; }
        button:hover { transform: scale(1.05); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .btn-start { background: #00f2ff; color: #000; }
        .btn-stop { background: #ff6600; color: #fff; }
        .btn-train { background: #ff0055; color: #fff; }
        .btn-reverse { background: #00ff9d; color: #000; }
        .btn-reset { background: #333; color: #fff; }
        .btn-export { background: #6600ff; color: #fff; }
        .btn-import { background: #ff00ff; color: #fff; }
        .btn-vision { background: #ffaa00; color: #000; }
        .stats { margin-top: 15px; color: #888; display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; }
        .stat { background: #121225; padding: 8px 15px; border-radius: 6px; border: 1px solid #2a2a40; }
        .stat-value { color: #00f2ff; font-weight: bold; }
        .stat-value.ok { color: #00ff9d; }
        .stat-value.err { color: #ff0055; }
        .stat-value.warn { color: #ffaa00; }
        .log { margin-top: 15px; background: #000; border: 1px solid #333; padding: 10px; max-height: 180px; overflow-y: auto; font-size: 0.75rem; width: 800px; border-radius: 6px; }
        .log-entry { margin-bottom: 5px; padding: 3px 0; border-bottom: 1px solid #1a1a1a; }
        .health { margin-top: 15px; display: flex; gap: 40px; }
        .hp-box { width: 200px; }
        .bar { width: 100%; height: 12px; background: #333; border-radius: 6px; overflow: hidden; }
        .fill { height: 100%; transition: width 0.3s; }
        .blue { background: linear-gradient(90deg, #0066ff, #00f2ff); }
        .red { background: linear-gradient(90deg, #ff0055, #ff6688); }
        .worker-status { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; }
        .worker-ok { background: #00ff9d; box-shadow: 0 0 10px #00ff9d; }
        .worker-err { background: #ff0055; }
        .worker-ready { background: #00f2ff; }
        .agent-stats { margin-top: 10px; font-size: 0.75rem; color: #666; }
        .reward-display { margin-top: 5px; font-size: 0.7rem; }
        .reward-blue { color: #00f2ff; }
        .reward-red { color: #ff0055; }
        .file-input { display: none; }
        .vision-badge { font-size: 0.7rem; color: #ffaa00; margin-left: 10px; }
    </style>
</head>
<body>
    <h1>‚ö° HC ARENA v18.1 <span class="vision-badge">üëÅÔ∏è –ü–õ–ê–í–ù–û–ï –î–í–ò–ñ–ï–ù–ò–ï</span></h1>
    <div class="badge">Web Worker | 338 dim | 16-Head | 12 Blocks | 102 Memory | CNN Vision | Online Learning | Hindsight</div>
    
    <canvas id="arena" width="800" height="600"></canvas>
    
    <div class="health">
        <div class="hp-box">
            <div style="color:#00f2ff">üü¶ BLUE AGENT</div>
            <div class="bar"><div class="fill blue" id="blueBar" style="width:100%"></div></div>
            <div class="reward-display reward-blue" id="blueReward">Reward: 0.00</div>
            <div class="agent-stats" id="blueStats">Wins: 0 | Mut: 0 | Hindsight: 0</div>
        </div>
        <div class="hp-box">
            <div style="color:#ff0055">üü• RED AGENT</div>
            <div class="bar"><div class="fill red" id="redBar" style="width:100%"></div></div>
            <div class="reward-display reward-red" id="redReward">Reward: 0.00</div>
            <div class="agent-stats" id="redStats">Wins: 0 | Mut: 0 | Hindsight: 0</div>
        </div>
    </div>
    
    <div class="controls">
        <button class="btn-start" id="btnStart" onclick="startGame()">‚ñ∂Ô∏è START</button>
        <button class="btn-stop" id="btnStop" onclick="stopGame()" disabled>‚èπÔ∏è STOP</button>
        <button class="btn-train" id="btnTrain" onclick="toggleTrain()">üß† Train</button>
        <button class="btn-reverse" id="btnReverse" onclick="doReverse()">üîÑ Reverse</button>
        <button class="btn-reset" id="btnReset" onclick="resetGame()">‚Ü∫ Reset</button>
        <button class="btn-export" id="btnExport" onclick="exportWeights()">üíæ Export</button>
        <button class="btn-import" id="btnImport" onclick="document.getElementById('fileInput').click()">üìÇ Import</button>
        <button class="btn-vision" id="btnVision" onclick="toggleVision()">üëÅÔ∏è Vision: ON</button>
        <input type="file" id="fileInput" class="file-input" accept=".json" onchange="importWeights(event)">
    </div>
    
    <div class="stats">
        <span class="stat"><span class="worker-status worker-ready" id="workerStatus"></span>Worker: <span class="stat-value" id="workerState">READY</span></span>
        <span class="stat">Gen: <span class="stat-value" id="gen">0</span></span>
        <span class="stat">Episode: <span class="stat-value" id="ep">0</span></span>
        <span class="stat">Blue: <span class="stat-value" id="blueWins">0</span></span>
        <span class="stat">Red: <span class="stat-value" id="redWins">0</span></span>
        <span class="stat">Reversed: <span class="stat-value" id="reversed">0</span></span>
        <span class="stat">FPS: <span class="stat-value" id="fps">0</span></span>
    </div>
    
    <div class="log" id="log"></div>

<script>
// ============================================================================
// HC ARENA v18.1 ‚Äî –ü–õ–ê–í–ù–û–ï –î–í–ò–ñ–ï–ù–ò–ï
// ============================================================================

const canvas = document.getElementById('arena');
const ctx = canvas.getContext('2d');

// Game state
let blue, red, obstacles;
let running = false, training = false, gameStarted = false, visionEnabled = true;
let episode = 0, blueWins = 0, redWins = 0, totalReverse = 0, generation = 0;
let worker = null;
let lastFrameTime = performance.now();
let frameCount = 0;
let fps = 0;
let blueReward = 0, redReward = 0;
let blueDamage = 0, redDamage = 0;
let animFrame = null;

// ============================================================================
// WORKER INITIALIZATION
// ============================================================================
function initWorker() {
    if (worker) {
        worker.terminate();
    }

    worker = new Worker('arena-worker.js');

    worker.onmessage = function(e) {
        const msg = e.data || {};
        const type = msg.type;
        const data = msg.data;

        switch (type) {
            case 'WORKER_READY':
                handleWorkerReady(data);
                break;
            case 'INIT':
                handleInit(data);
                break;
            case 'LOG':
                handleLog(data);
                break;
            case 'ACTIONS':
                handleActions(data);
                break;
            case 'TRAIN_COMPLETE':
                handleTrainComplete(data);
                break;
            case 'REVERSE_RESULT':
                handleReverseResult(data);
                break;
            case 'ERR':
                handleError(data);
                break;
            case 'STATS':
                handleStats(data);
                break;
            case 'REWARD':
                handleReward(data);
                break;
            case 'WEIGHTS_EXPORT':
                handleWeightsExport(data);
                break;
            default:
                console.warn('[Main] Unknown message type:', type);
        }
    };

    worker.onerror = function(e) {
        log('‚ùå Worker Error: ' + e.message, 'err');
        document.getElementById('workerState').innerText = 'ERROR';
        document.getElementById('workerStatus').className = 'worker-status worker-err';
    };

    log('üîß Worker initialized', 'info');
}

// ============================================================================
// MESSAGE HANDLERS
// ============================================================================
function handleWorkerReady(data) {
    document.getElementById('workerState').innerText = 'READY';
    document.getElementById('workerStatus').className = 'worker-status worker-ready';
    log('‚úÖ Worker v' + (data ? data.version : '18.1') + ' ready', 'success');
}

function handleInit(data) {
    if (data && data.status) {
        document.getElementById('workerState').innerText = data.status.toUpperCase();
        if (data.status === 'ready') {
            document.getElementById('workerStatus').className = 'worker-status worker-ok';
        } else if (data.status === 'reset') {
            document.getElementById('workerStatus').className = 'worker-status worker-ready';
        } else if (data.status === 'loaded') {
            document.getElementById('workerStatus').className = 'worker-status worker-ok';
            log('‚úÖ Weights loaded successfully', 'success');
        }
    }
}

function handleLog(data) {
    if (data && data.msg) {
        log(data.msg, data.type || 'info');
    }
}

function handleActions(data) {
    if (!running || !data) return;
    applyActions(data);
}

function handleTrainComplete(data) {
    if (data) {
        if (data.generation !== undefined) {
            document.getElementById('gen').innerText = data.generation;
            generation = data.generation;
        }
        if (data.blueWins !== undefined) {
            document.getElementById('blueWins').innerText = data.blueWins;
            blueWins = data.blueWins;
        }
        if (data.redWins !== undefined) {
            document.getElementById('redWins').innerText = data.redWins;
            redWins = data.redWins;
        }
        log(`üß¨ Generation ${data.generation} | ${data.winner} wins`, 'train');
    }
}

function handleReverseResult(data) {
    if (data && data.success) {
        totalReverse++;
        document.getElementById('reversed').innerText = totalReverse;
        log(`üîÑ Reversed ${data.steps} steps`, 'train');
    }
}

function handleError(data) {
    if (data && data.msg) {
        log('‚ùå ' + data.msg, 'err');
        if (data.stack) console.error('[Worker]', data.stack);
    }
    document.getElementById('workerState').innerText = 'ERROR';
    document.getElementById('workerStatus').className = 'worker-status worker-err';
}

function handleStats(data) {
    if (!data) return;

    if (data.generation !== undefined) document.getElementById('gen').innerText = data.generation;
    if (data.episode !== undefined) document.getElementById('ep').innerText = data.episode;
    if (data.blueWins !== undefined) document.getElementById('blueWins').innerText = data.blueWins;
    if (data.redWins !== undefined) document.getElementById('redWins').innerText = data.redWins;

    if (data.agent1) {
        document.getElementById('blueStats').innerText = 
            'Wins: ' + (data.agent1.wins || 0) + 
            ' | Mut: ' + (data.agent1.mutations || 0) +
            ' | Hindsight: ' + (data.agent1.hindsightCount || 0);
    }
    if (data.agent2) {
        document.getElementById('redStats').innerText = 
            'Wins: ' + (data.agent2.wins || 0) + 
            ' | Mut: ' + (data.agent2.mutations || 0) +
            ' | Hindsight: ' + (data.agent2.hindsightCount || 0);
    }
}

function handleReward(data) {
    if (!data) return;
    if (data.blue !== undefined) {
        blueReward = data.blue;
        document.getElementById('blueReward').innerText = 'Reward: ' + blueReward.toFixed(3);
    }
    if (data.red !== undefined) {
        redReward = data.red;
        document.getElementById('redReward').innerText = 'Reward: ' + redReward.toFixed(3);
    }
}

function handleWeightsExport(data) {
    if (!data || !data.blue || !data.red) return;

    const exportData = {
        version: '18.1',
        timestamp: Date.now(),
        generation: generation,
        blueWins: blueWins,
        redWins: redWins,
        blue: data.blue,
        red: data.red
    };

    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'hc_weights_gen' + generation + '_' + Date.now() + '.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    log('üíæ Weights exported (Gen ' + generation + ')', 'success');
}

// ============================================================================
// GAME INITIALIZATION
// ============================================================================
function initGame() {
    blue = { 
        x: 200, y: 300, vx: 0, vy: 0, 
        hp: 100, maxHp: 100, 
        size: 40, 
        damageDealt: 0, damageTaken: 0,
        wins: 0
    };
    red = { 
        x: 600, y: 300, vx: 0, vy: 0, 
        hp: 100, maxHp: 100, 
        size: 40, 
        damageDealt: 0, damageTaken: 0,
        wins: 0
    };

    obstacles = [
        { x: 400, y: 150, w: 200, h: 20 },
        { x: 400, y: 450, w: 200, h: 20 },
        { x: 250, y: 300, w: 20, h: 200 },
        { x: 550, y: 300, w: 20, h: 200 }
    ];

    episode++;
    blueReward = 0;
    redReward = 0;
    blueDamage = 0;
    redDamage = 0;

    updateUI();
}

// ============================================================================
// CANVAS DATA CAPTURE
// ============================================================================
function captureCanvasForAgent(agentX, agentY, targetX, targetY) {
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = 84;
    tempCanvas.height = 84;
    const tempCtx = tempCanvas.getContext('2d');
    
    if (visionEnabled) {
        const angle = Math.atan2(targetY - agentY, targetX - agentX);
        
        tempCtx.translate(42, 42);
        tempCtx.rotate(-angle);
        tempCtx.translate(-42, -42);
        
        tempCtx.fillStyle = '#050510';
        tempCtx.fillRect(0, 0, 84, 84);
        
        tempCtx.fillStyle = '#2a2a40';
        obstacles.forEach(obs => {
            const sx = (obs.x - agentX) / 10 + 42;
            const sy = (obs.y - agentY) / 10 + 42;
            const sw = obs.w / 10;
            const sh = obs.h / 10;
            if (sx > -20 && sx < 104 && sy > -20 && sy < 104) {
                tempCtx.fillRect(sx - sw/2, sy - sh/2, sw, sh);
            }
        });
        
        const ex = (targetX - agentX) / 10 + 42;
        const ey = (targetY - agentY) / 10 + 42;
        if (ex > 0 && ex < 84 && ey > 0 && ey < 84) {
            tempCtx.fillStyle = agentX === blue.x ? '#ff0055' : '#00f2ff';
            tempCtx.fillRect(ex - 4, ey - 4, 8, 8);
        }
        
        tempCtx.fillStyle = agentX === blue.x ? '#00f2ff' : '#ff0055';
        tempCtx.fillRect(38, 38, 8, 8);
        
    } else {
        tempCtx.fillStyle = '#000';
        tempCtx.fillRect(0, 0, 84, 84);
    }
    
    return tempCtx.getImageData(0, 0, 84, 84);
}

// ============================================================================
// –§–ò–ó–ò–ö–ê –ò –î–í–ò–ñ–ï–ù–ò–ï ‚Äî –ü–õ–ê–í–ù–û–ï
// ============================================================================
function applyActions(actions) {
    if (!running || !actions) return;

    const { blue: a1, red: a2 } = actions;

    // ========================================================================
    // –ü–ê–†–ê–ú–ï–¢–†–´ –î–í–ò–ñ–ï–ù–ò–Ø (–∫–∞–∫ –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª–µ)
    // ========================================================================
    const MOVE_FORCE = 60;         // ‚Üê —Å–∏–ª–∞ –¥–≤–∏–∂–µ–Ω–∏—è
    const BOUNCE_FORCE = 4;        // —Å–∏–ª–∞ –æ—Ç—Å–∫–æ–∫–∞
    const FRICTION = 0.90;          // —Ç—Ä–µ–Ω–∏–µ (–≤–∞–∂–Ω–æ –¥–ª—è –ø–ª–∞–≤–Ω–æ—Å—Ç–∏!)
    
    // –ë–∞–∑–æ–≤–∞—è –∞–≥—Ä–µ—Å—Å–∏—è (–æ—Ä–∏–≥–∏–Ω–∞–ª)
    const sp1 = 0.4 + a1.aggression * 0.6;
    const sp2 = 0.4 + a2.aggression * 0.6;
    
    // ========================================================================
    // –ü–õ–ê–í–ù–û–ï –î–í–ò–ñ–ï–ù–ò–ï
    // ========================================================================
    // –ù–µ–±–æ–ª—å—à–æ–π –ø–ª–∞–≤–Ω—ã–π —Ç–æ–ª—á–æ–∫ –∫–∞–∂–¥—ã–π –∫–∞–¥—Ä
    blue.vx += a1.fx * sp1 * MOVE_FORCE;
    blue.vy += a1.fy * sp1 * MOVE_FORCE;
    red.vx += a2.fx * sp2 * MOVE_FORCE;
    red.vy += a2.fy * sp2 * MOVE_FORCE;

    // –ü–ª–∞–≤–Ω–æ–µ –∑–∞—Ç—É—Ö–∞–Ω–∏–µ (–æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ —Ç—Ä–µ–Ω–∏–µ)
    blue.vx *= FRICTION;
    blue.vy *= FRICTION;
    red.vx *= FRICTION;
    red.vy *= FRICTION;

    // –î–≤–∏–∂–µ–Ω–∏–µ
    blue.x += blue.vx;
    blue.y += blue.vy;
    red.x += red.vx;
    red.y += red.vy;

    // ========================================================================
    // –§–ò–ó–ò–ö–ê
    // ========================================================================
    
    // –°—Ç–µ–Ω—ã
    if (blue.x < 20 || blue.x > canvas.width - 20) {
        blue.vx *= -1.5;
        blue.x = Math.max(20, Math.min(canvas.width - 20, blue.x));
    }
    if (blue.y < 20 || blue.y > canvas.height - 20) {
        blue.vy *= -1.5;
        blue.y = Math.max(20, Math.min(canvas.height - 20, blue.y));
    }
    if (red.x < 20 || red.x > canvas.width - 20) {
        red.vx *= -1.5;
        red.x = Math.max(20, Math.min(canvas.width - 20, red.x));
    }
    if (red.y < 20 || red.y > canvas.height - 20) {
        red.vy *= -1.5;
        red.y = Math.max(20, Math.min(canvas.height - 20, red.y));
    }

    // –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
    for (let obs of obstacles) {
        if (blue.x > obs.x - obs.w/2 - 20 && blue.x < obs.x + obs.w/2 + 20 &&
            blue.y > obs.y - obs.h/2 - 20 && blue.y < obs.y + obs.h/2 + 20) {
            blue.vx *= -1.5;
            blue.vy *= -1.5;
        }
        if (red.x > obs.x - obs.w/2 - 20 && red.x < obs.x + obs.w/2 + 20 &&
            red.y > obs.y - obs.h/2 - 20 && red.y < obs.y + obs.h/2 + 20) {
            red.vx *= -1.5;
            red.vy *= -1.5;
        }
    }

    // –ë–æ–π
    const dist = Math.hypot(blue.x - red.x, blue.y - red.y);
    if (dist < 40) {
        const bSp = Math.hypot(blue.vx, blue.vy);
        const rSp = Math.hypot(red.vx, red.vy);
        const tot = bSp + rSp;

        if (tot > 0) {
            const bDmg = (rSp / tot) * 10 + 3;
            const rDmg = (bSp / tot) * 10 + 3;

            blue.hp -= bDmg;
            red.hp -= rDmg;

            blue.damageTaken += bDmg;
            red.damageTaken += rDmg;
            blue.damageDealt += rDmg;
            red.damageDealt += bDmg;
        }

        const ang = Math.atan2(blue.y - red.y, blue.x - red.x);
        blue.vx += Math.cos(ang) * BOUNCE_FORCE;
        blue.vy += Math.sin(ang) * BOUNCE_FORCE;
        red.vx -= Math.cos(ang) * BOUNCE_FORCE;
        red.vy -= Math.sin(ang) * BOUNCE_FORCE;
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–º–µ—Ä—Ç–∏
    if (blue.hp <= 0 || red.hp <= 0) {
        const winner = blue.hp > 0 ? 'BLUE' : 'RED';
        if (winner === 'BLUE') blueWins++; else redWins++;

        log('üèÜ ' + winner + ' WINS! (Gen ' + generation + ')', 'battle');

        if (training && worker) {
            worker.postMessage({
                type: 'TRAIN',
                data: { 
                    winner: winner,
                    generation: generation
                }
            });
        }

        setTimeout(initGame, 2000);
    }

    updateUI();
}

// ============================================================================
// RENDER ‚Äî –ü–õ–ê–í–ù–ê–Ø –û–¢–†–ò–°–û–í–ö–ê (60 FPS)
// ============================================================================
function render() {
    if (!running) {
        // –ï—Å–ª–∏ –∏–≥—Ä–∞ –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞, –≤—Å—ë —Ä–∞–≤–Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –æ—Ç—Ä–∏—Å–æ–≤–∫—É
        requestAnimationFrame(render);
        return;
    }

    // –û—á–∏—Å—Ç–∫–∞ –∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–∞
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
    ctx.fillStyle = '#2a2a40';
    for (let obs of obstacles) {
        ctx.fillRect(obs.x - obs.w / 2, obs.y - obs.h / 2, obs.w, obs.h);
    }

    // –°–∏–Ω–∏–π –∞–≥–µ–Ω—Ç
    ctx.fillStyle = '#00f2ff';
    ctx.shadowColor = '#00f2ff';
    ctx.shadowBlur = blue.hp < 30 ? 30 : 20;
    ctx.fillRect(blue.x - 20, blue.y - 20, 40, 40);

    // –ö—Ä–∞—Å–Ω—ã–π –∞–≥–µ–Ω—Ç
    ctx.fillStyle = '#ff0055';
    ctx.shadowColor = '#ff0055';
    ctx.shadowBlur = red.hp < 30 ? 30 : 20;
    ctx.fillRect(red.x - 20, red.y - 20, 40, 40);

    ctx.shadowBlur = 0;

    // FPS —Å—á–µ—Ç—á–∏–∫
    frameCount++;
    const now = performance.now();
    if (now - lastFrameTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastFrameTime = now;
        document.getElementById('fps').innerText = fps;
    }

    // –°–ª–µ–¥—É—é—â–∏–π –∫–∞–¥—Ä
    requestAnimationFrame(render);
}

// ============================================================================
// UI UPDATE
// ============================================================================
function updateUI() {
    document.getElementById('blueBar').style.width = Math.max(0, blue.hp) + '%';
    document.getElementById('redBar').style.width = Math.max(0, red.hp) + '%';
    document.getElementById('ep').innerText = episode;
    document.getElementById('blueWins').innerText = blueWins;
    document.getElementById('redWins').innerText = redWins;

    document.getElementById('btnStart').disabled = running;
    document.getElementById('btnStop').disabled = !running;
    document.getElementById('btnTrain').disabled = !gameStarted;
    document.getElementById('btnReverse').disabled = !gameStarted;
    document.getElementById('btnExport').disabled = !gameStarted;
    document.getElementById('btnVision').innerText = visionEnabled ? 'üëÅÔ∏è Vision: ON' : 'üëÅÔ∏è Vision: OFF';
}

function log(msg, type) {
    const l = document.getElementById('log');
    const d = document.createElement('div');
    d.className = 'log-entry';
    d.innerText = '[' + new Date().toLocaleTimeString() + '] ' + msg;

    if (type === 'train') d.style.color = '#00ff9d';
    else if (type === 'battle') d.style.color = '#ffaa00';
    else if (type === 'err') d.style.color = '#ff0055';
    else if (type === 'success') d.style.color = '#00ff9d';
    else if (type === 'warning') d.style.color = '#ffaa00';
    else d.style.color = '#00f2ff';

    l.insertBefore(d, l.firstChild);
    if (l.children.length > 20) l.removeChild(l.lastChild);
}

// ============================================================================
// BUTTON HANDLERS
// ============================================================================
function startGame() {
    if (!worker) {
        initWorker();
    }

    gameStarted = true;
    running = true;
    initGame();

    log('‚ñ∂Ô∏è Game STARTED', 'success');
    updateUI();

    if (worker) {
        worker.postMessage({
            type: 'START',
            data: {
                training: training,
                episode: episode,
                generation: generation
            }
        });
    }

    // –ó–∞–ø—É—Å–∫–∞–µ–º —Ü–∏–∫–ª –¥–µ–π—Å—Ç–≤–∏–π
    requestActions();
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º –æ—Ç—Ä–∏—Å–æ–≤–∫—É (–µ—Å–ª–∏ –µ—â—ë –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞)
    if (!animFrame) {
        render();
    }
}

function requestActions() {
    if (!running || !worker) return;

    const dist1 = Math.hypot(red.x - blue.x, red.y - blue.y);
    const dist2 = dist1;

    const input1 = getInput(blue, red);
    const input2 = getInput(red, blue);
    
    const canvasData1 = captureCanvasForAgent(blue.x, blue.y, red.x, red.y);
    const canvasData2 = captureCanvasForAgent(red.x, red.y, blue.x, blue.y);

    const canvas1 = {
        width: canvasData1.width,
        height: canvasData1.height,
        data: Array.from(canvasData1.data)
    };
    
    const canvas2 = {
        width: canvasData2.width,
        height: canvasData2.height,
        data: Array.from(canvasData2.data)
    };

    if (worker) {
        worker.postMessage({
            type: 'STEP',
            data: {
                input1: input1,
                input2: input2,
                canvas1: canvas1,
                canvas2: canvas2,
                episode: episode,
                training: training,
                generation: generation,
                dist1: dist1,
                dist2: dist2,
                damage1: blue.damageDealt,
                damage2: red.damageDealt,
                pos1: { x: blue.x, y: blue.y },
                pos2: { x: red.x, y: red.y }
            }
        });
    }

    // –°–ª–µ–¥—É—é—â–∏–π –∑–∞–ø—Ä–æ—Å —á–µ—Ä–µ–∑ 16–º—Å (~60 FPS)
    setTimeout(requestActions, 16);
}

function stopGame() {
    running = false;
    log('‚èπÔ∏è Game STOPPED', 'info');
    updateUI();
}

function toggleTrain() {
    training = !training;
    log(training ? 'üß† Training ON' : 'üß† Training OFF', 'train');

    if (worker) {
        worker.postMessage({
            type: 'SET_TRAINING',
            data: { training: training }
        });
    }
}

function toggleVision() {
    visionEnabled = !visionEnabled;
    document.getElementById('btnVision').innerText = visionEnabled ? 'üëÅÔ∏è Vision: ON' : 'üëÅÔ∏è Vision: OFF';
    log(visionEnabled ? 'üëÅÔ∏è CNN Vision enabled' : 'üëÅÔ∏è CNN Vision disabled', 'info');
}

function doReverse() {
    if (!worker || !gameStarted) {
        log('‚ùå Start game first!', 'err');
        return;
    }

    worker.postMessage({
        type: 'REVERSE',
        data: { steps: 5 }
    });
}

function resetGame() {
    running = false;
    gameStarted = false;
    episode = 0;
    generation = 0;
    blueWins = 0;
    redWins = 0;
    totalReverse = 0;
    blueReward = 0;
    redReward = 0;

    if (worker) {
        worker.postMessage({ 
            type: 'RESET',
            data: { generation: 0 }
        });
    }

    initGame();
    log('‚Ü∫ Reset complete', 'info');
    updateUI();
}

function exportWeights() {
    if (!worker || !gameStarted) {
        log('‚ùå Start game first!', 'err');
        return;
    }

    worker.postMessage({ type: 'EXPORT_WEIGHTS' });
}

function importWeights(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const weights = JSON.parse(e.target.result);
            if (worker && weights.blue && weights.red) {
                worker.postMessage({
                    type: 'IMPORT_WEIGHTS',
                    data: {
                        blue: weights.blue,
                        red: weights.red
                    }
                });
                if (weights.generation) generation = weights.generation;
                if (weights.blueWins) blueWins = weights.blueWins;
                if (weights.redWins) redWins = weights.redWins;
                
                log('üìÇ Weights imported: ' + file.name + ' (Gen ' + generation + ')', 'success');
            } else {
                log('‚ùå Invalid weights file', 'err');
            }
        } catch (err) {
            log('‚ùå Error loading weights: ' + err.message, 'err');
        }
    };
    reader.readAsText(file);
    event.target.value = '';
}

// ============================================================================
// RAYCASTING
// ============================================================================
function raycast(x, y, angle, maxDist) {
    for (let i = 0; i < maxDist; i += 15) {
        const tx = x + Math.cos(angle) * i;
        const ty = y + Math.sin(angle) * i;

        for (let obs of obstacles) {
            if (tx > obs.x - obs.w / 2 && tx < obs.x + obs.w / 2 &&
                ty > obs.y - obs.h / 2 && ty < obs.y + obs.h / 2) {
                return i / maxDist;
            }
        }

        if (tx < 0 || tx > canvas.width || ty < 0 || ty > canvas.height) {
            return i / maxDist;
        }
    }
    return 1;
}

function getInput(me, enemy) {
    const input = [];

    // Position
    input.push(me.x / canvas.width);
    input.push(me.y / canvas.height);

    // Velocity
    input.push(me.vx * 0.5);
    input.push(me.vy * 0.5);

    // Enemy relative
    input.push((enemy.x - me.x) / canvas.width);
    input.push((enemy.y - me.y) / canvas.height);
    input.push(enemy.vx * 0.5);
    input.push(enemy.vy * 0.5);

    // Distance
    input.push(Math.hypot(enemy.x - me.x, enemy.y - me.y) / canvas.width);

    // Health
    input.push(me.hp / me.maxHp);
    input.push(enemy.hp / enemy.maxHp);

    // 32 rays
    for (let i = 0; i < 32; i++) {
        const angle = (i / 32) * Math.PI * 2;
        input.push(raycast(me.x, me.y, angle, 400));
    }

    while (input.length < 32) input.push(0);
    return input.slice(0, 32);
}

// ============================================================================
// STATS & INIT
// ============================================================================
function requestStats() {
    if (worker && gameStarted) {
        worker.postMessage({ type: 'GET_STATS' });
    }
    setTimeout(requestStats, 1000);
}

window.onload = function() {
    initWorker();
    initGame();
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º –æ—Ç—Ä–∏—Å–æ–≤–∫—É —Å—Ä–∞–∑—É
    animFrame = requestAnimationFrame(render);
    
    requestStats();
    log('‚ö° HC v18.1 Ready | Press ‚ñ∂Ô∏è START', 'info');
    updateUI();
};

window.onbeforeunload = function() {
    if (worker) {
        worker.terminate();
    }
    if (animFrame) {
        cancelAnimationFrame(animFrame);
    }
};
</script>
</body>
</html>
