<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
    <title>üéÆ AI Arena v3.2.2 ‚Äî PROFESSIONAL FIXED</title>
    <style>
        :root {
            --bg: #0a0a15;
            --panel: #121225;
            --text: #e0e0ff;
            --primary: #00f2ff;
            --accent: #ff0066;
            --success: #00ff9d;
            --warning: #ffaa00;
            --danger: #ff4444;
            --border: #2a2a45;
            --purple: #aa88ff;
            --yellow: #ffdd44;
            --stat-str: #ff4444;
            --stat-spd: #4444ff;
            --stat-hp: #44ff44;
            --stat-dod: #aa88ff;
            --learning-good: #00ff9d;
            --learning-bad: #ff5577;
            --learning-neutral: #ffaa00;
        }
        
        @supports not (--css: variables) {
            body { background: #0a0a15; color: #e0e0ff; }
            .sidebar { background: #121225; }
            .panel { background: rgba(0,0,0,0.3); border-color: #2a2a45; }
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', system-ui, sans-serif; }
        
        body { 
            background: var(--bg); 
            color: var(--text); 
            overflow: hidden;
            user-select: none;
        }
        
        .container { display: grid; grid-template-columns: 1fr 420px; height: 100vh; }
        
        #gameCanvas { 
            width: 100%; 
            height: 100%; 
            background: linear-gradient(135deg, #0a0a15 0%, #1a1a2e 100%);
            display: block;
            cursor: crosshair;
        }
        
        .sidebar {
            background: var(--panel);
            border-left: 1px solid var(--border);
            padding: 10px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .panel {
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 8px;
        }
        
        .panel-title {
            color: var(--primary);
            font-size: 0.75rem;
            font-weight: 700;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 5px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 4px;
        }
        
        .stat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
        }
        
        .stat {
            background: rgba(0,0,0,0.2);
            padding: 4px 6px;
            border-radius: 6px;
            font-size: 0.6rem;
        }
        
        .stat-label { color: #888; display: block; margin-bottom: 1px; }
        .stat-value { color: var(--primary); font-weight: 700; font-family: 'Courier New', monospace; }
        .stat-value.good { color: var(--success); }
        .stat-value.bad { color: var(--danger); }
        .stat-value.warn { color: var(--warning); }
        .stat-value.learning { color: var(--learning-good); }
        
        .control-group { margin-bottom: 6px; }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.65rem;
            margin-bottom: 2px;
            color: #aaa;
        }
        
        input[type="range"] {
            width: 100%;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-top: 4px; }
        .btn-group-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px; margin-top: 4px; }
        
        button {
            padding: 6px;
            border: none;
            border-radius: 6px;
            font-weight: 700;
            cursor: pointer;
            font-size: 0.65rem;
            transition: all 0.2s;
            text-transform: uppercase;
        }
        
        button:focus, input:focus { 
            outline: 2px solid var(--primary, #00f2ff); 
            outline-offset: 2px; 
        }
        
        .btn-primary { background: var(--primary); color: #000; }
        .btn-primary:hover { background: #fff; transform: translateY(-1px); }
        .btn-danger { background: var(--danger); color: #fff; }
        .btn-danger:hover { background: #ff6666; }
        .btn-success { background: var(--success); color: #000; }
        .btn-success:hover { background: #66ffcc; }
        .btn-secondary { background: var(--border); color: var(--text); }
        .btn-secondary:hover { background: #3a3a55; }
        .btn-toggle { background: var(--border); color: var(--text); }
        .btn-toggle.active { background: var(--accent); color: #fff; }
        .btn-learning { background: var(--purple); color: #fff; }
        .btn-learning:hover { background: #cc88ff; }
        
        .log {
            background: #000;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 6px;
            height: 90px;
            overflow-y: auto;
            font-size: 0.55rem;
            font-family: 'Courier New', monospace;
            word-break: break-word;
            white-space: pre-wrap;
            max-width: 100%;
        }
        
        .log-entry { margin-bottom: 2px; padding-bottom: 2px; border-bottom: 1px solid #111; }
        .log-entry.info { color: var(--primary); }
        .log-entry.success { color: var(--success); }
        .log-entry.warn { color: var(--warning); }
        .log-entry.error { color: var(--danger); }
        .log-entry.learning { color: var(--learning-good); }
        
        .progress-bar {
            height: 4px;
            background: rgba(0,0,0,0.3);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 3px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--success));
            transition: width 0.3s;
        }
        
        .agent-legend {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 3px;
            margin-top: 4px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.55rem;
        }
        
        .legend-color {
            width: 8px;
            height: 8px;
            border-radius: 2px;
        }
        
        .toggle {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.65rem;
            margin-bottom: 3px;
        }
        
        .toggle input { accent-color: var(--primary); width: 14px; height: 14px; }
        
        .header {
            grid-column: 1 / -1;
            background: var(--panel);
            border-bottom: 1px solid var(--border);
            padding: 8px 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header h1 {
            font-size: 0.9rem;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .fps-counter {
            font-family: 'Courier New', monospace;
            color: var(--success);
            font-weight: 700;
            font-size: 0.7rem;
        }
        
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: var(--bg); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
        
        .version-badge {
            background: var(--accent);
            color: #fff;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 0.45rem;
            margin-left: 4px;
        }
        
        .mode-badge {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            padding: 1px 4px;
            border-radius: 6px;
            font-size: 0.5rem;
            margin-left: 4px;
        }
        .mode-hunt { background: rgba(0,255,157,0.2); color: var(--success); }
        .mode-flee { background: rgba(255,85,119,0.2); color: var(--danger); }
        .mode-explore { background: rgba(0,212,255,0.2); color: var(--primary); }
        .mode-combat { background: rgba(255,170,0,0.2); color: var(--warning); }
        .mode-avoid { background: rgba(170,136,255,0.2); color: var(--purple); }
        
        .debug-panel {
            background: rgba(0,0,0,0.4);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 6px;
            font-size: 0.55rem;
            display: none;
        }
        .debug-panel.active { display: block; }
        .debug-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2px 4px;
        }
        .debug-item { display: flex; justify-content: space-between; }
        .debug-label { color: #888; }
        .debug-value { color: var(--primary); font-weight: 600; }
        .debug-value.good { color: var(--success); }
        .debug-value.bad { color: var(--danger); }
        
        .agent-card {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 6px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            margin-bottom: 6px;
        }
        .agent-card.blue { border-left: 3px solid var(--primary); }
        .agent-card.red { border-left: 3px solid var(--accent); }
        .agent-header {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.65rem;
            font-weight: 600;
        }
        .health-bar {
            height: 3px;
            background: rgba(0,0,0,0.3);
            border-radius: 2px;
            overflow: hidden;
        }
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success), var(--primary));
            transition: width 0.2s;
        }
        .health-fill.low { background: linear-gradient(90deg, var(--danger), var(--warning)); }
        .agent-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.55rem;
            color: #aaa;
        }
        .agent-stats b { color: var(--text); }
        
        .skills-display {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 2px;
            margin-top: 3px;
        }
        .skill-item {
            text-align: center;
            font-size: 0.5rem;
        }
        .skill-bar {
            height: 2px;
            background: rgba(0,0,0,0.3);
            border-radius: 1px;
            margin-top: 1px;
            overflow: hidden;
        }
        .skill-fill {
            height: 100%;
            transition: width 0.3s;
        }
        .skill-hunt .skill-fill { background: var(--success); }
        .skill-flee .skill-fill { background: var(--danger); }
        .skill-combat .skill-fill { background: var(--warning); }
        .skill-explore .skill-fill { background: var(--primary); }
        .skill-avoid .skill-fill { background: var(--purple); }
        
        .confidence-meter {
            display: flex;
            align-items: center;
            gap: 3px;
            margin-top: 3px;
            font-size: 0.55rem;
        }
        .confidence-bar {
            flex: 1;
            height: 3px;
            background: rgba(0,0,0,0.3);
            border-radius: 2px;
            overflow: hidden;
        }
        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--danger), var(--warning), var(--success));
            transition: width 0.2s;
        }

        .stat-badge {
            display: inline-block;
            padding: 1px 3px;
            border-radius: 2px;
            font-size: 0.45rem;
            font-weight: bold;
            margin-right: 2px;
        }
        .stat-str { background: rgba(255, 68, 68, 0.2); color: var(--stat-str); border: 1px solid var(--stat-str); }
        .stat-spd { background: rgba(68, 68, 255, 0.2); color: var(--stat-spd); border: 1px solid var(--stat-spd); }
        .stat-hp { background: rgba(68, 255, 68, 0.2); color: var(--stat-hp); border: 1px solid var(--stat-hp); }
        .stat-dod { background: rgba(170, 136, 255, 0.2); color: var(--stat-dod); border: 1px solid var(--stat-dod); }
        
        .learning-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3px;
            margin-top: 4px;
        }
        .metric-item {
            background: rgba(0,0,0,0.2);
            padding: 3px 4px;
            border-radius: 4px;
            font-size: 0.5rem;
        }
        .metric-label { color: #888; display: block; }
        .metric-value { color: var(--learning-good); font-weight: 600; }
        .metric-value.degrading { color: var(--danger); }
        
        .learning-progress {
            display: flex;
            flex-direction: column;
            gap: 2px;
            margin-top: 4px;
        }
        .progress-row {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.5rem;
        }
        .progress-label { width: 70px; color: #888; }
        .progress-track {
            flex: 1;
            height: 3px;
            background: rgba(0,0,0,0.3);
            border-radius: 2px;
            overflow: hidden;
        }
        .progress-track.td .progress-fill { background: linear-gradient(90deg, var(--danger), var(--warning), var(--success)); }
        .progress-track.entropy .progress-fill { background: linear-gradient(90deg, var(--warning), var(--primary)); }
        .progress-track.pred .progress-fill { background: linear-gradient(90deg, var(--danger), var(--success)); }
        
        .separator {
            height: 1px;
            background: var(--border);
            margin: 6px 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéÆ AI ARENA <span class="version-badge">v3.2.2 FIXED</span></h1>
        <div class="fps-counter" id="fpsCounter">FPS: 60</div>
    </div>
    
    <div class="container">
        <canvas id="gameCanvas"></canvas>
        
        <noscript>
            <div style="grid-column:1/-1;padding:15px;background:var(--danger);color:#fff;text-align:center;font-size:0.7rem;">‚ö†Ô∏è –î–ª—è —Ä–∞–±–æ—Ç—ã AI Arena —Ç—Ä–µ–±—É–µ—Ç—Å—è JavaScript</div>
        </noscript>
        
        <div class="sidebar">
            <div class="panel">
                <div class="panel-title">üë• –ê–ì–ï–ù–¢–´</div>
                <div class="agent-card blue">
                    <div class="agent-header">
                        <span>üîµ BLUE</span>
                        <span class="mode-badge mode-explore" id="blue-mode">EXPLORE</span>
                    </div>
                    <div class="health-bar"><div class="health-fill" id="blue-health" style="width:100%"></div></div>
                    <div class="agent-stats">
                        <span>Reward: <b id="blue-reward">0.00</b></span>
                        <span>Wins: <b id="blue-wins">0</b></span>
                        <span>Gen: <b id="blue-gen">1</b></span>
                    </div>
                    <div style="font-size: 0.5rem; margin-top: 1px; color: #aaa;">
                        <span class="stat-badge stat-hp" id="blue-stat-hp">HP:100</span>
                        <span class="stat-badge stat-str" id="blue-stat-dmg">DMG:3</span>
                        <span class="stat-badge stat-spd" id="blue-stat-spd">SPD:15</span>
                        <span class="stat-badge stat-dod" id="blue-stat-dod">DOD:0%</span>
                    </div>
                    <div class="skills-display" id="blue-skills">
                        <div class="skill-item skill-hunt"><div class="skill-bar"><div class="skill-fill" style="width:30%"></div></div><div>H</div></div>
                        <div class="skill-item skill-flee"><div class="skill-bar"><div class="skill-fill" style="width:40%"></div></div><div>F</div></div>
                        <div class="skill-item skill-combat"><div class="skill-bar"><div class="skill-fill" style="width:20%"></div></div><div>C</div></div>
                        <div class="skill-item skill-explore"><div class="skill-bar"><div class="skill-fill" style="width:50%"></div></div><div>E</div></div>
                        <div class="skill-item skill-avoid"><div class="skill-bar"><div class="skill-fill" style="width:60%"></div></div><div>A</div></div>
                    </div>
                </div>
                <div class="agent-card red">
                    <div class="agent-header">
                        <span>üî¥ RED</span>
                        <span class="mode-badge mode-explore" id="red-mode">EXPLORE</span>
                    </div>
                    <div class="health-bar"><div class="health-fill" id="red-health" style="width:100%"></div></div>
                    <div class="agent-stats">
                        <span>Reward: <b id="red-reward">0.00</b></span>
                        <span>Wins: <b id="red-wins">0</b></span>
                        <span>Gen: <b id="red-gen">1</b></span>
                    </div>
                    <div style="font-size: 0.5rem; margin-top: 1px; color: #aaa;">
                        <span class="stat-badge stat-hp" id="red-stat-hp">HP:100</span>
                        <span class="stat-badge stat-str" id="red-stat-dmg">DMG:3</span>
                        <span class="stat-badge stat-spd" id="red-stat-spd">SPD:15</span>
                        <span class="stat-badge stat-dod" id="red-stat-dod">DOD:0%</span>
                    </div>
                    <div class="skills-display" id="red-skills">
                        <div class="skill-item skill-hunt"><div class="skill-bar"><div class="skill-fill" style="width:30%"></div></div><div>H</div></div>
                        <div class="skill-item skill-flee"><div class="skill-bar"><div class="skill-fill" style="width:40%"></div></div><div>F</div></div>
                        <div class="skill-item skill-combat"><div class="skill-bar"><div class="skill-fill" style="width:20%"></div></div><div>C</div></div>
                        <div class="skill-item skill-explore"><div class="skill-bar"><div class="skill-fill" style="width:50%"></div></div><div>E</div></div>
                        <div class="skill-item skill-avoid"><div class="skill-bar"><div class="skill-fill" style="width:60%"></div></div><div>A</div></div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title">üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê</div>
                <div class="stat-grid">
                    <div class="stat"><span class="stat-label">–≠–ø–∏–∑–æ–¥</span><span class="stat-value" id="episodeStat">0</span></div>
                    <div class="stat"><span class="stat-label">–®–∞–≥</span><span class="stat-value" id="stepStat">0</span></div>
                    <div class="stat"><span class="stat-label">–¢–æ—á–∫–∏</span><span class="stat-value" id="dotsStat">50</span></div>
                    <div class="stat"><span class="stat-label">–ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è</span><span class="stat-value" id="obstaclesStat">12</span></div>
                    <div class="stat"><span class="stat-label">–°—Ä. —Ñ–∏—Ç–Ω–µ—Å</span><span class="stat-value good" id="fitnessStat">0</span></div>
                    <div class="stat"><span class="stat-label">–õ—É—á—à–∏–π</span><span class="stat-value good" id="bestFitnessStat">0</span></div>
                </div>
                <div class="progress-bar"><div class="progress-fill" id="episodeProgress" style="width: 0%"></div></div>
            </div>

            <div class="panel">
                <div class="panel-title">üß† –û–ë–£–ß–ï–ù–ò–ï ‚Äî TD(Œª) + ACTOR-CRITIC</div>
                <div class="control-group">
                    <div class="control-label"><span>Learning Rate (Œ±)</span><span id="learningRateValue">0.005</span></div>
                    <input type="range" id="learningRate" min="0.001" max="0.05" step="0.001" value="0.005">
                </div>
                <div class="control-group">
                    <div class="control-label"><span>TD Lambda (Œª)</span><span id="lambdaValue">0.95</span></div>
                    <input type="range" id="lambda" min="0.8" max="0.99" step="0.01" value="0.95">
                </div>
                <div class="control-group">
                    <div class="control-label"><span>Discount (Œ≥)</span><span id="gammaValue">0.99</span></div>
                    <input type="range" id="gamma" min="0.9" max="0.999" step="0.001" value="0.99">
                </div>
                <div class="control-group">
                    <div class="control-label"><span>Entropy Coef</span><span id="entropyValue">0.01</span></div>
                    <input type="range" id="entropyCoeff" min="0.001" max="0.05" step="0.001" value="0.01">
                </div>
                <div class="control-group">
                    <div class="control-label"><span>Mutation Rate</span><span id="mutationRateValue">0.1</span></div>
                    <input type="range" id="mutationRate" min="0.05" max="0.3" step="0.01" value="0.1">
                </div>
                <div class="control-group">
                    <div class="control-label"><span>Skill Growth</span><span id="skillGrowthValue">0.04</span></div>
                    <input type="range" id="skillGrowth" min="0.01" max="0.1" step="0.01" value="0.04">
                </div>
                <div class="toggle"><input type="checkbox" id="enableTraining" checked><label for="enableTraining">TD(Œª) Learning</label></div>
                <div class="toggle"><input type="checkbox" id="enableCritic" checked><label for="enableCritic">Actor-Critic (Value Estimation)</label></div>
                <div class="toggle"><input type="checkbox" id="enablePolicySelector" checked><label for="enablePolicySelector">Learnable Behavior Policy</label></div>
                <div class="toggle"><input type="checkbox" id="enableEvolution" checked><label for="enableEvolution">Weight Mutation</label></div>
                <div class="toggle"><input type="checkbox" id="enableSkillEvolution" checked><label for="enableSkillEvolution">Skill Evolution</label></div>
                <div class="toggle"><input type="checkbox" id="enableMoE" checked><label for="enableMoE">Mixture-of-Experts + Load Balance</label></div>
                <div class="toggle"><input type="checkbox" id="enableConsolidation" checked><label for="enableConsolidation">Memory Consolidation</label></div>
                <div class="toggle"><input type="checkbox" id="enableFighting" checked><label for="enableFighting">–ë–æ–∏ –º–µ–∂–¥—É –∞–≥–µ–Ω—Ç–∞–º–∏</label></div>
                <div class="toggle"><input type="checkbox" id="enableRanged" checked><label for="enableRanged">–î–∏—Å—Ç–∞–Ω—Ü–∏–æ–Ω–Ω–æ–µ –æ—Ä—É–∂–∏–µ</label></div>
                <div class="toggle"><input type="checkbox" id="enableVisualization"><label for="enableVisualization">–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –Ω–µ–π—Ä–æ–Ω–æ–≤</label></div>
            </div>

            <div class="panel">
                <div class="panel-title">üìà METRICS ‚Äî –ß–¢–û –£–õ–£–ß–®–ê–ï–¢–°–Ø</div>
                <div class="learning-metrics">
                    <div class="metric-item">
                        <span class="metric-label">TD-Error</span>
                        <span class="metric-value" id="metricTDError">0.0000</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Pred.Error</span>
                        <span class="metric-value" id="metricPredError">0.000</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Entropy</span>
                        <span class="metric-value" id="metricEntropy">0.000</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Win Rate</span>
                        <span class="metric-value" id="metricWinRate">0.00</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Collection</span>
                        <span class="metric-value" id="metricCollection">0.00</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Survival</span>
                        <span class="metric-value" id="metricSurvival">0.00</span>
                    </div>
                </div>
                <div class="learning-progress">
                    <div class="progress-row">
                        <span class="progress-label">TD Learning</span>
                        <div class="progress-track td"><div class="progress-fill" id="progressTD" style="width:50%"></div></div>
                    </div>
                    <div class="progress-row">
                        <span class="progress-label">Exploration</span>
                        <div class="progress-track entropy"><div class="progress-fill" id="progressEntropy" style="width:50%"></div></div>
                    </div>
                    <div class="progress-row">
                        <span class="progress-label">Memory</span>
                        <div class="progress-track pred"><div class="progress-fill" id="progressPred" style="width:50%"></div></div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title">üéÆ –£–ü–†–ê–í–õ–ï–ù–ò–ï</div>
                <div class="btn-group">
                    <button class="btn-primary" id="btnStart">‚ñ∂ –°—Ç–∞—Ä—Ç</button>
                    <button class="btn-danger" id="btnReset">üîÑ –°–±—Ä–æ—Å</button>
                    <button class="btn-success" id="btnSave">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                    <button class="btn-secondary" id="btnLoad">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
                </div>
                <div class="btn-group-3" style="margin-top: 4px;">
                    <button class="btn-toggle" id="btnDebug">üîç Debug</button>
                    <button class="btn-toggle" id="btnVision">üëÅÔ∏è Vision</button>
                    <button class="btn-learning" id="btnMetrics">üìä Metrics</button>
                </div>
                <div class="btn-group" style="margin-top: 4px;">
                    <button class="btn-secondary" id="btnExport">üì§ –≠–∫—Å–ø–æ—Ä—Ç</button>
                    <button class="btn-secondary" id="btnPretrain">‚¨ÜÔ∏è Pretrain</button>
                    <button class="btn-secondary" id="btnImport">üì• –ò–º–ø–æ—Ä—Ç</button>
                </div>
                <input type="file" id="fileImport" accept=".json" style="display:none">
                <input type="file" id="filePretrain" accept=".json" style="display:none">
            </div>

            <div class="panel">
                <div class="panel-title">üé® –õ–ï–ì–ï–ù–î–ê</div>
                <div class="agent-legend">
                    <div class="legend-item"><div class="legend-color" style="background:#00d4ff"></div><span>–ê–≥–µ–Ω—Ç</span></div>
                    <div class="legend-item"><div class="legend-color" style="background:#00ff9d"></div><span>–¢–æ—á–∫–∞ (5)</span></div>
                    <div class="legend-item"><div class="legend-color" style="background:#ff66cc"></div><span>Scared (8)</span></div>
                    <div class="legend-item"><div class="legend-color" style="background:#ffaa00"></div><span>Rare (20)</span></div>
                    <div class="legend-item"><div class="legend-color" style="background:#4a4a7a"></div><span>–ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ</span></div>
                    <div class="legend-item"><div class="legend-color" style="background:var(--stat-str)"></div><span>–°–∏–ª–∞ (–ö—Ä–∞—Å–Ω—ã–π)</span></div>
                    <div class="legend-item"><div class="legend-color" style="background:var(--stat-spd)"></div><span>–°–∫–æ—Ä–æ—Å—Ç—å (–°–∏–Ω–∏–π)</span></div>
                    <div class="legend-item"><div class="legend-color" style="background:var(--stat-hp)"></div><span>–ó–¥–æ—Ä–æ–≤—å–µ (–ó–µ–ª–µ–Ω—ã–π)</span></div>
                    <div class="legend-item"><div class="legend-color" style="background:var(--learning-good)"></div><span>–£–ª—É—á—à–µ–Ω–∏–µ</span></div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title">üìù –õ–û–ì</div>
                <div class="log" id="eventLog"></div>
            </div>

            <div class="debug-panel" id="debugPanel">
                <div style="margin-bottom:4px;font-weight:600;color:var(--primary);font-size:0.6rem">üîç INSPECTOR ‚Äî v3.2.2</div>
                <div class="debug-grid" id="debugGrid">
                    <div class="debug-item"><span class="debug-label">Mode</span><span class="debug-value" id="dbgMode">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Target</span><span class="debug-value" id="dbgTarget">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Speed</span><span class="debug-value" id="dbgSpeed">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Aggro</span><span class="debug-value" id="dbgAggro">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Memory</span><span class="debug-value" id="dbgMemory">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Neurons</span><span class="debug-value" id="dbgNeurons">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Reward</span><span class="debug-value" id="dbgReward">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Stuck</span><span class="debug-value" id="dbgStuck">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Confidence</span><span class="debug-value" id="dbgConf">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">TD-Error</span><span class="debug-value" id="dbgTDErr">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Entropy</span><span class="debug-value" id="dbgEntropy">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Pred.Err</span><span class="debug-value" id="dbgPredErr">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">WinRate</span><span class="debug-value" id="dbgWinRate">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Collect</span><span class="debug-value" id="dbgCollection">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Gate[0]</span><span class="debug-value" id="dbgGate0">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Gate[1]</span><span class="debug-value" id="dbgGate1">‚Äî</span></div>
                </div>
                <div class="confidence-meter">
                    <span>Conf:</span>
                    <div class="confidence-bar"><div class="confidence-fill" id="dbgConfBar" style="width:50%"></div></div>
                    <span id="dbgConfVal">0.50</span>
                </div>
            </div>
        </div>
    </div>

<script>
/**
 * ============================================================================
 * AI ARENA v3.2.2 ‚Äî PROFESSIONAL FIXED (Minimal Changes)
 * ============================================================================
 * ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–´ –¢–û–õ–¨–ö–û –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –û–®–ò–ë–ö–ò
 * ‚úÖ –í–°–Ø –§–£–ù–ö–¶–ò–û–ù–ê–õ–¨–ù–û–°–¢–¨ –°–û–•–†–ê–ù–ï–ù–ê
 * ============================================================================
 */

// üîß –ì–õ–û–ë–ê–õ–¨–ù–ê–Ø –ü–ï–†–ï–ú–ï–ù–ù–ê–Ø settings ‚Äî –î–û –í–°–ï–• –ö–õ–ê–°–°–û–í
window.settings = {
    enableTraining: true, enableCritic: true, enablePolicySelector: true,
    enableEvolution: true, enableSkillEvolution: true, enableMoE: true,
    enableConsolidation: true, enableFighting: true, enableRanged: true,
    enableVisualization: false,
    learningRate: 0.005, lambda: 0.95, gamma: 0.99, entropyCoeff: 0.01,
    mutationRate: 0.1, skillGrowthRate: 0.04
};

const Utils = {
    clamp: (v, min, max) => Math.max(min, Math.min(max, v)),
    lerp: (a, b, t) => a + (b - a) * t,
    dist: (a, b) => Math.hypot(a.x - b.x, a.y - b.y),
    normalize: (x, y) => { const l = Math.hypot(x, y) || 1; return { x: x/l, y: y/l }; },
    tanh: x => { const e = Math.exp(2*x); return (e-1)/(e+1); },
    sigmoid: x => 1/(1+Math.exp(-x)),
    leakyRelu: (x, Œ±=0.01) => x > 0 ? x : Œ±*x,
    argmax: arr => arr.reduce((mi, v, i, a) => v > a[mi] ? i : mi, 0),
    rand: (min, max) => Math.random() * (max - min) + min,
    randInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
    safeNumber: (val, fallback = 0) => (typeof val === 'number' && isFinite(val)) ? val : fallback,
    
    // ‚úÖ FIX #1: Numerically stable softmax
    softmax: (arr, temp = 1) => {
        if (!arr || !arr.length) return [];
        const max = Math.max(...arr);
        const exps = arr.map(v => Math.exp(Math.min((v - max) / temp, 700)));
        const sum = exps.reduce((s,x)=>s+x,0) || 1e-10;
        return exps.map(e => e / sum);
    },
    
    // ‚úÖ FIX #1: Numerically stable logSoftmax  
    logSoftmax: (arr, temp = 1) => {
        if (!arr || !arr.length) return [];
        const max = Math.max(...arr);
        const logSumExp = max + Math.log(arr.reduce((s,x)=>s+Math.exp(Math.min((x-max)/temp, 700)),0) + 1e-10);
        return arr.map(v => ((v - max) / temp - logSumExp));
    },
    
    // ‚úÖ FIX #2: Safe policy gradient loss with zero-length check
    policyGradientLoss: (logProbs, advantages) => {
        if (!logProbs || !logProbs.length || !advantages || !advantages.length) return 0;
        const len = logProbs.length;
        return len > 0 ? -logProbs.reduce((sum, lp, i) => sum + lp * (advantages[i] || 0), 0) / len : 0;
    },
    
    entropyBonus: (probs) => {
        if (!probs || !probs.length) return 0;
        return -probs.reduce((sum, p) => {
            const safeP = Math.max(p, 1e-10);
            return sum + safeP * Math.log(safeP);
        }, 0);
    },
    
    moeLoadBalanceLoss: (gateProbs, expertUsage) => {
        if (!gateProbs || !gateProbs.length) return 0;
        const numExperts = gateProbs.length;
        const targetUsage = 1 / numExperts;
        return expertUsage.reduce((sum, usage, i) => {
            return sum + Math.pow((usage || 0) - targetUsage, 2);
        }, 0) / numExperts;
    },
    
    computeGAE: (rewards, values, nextValue, gamma = 0.99, lambda = 0.95) => {
        const advantages = [];
        let advantage = 0;
        for (let t = rewards.length - 1; t >= 0; t--) {
            const delta = rewards[t] + gamma * (t === rewards.length - 1 ? nextValue : values[t+1]) - values[t];
            advantage = delta + gamma * lambda * advantage;
            advantages.unshift(advantage);
        }
        return advantages;
    },
    
    tdError: (reward, value, nextValue, gamma = 0.99) => {
        return reward + gamma * nextValue - value;
    },
    
    _pointSegDist: (ax, ay, bx, by, cx, cy) => {
        const vx = bx - ax, vy = by - ay;
        const wx = cx - ax, wy = cy - ay;
        const c1 = vx*wx + vy*wy;
        if (c1 <= 0) return Math.hypot(cx-ax, cy-ay);
        const c2 = vx*vx + vy*vy;
        if (c2 <= c1) return Math.hypot(cx-bx, cy-by);
        const b = c1 / c2;
        const pbx = ax + b * vx, pby = ay + b * vy;
        return Math.hypot(cx-pbx, cy-pby);
    },
    
    hasLineOfSight: (a, b, walls, wallRadius=14) => {
        if (!walls || !walls.length) return true;
        for(const w of walls) {
            const d = Utils._pointSegDist(a.x, a.y, b.x, b.y, w.x, w.y);
            if (d < wallRadius + 2) return false;
        }
        return true;
    },
    
    projectInput: (rawInputs, embeddingWeights, bias, outputDim) => {
        const projected = new Array(outputDim).fill(0);
        for (let o = 0; o < outputDim; o++) {
            let sum = bias[o] || 0;
            for (let i = 0; i < rawInputs.length; i++) {
                sum += (rawInputs[i] || 0) * (embeddingWeights[i]?.[o] || 0);
            }
            projected[o] = Utils.leakyRelu(sum);
        }
        return projected;
    },
    
    hashSeed: (seed, i, j) => {
        let h = seed.split('').reduce((a,c,idx) => {
            return ((a * 31 + c.charCodeAt(0)) ^ (idx * 17 + i * 7919 + j * 104729)) % 2147483647;
        }, seed.length) || 12345;
        h = (h * 2654435761) >>> 0;
        return h / 4294967296;
    }
};

class SeededRNG {
    constructor(seed) {
        this.baseSeed = seed.split('').reduce((a,c,i) => {
            return ((a * 31 + c.charCodeAt(0)) ^ (i * 17)) % 2147483647;
        }, seed.length) || 12345;
        this.state = this.baseSeed;
        this.callCount = 0;
    }
    next() {
        let x = this.state ^ (this.callCount++);
        x ^= x >>> 12;
        x ^= x << 25;
        x ^= x >>> 27;
        this.state = x;
        return (x * 0x2545F4914F6CDD1D) >>> 0 / 4294967296;
    }
    deriveWeights(rows, cols, scale) {
        const weights = [];
        for (let i = 0; i < rows; i++) {
            const row = [];
            for (let j = 0; j < cols; j++) {
                const hash = Utils.hashSeed(this.baseSeed.toString(), i, j);
                row.push((hash * 2 - 1) * scale);
            }
            weights.push(row);
        }
        return weights;
    }
    deriveVector(length, scale) {
        const vec = [];
        for (let i = 0; i < length; i++) {
            const hash = Utils.hashSeed(this.baseSeed.toString(), i, 0);
            vec.push((hash * 2 - 1) * scale);
        }
        return vec;
    }
    reset() {
        this.state = this.baseSeed;
        this.callCount = 0;
    }
}

class NeuralNetwork {
    constructor(config) {
        this.inputDim = config.inputDim || 57;
        this.embeddingDim = config.embeddingDim || 24;
        this.hidden1 = config.hidden1 || 48;
        this.hidden2 = config.hidden2 || 36;
        this.outputDim = config.outputDim || 16;
        this.memoryDim = config.memoryDim || 16;
        this.seed = config.seed || 'default';
        this.rng = new SeededRNG(this.seed);
        
        this.inputEmbedding = this.rng.deriveWeights(this.inputDim, this.embeddingDim, 0.3);
        this.embeddingBias = this.rng.deriveVector(this.embeddingDim, 0.1);
        this.W1 = this.rng.deriveWeights(this.embeddingDim + this.memoryDim * 2, this.hidden1, 0.3);
        this.W2 = this.rng.deriveWeights(this.hidden1, this.hidden2, 0.2);
        this.W3 = this.rng.deriveWeights(this.hidden2, this.outputDim, 0.1);
        
        this.numHeads = config.numHeads || 4;
        this.headDim = Math.floor(this.hidden1 / this.numHeads);
        this.Wq = this.rng.deriveWeights(this.hidden1, this.hidden1, 0.08);
        this.Wk = this.rng.deriveWeights(this.hidden1, this.hidden1, 0.08);
        this.Wv = this.rng.deriveWeights(this.hidden1, this.hidden1, 0.08);
        this.Wo = this.rng.deriveWeights(this.hidden1, this.hidden1, 0.08);
        
        this.numExperts = config.numExperts || 4;
        this.expertDim = config.expertDim || 36;
        this.Wg = this.rng.deriveWeights(this.hidden2, this.numExperts, 0.12);
        this.expertW1 = [];
        this.expertW2 = [];
        for (let e = 0; e < this.numExperts; e++) {
            this.expertW1.push(this.rng.deriveWeights(this.hidden2, this.expertDim, 0.15));
            this.expertW2.push(this.rng.deriveWeights(this.expertDim, this.outputDim, 0.1));
        }
        
        this.eligibilityW1 = new Float32Array((this.embeddingDim + this.memoryDim*2) * this.hidden1).fill(0);
        this.eligibilityW2 = new Float32Array(this.hidden1 * this.hidden2).fill(0);
        this.eligibilityW3 = new Float32Array(this.hidden2 * this.outputDim).fill(0);
        this.eligibilityEmbedding = new Float32Array(this.inputDim * this.embeddingDim).fill(0);
        
        this.predictionErrors = new Float32Array(this.memoryDim).fill(0);
        this.consolidationBuffer = [];
        this.maxBuffer = 32;
        
        this.memoryPermanent = new Float32Array(this.memoryDim).fill(0);
        this.memoryPredictive = new Float32Array(this.memoryDim).fill(0);
        
        this.lr = config.lr || 0.005;
        this.hebbianRate = config.hebbianRate || 0.002;
        this.gamma = config.gamma || 0.99;
        this.lambda = config.lambda || 0.95;
        this.entropyCoeff = config.entropyCoeff || 0.01;
        
        this.trainingStats = {
            tdErrorHistory: [],
            predictionErrorHistory: [],
            policyEntropyHistory: [],
            loadBalanceHistory: [],
            winRate: 0,
            collectionRate: 0,
            survivalTime: 0,
            totalSteps: 0,
            avgRewardPerStep: 0
        };
        
        this.activeNeurons = [];
        this.lastInputs = null;
        this.lastEmbedded = null;
        this.lastHidden1 = null;
        this.lastHidden2 = null;
        this.lastOutput = null;
        this.lastGateProbs = null;
        this.lastAttentionWeights = null;
    }
    
    _embedInputs(rawInputs) {
        return Utils.projectInput(rawInputs, this.inputEmbedding, this.embeddingBias, this.embeddingDim);
    }
    
    // ‚úÖ FIX #3: Proper softmax-based attention
    _selfAttention(h1) {
        const Q = this._linMatMul(h1, this.Wq);
        const K = this._linMatMul(h1, this.Wk);
        const V = this._linMatMul(h1, this.Wv);
        const scale = 1 / Math.sqrt(Math.max(1, this.headDim));
        
        // Compute all raw scores first
        const rawScores = new Array(this.hidden1).fill(0);
        for (let i = 0; i < this.hidden1; i++) {
            let sum = 0;
            for (let j = 0; j < this.hidden1; j++) {
                sum += (Q[i] || 0) * (K[j] || 0) * scale;
            }
            rawScores[i] = sum;
        }
        // Apply proper softmax normalization
        const scores = Utils.softmax(rawScores, 1);
        
        const attended = new Array(this.hidden1).fill(0);
        for (let i = 0; i < this.hidden1; i++) {
            for (let j = 0; j < this.hidden1; j++) {
                attended[i] += (scores[j] || 0) * (V[j] || 0);
            }
        }
        const projected = this._linMatMul(attended, this.Wo);
        const output = h1.map((v, i) => Utils.lerp(v, v + (projected[i] || 0), 0.6));
        this.lastAttentionWeights = scores.slice();
        return output;
    }
    
    _matMul(vec, mat) {
        const out = [];
        for(let i=0; i<mat[0].length; i++) {
            let sum = 0;
            for(let j=0; j<vec.length; j++) sum += Utils.safeNumber(vec[j], 0) * Utils.safeNumber(mat[j][i], 0);
            out.push(Utils.tanh(sum));
        }
        return out;
    }

    _linMatMul(vec, mat) {
        const out = new Array(mat[0].length).fill(0);
        for(let i=0;i<mat[0].length;i++) {
            let sum = 0;
            for(let j=0;j<vec.length;j++) sum += Utils.safeNumber(vec[j], 0) * Utils.safeNumber(mat[j][i], 0);
            out[i] = sum;
        }
        return out;
    }
    
    forward(inputs) {
        if (!inputs || inputs.length !== this.inputDim) {
            inputs = new Array(this.inputDim).fill(0);
        }
        this.lastInputs = inputs.slice();
        const embedded = this._embedInputs(inputs);
        this.lastEmbedded = embedded.slice();
        const combined = [...embedded, ...this.memoryPermanent, ...this.memoryPredictive];
        let h1 = this._matMul(combined, this.W1);
        this.lastHidden1 = h1.slice();
        h1 = this._selfAttention(h1);
        const gateLogits = this._linMatMul(h1, this.Wg);
        const gateProbs = Utils.softmax(gateLogits, 0.7);
        this.lastGateProbs = gateProbs.slice();
        
        // ‚úÖ FIX #4: Deterministic top-k expert selection
        const expertScores = gateProbs.map((p, i) => ({idx: i, score: p}));
        expertScores.sort((a, b) => b.score - a.score);
        const activeExperts = expertScores.slice(0, Math.min(2, this.numExperts)).map(e => e.idx);
        
        let combinedOutput = new Array(this.outputDim).fill(0);
        let expertUsage = new Array(this.numExperts).fill(0);
        for (const e of activeExperts) {
            const h2_expert = this._matMul(h1, this.expertW1[e]);
            const expOut = this._matMul(h2_expert, this.expertW2[e]);
            for (let j = 0; j < combinedOutput.length; j++) {
                combinedOutput[j] += (expOut[j] || 0) * (gateProbs[e] || 0);
            }
            expertUsage[e] = gateProbs[e] || 0;
        }
        const loadBalanceLoss = Utils.moeLoadBalanceLoss(gateProbs, expertUsage);
        let h2 = this._matMul(h1, this.W2);
        this.lastHidden2 = h2.slice();
        let output = this._matMul(h2, this.W3);
        this.lastOutput = output.slice();
        const predictedMemory = h2.slice(0, this.memoryDim);
        for (let i = 0; i < this.memoryDim; i++) {
            const error = Math.abs(predictedMemory[i] - this.memoryPredictive[i]);
            this.predictionErrors[i] = Utils.lerp(this.predictionErrors[i], error, 0.1);
        }
        this.memoryPredictive = new Float32Array(predictedMemory);
        for (let i = 0; i < this.memoryDim; i++) {
            if (this.predictionErrors[i] > 0.3) {
                this.memoryPermanent[i] = Utils.lerp(this.memoryPermanent[i], predictedMemory[i], 0.15);
            } else {
                this.memoryPermanent[i] = Utils.lerp(this.memoryPermanent[i], predictedMemory[i], 0.02);
            }
        }
        this.activeNeurons = [...h1, ...h2, ...output]
            .map((v,i) => ({i, v: Utils.safeNumber(v, 0)}))
            .sort((a,b) => Math.abs(b.v) - Math.abs(a.v))
            .slice(0, 5)
            .map(n => n.i);
        return { 
            output: output.map(v => Utils.safeNumber(v, 0)), 
            gateLogits: gateLogits,
            gateProbs: gateProbs,
            loadBalanceLoss: loadBalanceLoss,
            memoryPermanent: Array.from(this.memoryPermanent),
            memoryPredictive: Array.from(this.memoryPredictive),
            predictionErrors: Array.from(this.predictionErrors),
            activeNeurons: this.activeNeurons,
            embedded: embedded,
            h1: h1,
            h2: h2,
            attentionWeights: this.lastAttentionWeights
        };
    }
    
    tdLearn(inputs, outputs, reward, value, nextValue, actionLogProbs = null) {
        const tdErr = Utils.tdError(reward, value, nextValue, this.gamma);
        this.trainingStats.tdErrorHistory.push(Math.abs(tdErr));
        if (this.trainingStats.tdErrorHistory.length > 100) this.trainingStats.tdErrorHistory.shift();
        this._updateEligibilityTraces(inputs, outputs);
        this._applyTDError(tdErr);
        if (actionLogProbs && actionLogProbs.length > 0) {
            const advantage = tdErr;
            const entropy = Utils.entropyBonus(Utils.softmax(outputs.map(o => o * 10), 1));
            const policyLoss = Utils.policyGradientLoss(actionLogProbs, [advantage]);
            const totalLoss = policyLoss - this.entropyCoeff * entropy;
            this.trainingStats.policyEntropyHistory.push(entropy);
            if (this.trainingStats.policyEntropyHistory.length > 100) this.trainingStats.policyEntropyHistory.shift();
        }
        this._consolidateMemories(reward);
        return {
            tdError: tdErr,
            avgTDError: this.trainingStats.tdErrorHistory.reduce((a,b)=>a+b,0)/Math.max(1, this.trainingStats.tdErrorHistory.length),
            avgPredictionError: Array.from(this.predictionErrors).reduce((a,b)=>a+b,0)/Math.max(1, this.predictionErrors.length)
        };
    }
    
    _updateEligibilityTraces(inputs, outputs) {
        const embedded = this._embedInputs(inputs);
        const combined = [...embedded, ...this.memoryPermanent, ...this.memoryPredictive];
        for (let i = 0; i < this.inputDim; i++) {
            for (let o = 0; o < this.embeddingDim; o++) {
                const idx = i * this.embeddingDim + o;
                this.eligibilityEmbedding[idx] = this.gamma * this.lambda * this.eligibilityEmbedding[idx] + (inputs[i] || 0) * (this.lastHidden1?.[o] || 0);
            }
        }
        for (let i = 0; i < combined.length; i++) {
            for (let o = 0; o < this.hidden1; o++) {
                const idx = i * this.hidden1 + o;
                this.eligibilityW1[idx] = this.gamma * this.lambda * this.eligibilityW1[idx] + (combined[i] || 0) * (this.lastHidden1?.[o] || 0);
            }
        }
        if (this.lastHidden1 && this.lastHidden2) {
            for (let i = 0; i < this.lastHidden1.length; i++) {
                for (let o = 0; o < this.hidden2; o++) {
                    const idx = i * this.hidden2 + o;
                    this.eligibilityW2[idx] = this.gamma * this.lambda * this.eligibilityW2[idx] + (this.lastHidden1[i] || 0) * (this.lastHidden2[o] || 0);
                }
            }
        }
        if (this.lastHidden2 && this.lastOutput) {
            for (let i = 0; i < this.lastHidden2.length; i++) {
                for (let o = 0; o < this.outputDim; o++) {
                    const idx = i * this.outputDim + o;
                    this.eligibilityW3[idx] = this.gamma * this.lambda * this.eligibilityW3[idx] + (this.lastHidden2[i] || 0) * (this.lastOutput[o] || 0);
                }
            }
        }
    }
    
    _applyTDError(tdErr) {
        const alpha = this.lr * Math.sign(tdErr);
        for (let i = 0; i < this.inputDim * this.embeddingDim; i++) {
            const row = Math.floor(i / this.embeddingDim);
            const col = i % this.embeddingDim;
            this.inputEmbedding[row][col] += alpha * this.eligibilityEmbedding[i];
            this.inputEmbedding[row][col] = Utils.clamp(this.inputEmbedding[row][col], -2, 2);
        }
        for (let i = 0; i < this.eligibilityW1.length; i++) {
            const row = Math.floor(i / this.hidden1);
            const col = i % this.hidden1;
            this.W1[row][col] += alpha * this.eligibilityW1[i];
            this.W1[row][col] = Utils.clamp(this.W1[row][col], -2, 2);
        }
        for (let i = 0; i < this.eligibilityW2.length; i++) {
            const row = Math.floor(i / this.hidden2);
            const col = i % this.hidden2;
            this.W2[row][col] += alpha * this.eligibilityW2[i];
            this.W2[row][col] = Utils.clamp(this.W2[row][col], -2, 2);
        }
        for (let i = 0; i < this.eligibilityW3.length; i++) {
            const row = Math.floor(i / this.outputDim);
            const col = i % this.outputDim;
            this.W3[row][col] += alpha * this.eligibilityW3[i];
            this.W3[row][col] = Utils.clamp(this.W3[row][col], -2, 2);
        }
    }
    
    // ‚úÖ FIX #5: Safe buffer mutation using filter
    _consolidateMemories(reward) {
        if (reward < 2) return;
        for (let i = 0; i < this.memoryDim; i++) {
            if (this.predictionErrors[i] > 0.25) {
                this.consolidationBuffer.push({
                    index: i,
                    value: this.memoryPredictive[i],
                    error: this.predictionErrors[i],
                    reward: reward,
                    priority: this.predictionErrors[i] * reward
                });
            }
        }
        if (this.consolidationBuffer.length > 0 && this.rng.next() < 0.1) {
            const totalPriority = this.consolidationBuffer.reduce((s, item) => s + item.priority, 0);
            let rand = this.rng.next() * totalPriority;
            let selected = this.consolidationBuffer[0];
            for (const item of this.consolidationBuffer) {
                rand -= item.priority;
                if (rand <= 0) { selected = item; break; }
            }
            this.memoryPermanent[selected.index] = Utils.lerp(this.memoryPermanent[selected.index], selected.value, 0.3);
            if (this.rng.next() < 0.5) {
                this.consolidationBuffer = this.consolidationBuffer.filter(item => item !== selected);
            }
        }
        if (this.consolidationBuffer.length > this.maxBuffer) {
            this.consolidationBuffer.sort((a,b) => b.priority - a.priority);
            this.consolidationBuffer.length = this.maxBuffer;
        }
    }
    
    updateDiagnostics(metrics) {
        if (metrics.win !== undefined) this.trainingStats.winRate = Utils.lerp(this.trainingStats.winRate, metrics.win ? 1 : 0, 0.05);
        if (metrics.collected !== undefined) this.trainingStats.collectionRate = Utils.lerp(this.trainingStats.collectionRate, metrics.collected ? 1 : 0, 0.05);
        if (metrics.survival !== undefined) this.trainingStats.survivalTime = Utils.lerp(this.trainingStats.survivalTime, metrics.survival, 0.02);
        if (metrics.reward !== undefined) this.trainingStats.avgRewardPerStep = Utils.lerp(this.trainingStats.avgRewardPerStep, metrics.reward, 0.01);
        this.trainingStats.totalSteps++;
    }
    
    mutate(rate = 0.1, strength = 0.1) {
        let mutations = 0;
        const mutateMat = (mat) => {
            for(let i=0; i<mat.length; i++) {
                for(let j=0; j<mat[i].length; j++) {
                    if (this.rng.next() < rate) {
                        mat[i][j] += (this.rng.next()*2-1)*strength;
                        mat[i][j] = Utils.clamp(mat[i][j], -2, 2);
                        mutations++;
                    }
                }
            }
        };
        mutateMat(this.inputEmbedding);
        mutateMat(this.W1); mutateMat(this.W2); mutateMat(this.W3);
        if (this.Wq) mutateMat(this.Wq);
        if (this.Wk) mutateMat(this.Wk);
        if (this.Wv) mutateMat(this.Wv);
        if (this.Wo) mutateMat(this.Wo);
        if (this.Wg) mutateMat(this.Wg);
        for (const ew1 of this.expertW1) mutateMat(ew1);
        for (const ew2 of this.expertW2) mutateMat(ew2);
        return mutations;
    }
    
    clone() {
        const clone = new NeuralNetwork({
            inputDim: this.inputDim, embeddingDim: this.embeddingDim,
            hidden1: this.hidden1, hidden2: this.hidden2,
            outputDim: this.outputDim, memoryDim: this.memoryDim,
            seed: this.seed + '_clone_' + Date.now(), 
            lr: this.lr, gamma: this.gamma, lambda: this.lambda,
            numHeads: this.numHeads, numExperts: this.numExperts
        });
        clone.inputEmbedding = this.inputEmbedding.map(r => r.slice());
        clone.embeddingBias = this.embeddingBias.slice();
        clone.W1 = this.W1.map(r => r.slice());
        clone.W2 = this.W2.map(r => r.slice());
        clone.W3 = this.W3.map(r => r.slice());
        if (this.Wq) clone.Wq = this.Wq.map(r => r.slice());
        if (this.Wk) clone.Wk = this.Wk.map(r => r.slice());
        if (this.Wv) clone.Wv = this.Wv.map(r => r.slice());
        if (this.Wo) clone.Wo = this.Wo.map(r => r.slice());
        if (this.Wg) clone.Wg = this.Wg.map(r => r.slice());
        clone.expertW1 = this.expertW1.map(m => m.map(r => r.slice()));
        clone.expertW2 = this.expertW2.map(m => m.map(r => r.slice()));
        clone.memoryPermanent = new Float32Array(this.memoryPermanent);
        clone.memoryPredictive = new Float32Array(this.memoryPredictive);
        clone.predictionErrors = new Float32Array(this.predictionErrors);
        // ‚úÖ FIX #21: Deep copy of training stats arrays
        clone.trainingStats = {
            ...this.trainingStats,
            tdErrorHistory: [...this.trainingStats.tdErrorHistory],
            predictionErrorHistory: [...this.trainingStats.predictionErrorHistory],
            policyEntropyHistory: [...this.trainingStats.policyEntropyHistory],
            loadBalanceHistory: [...this.trainingStats.loadBalanceHistory]
        };
        clone.eligibilityW1 = new Float32Array(this.eligibilityW1);
        clone.eligibilityW2 = new Float32Array(this.eligibilityW2);
        clone.eligibilityW3 = new Float32Array(this.eligibilityW3);
        clone.eligibilityEmbedding = new Float32Array(this.eligibilityEmbedding);
        return clone;
    }
    
    toJSON() {
        return {
            config: { 
                inputDim: this.inputDim, embeddingDim: this.embeddingDim,
                hidden1: this.hidden1, hidden2: this.hidden2,
                outputDim: this.outputDim, memoryDim: this.memoryDim,
                seed: this.seed, lr: this.lr, gamma: this.gamma, lambda: this.lambda,
                numHeads: this.numHeads, numExperts: this.numExperts
            },
            inputEmbedding: this.inputEmbedding.map(r=>r.slice()),
            embeddingBias: this.embeddingBias.slice(),
            W1: this.W1.map(r=>r.slice()), 
            W2: this.W2.map(r=>r.slice()), 
            W3: this.W3.map(r=>r.slice()),
            Wq: (this.Wq || []).map(r=>r.slice()),
            Wk: (this.Wk || []).map(r=>r.slice()),
            Wv: (this.Wv || []).map(r=>r.slice()),
            Wo: (this.Wo || []).map(r=>r.slice()),
            Wg: (this.Wg || []).map(r=>r.slice()),
            expertW1: this.expertW1.map(m => m.map(r=>r.slice())),
            expertW2: this.expertW2.map(m => m.map(r=>r.slice())),
            memoryPermanent: Array.from(this.memoryPermanent),
            memoryPredictive: Array.from(this.memoryPredictive),
            predictionErrors: Array.from(this.predictionErrors),
            trainingStats: this.trainingStats
        };
    }
    
    static fromJSON(data) {
        if (!data || !data.config) return new NeuralNetwork({});
        const nn = new NeuralNetwork(data.config);
        try {
            nn.inputEmbedding = (data.inputEmbedding || []).map(r => (r || []).slice());
            nn.embeddingBias = (data.embeddingBias || new Array(nn.embeddingDim).fill(0)).slice();
            nn.W1 = (data.W1 || []).map(r => (r || []).slice());
            nn.W2 = (data.W2 || []).map(r => (r || []).slice());
            nn.W3 = (data.W3 || []).map(r => (r || []).slice());
            if (data.Wq) nn.Wq = (data.Wq || []).map(r => (r || []).slice());
            if (data.Wk) nn.Wk = (data.Wk || []).map(r => (r || []).slice());
            if (data.Wv) nn.Wv = (data.Wv || []).map(r => (r || []).slice());
            if (data.Wo) nn.Wo = (data.Wo || []).map(r => (r || []).slice());
            if (data.Wg) nn.Wg = (data.Wg || []).map(r => (r || []).slice());
            if (data.expertW1) nn.expertW1 = data.expertW1.map(m => (m || []).map(r => (r || []).slice()));
            if (data.expertW2) nn.expertW2 = data.expertW2.map(m => (m || []).map(r => (r || []).slice()));
            nn.memoryPermanent = new Float32Array(data.memoryPermanent || new Array(nn.memoryDim).fill(0));
            nn.memoryPredictive = new Float32Array(data.memoryPredictive || new Array(nn.memoryDim).fill(0));
            nn.predictionErrors = new Float32Array(data.predictionErrors || new Array(nn.memoryDim).fill(0));
            if (data.trainingStats) nn.trainingStats = {...data.trainingStats};
        } catch(e) {
            console.warn('NeuralNetwork.fromJSON: error', e);
        }
        return nn;
    }
}

class CriticNetwork {
    constructor(config) {
        this.inputDim = config.inputDim || 57;
        this.embeddingDim = config.embeddingDim || 24;
        this.hidden = config.hidden || 32;
        this.seed = config.seed || 'critic_default';
        this.rng = new SeededRNG(this.seed);
        this.W1 = this.rng.deriveWeights(this.inputDim, this.hidden, 0.3);
        this.W2 = this.rng.deriveWeights(this.hidden, 1, 0.1);
        this.b1 = this.rng.deriveVector(this.hidden, 0.1);
        this.b2 = 0;
        this.lr = config.lr || 0.005;
        this.gamma = config.gamma || 0.99;
    }
    forward(inputs) {
        if (!inputs || inputs.length !== this.inputDim) inputs = new Array(this.inputDim).fill(0);
        const hidden = [];
        for (let o = 0; o < this.hidden; o++) {
            let sum = this.b1[o];
            for (let i = 0; i < inputs.length; i++) sum += (inputs[i] || 0) * (this.W1[i]?.[o] || 0);
            hidden.push(Utils.leakyRelu(sum));
        }
        let value = this.b2;
        for (let i = 0; i < this.hidden; i++) value += (hidden[i] || 0) * (this.W2[i]?.[0] || 0);
        return Utils.clamp(value, -10, 10);
    }
    update(inputs, reward, nextValue, alpha = null) {
        const currentValue = this.forward(inputs);
        const tdErr = Utils.tdError(reward, currentValue, nextValue, this.gamma);
        const lr = alpha || this.lr;
        const hidden = [];
        for (let o = 0; o < this.hidden; o++) {
            let sum = this.b1[o];
            for (let i = 0; i < inputs.length; i++) sum += (inputs[i] || 0) * (this.W1[i]?.[o] || 0);
            hidden.push(Utils.leakyRelu(sum));
        }
        for (let i = 0; i < this.hidden; i++) {
            this.W2[i][0] += lr * tdErr * (hidden[i] || 0);
            this.W2[i][0] = Utils.clamp(this.W2[i][0], -2, 2);
        }
        this.b2 += lr * tdErr;
        // ‚úÖ FIX #14: Always update input weights for better convergence
        for (let i = 0; i < this.inputDim; i++) {
            for (let o = 0; o < this.hidden; o++) {
                const grad = tdErr * (this.W2[o]?.[0] || 0) * (hidden[o] > 0 ? 1 : 0.01);
                this.W1[i][o] += lr * grad * (inputs[i] || 0);
                this.W1[i][o] = Utils.clamp(this.W1[i][o], -2, 2);
            }
        }
        return { tdError: tdErr, value: currentValue };
    }
    clone() {
        const clone = new CriticNetwork({
            inputDim: this.inputDim, embeddingDim: this.embeddingDim,
            hidden: this.hidden, seed: this.seed + '_clone', lr: this.lr, gamma: this.gamma
        });
        clone.W1 = this.W1.map(r => r.slice());
        clone.W2 = this.W2.map(r => r.slice());
        clone.b1 = this.b1.slice();
        clone.b2 = this.b2;
        return clone;
    }
    toJSON() {
        return {
            config: { inputDim: this.inputDim, hidden: this.hidden, seed: this.seed, lr: this.lr, gamma: this.gamma },
            W1: this.W1.map(r=>r.slice()),
            W2: this.W2.map(r=>r.slice()),
            b1: this.b1.slice(),
            b2: this.b2
        };
    }
    static fromJSON(data) {
        if (!data || !data.config) return new CriticNetwork({});
        const critic = new CriticNetwork(data.config);
        critic.W1 = (data.W1 || []).map(r => (r || []).slice());
        critic.W2 = (data.W2 || []).map(r => (r || []).slice());
        critic.b1 = (data.b1 || []).slice();
        critic.b2 = data.b2 ?? 0;
        return critic;
    }
}

class PolicySelector {
    constructor(config) {
        this.contextDim = config.contextDim || 8;
        this.skillEmbeddingDim = config.skillEmbeddingDim || 5;
        this.hidden = config.hidden || 24;
        this.numModes = config.numModes || 5;
        this.seed = config.seed || 'policy_default';
        this.rng = new SeededRNG(this.seed);
        this.W1 = this.rng.deriveWeights(this.contextDim + this.skillEmbeddingDim, this.hidden, 0.2);
        this.W2 = this.rng.deriveWeights(this.hidden, this.numModes, 0.15);
        this.b1 = this.rng.deriveVector(this.hidden, 0.1);
        this.lr = config.lr || 0.003;
        this.entropyCoeff = config.entropyCoeff || 0.02;
    }
    forward(context, skillEmbedding) {
        const combined = [...context, ...skillEmbedding];
        const hidden = [];
        for (let o = 0; o < this.hidden; o++) {
            let sum = this.b1[o];
            for (let i = 0; i < combined.length; i++) sum += (combined[i] || 0) * (this.W1[i]?.[o] || 0);
            hidden.push(Utils.leakyRelu(sum));
        }
        const logits = [];
        for (let m = 0; m < this.numModes; m++) {
            let sum = 0;
            for (let i = 0; i < this.hidden; i++) sum += (hidden[i] || 0) * (this.W2[i]?.[m] || 0);
            logits.push(sum);
        }
        const probs = Utils.softmax(logits, 0.8);
        return { logits, probs, hidden };
    }
    update(context, skillEmbedding, selectedMode, advantage, entropyBonus = true) {
        const { logits, probs, hidden } = this.forward(context, skillEmbedding);
        const logProb = Math.log(Math.max(probs[selectedMode], 1e-10));
        const policyLoss = -logProb * advantage;
        let entropy = 0;
        if (entropyBonus) entropy = Utils.entropyBonus(probs);
        const totalLoss = policyLoss - this.entropyCoeff * entropy;
        const lr = this.lr * Math.sign(advantage);
        for (let i = 0; i < this.hidden; i++) {
            for (let m = 0; m < this.numModes; m++) {
                const targetGrad = (m === selectedMode ? 1 : 0) - probs[m];
                this.W2[i][m] += lr * advantage * targetGrad * (hidden[i] || 0);
                this.W2[i][m] = Utils.clamp(this.W2[i][m], -2, 2);
            }
        }
        return { loss: totalLoss, entropy, selectedProb: probs[selectedMode] };
    }
    clone() {
        const clone = new PolicySelector({
            contextDim: this.contextDim, skillEmbeddingDim: this.skillEmbeddingDim,
            hidden: this.hidden, numModes: this.numModes,
            seed: this.seed + '_clone', lr: this.lr
        });
        clone.W1 = this.W1.map(r => r.slice());
        clone.W2 = this.W2.map(r => r.slice());
        clone.b1 = this.b1.slice();
        return clone;
    }
    toJSON() {
        return {
            config: { contextDim: this.contextDim, skillEmbeddingDim: this.skillEmbeddingDim, hidden: this.hidden, numModes: this.numModes, seed: this.seed, lr: this.lr },
            W1: this.W1.map(r=>r.slice()),
            W2: this.W2.map(r=>r.slice()),
            b1: this.b1.slice()
        };
    }
    static fromJSON(data) {
        if (!data || !data.config) return new PolicySelector({});
        const ps = new PolicySelector(data.config);
        ps.W1 = (data.W1 || []).map(r => (r || []).slice());
        ps.W2 = (data.W2 || []).map(r => (r || []).slice());
        ps.b1 = (data.b1 || []).slice();
        return ps;
    }
}

class BehaviorArbiter {
    constructor() {
        this.modes = ['hunt', 'flee', 'explore', 'combat', 'avoid'];
    }
    decode(outputs) {
        return {
            hunt: Utils.clamp(Utils.safeNumber(outputs[0], 0), 0, 1),
            flee: Utils.clamp(Utils.safeNumber(outputs[1], 0), 0, 1),
            explore: Utils.clamp(Utils.safeNumber(outputs[2], 0), 0, 1),
            combat: Utils.clamp(Utils.safeNumber(outputs[3], 0), 0, 1),
            avoid: Utils.clamp(Utils.safeNumber(outputs[4], 0), 0, 1),
            speed: Utils.clamp(Utils.safeNumber(outputs[5], 0), 0, 1),
            curiosity: Utils.clamp(Utils.safeNumber(outputs[6], 0), 0, 1),
            aggression: Utils.clamp(Utils.safeNumber(outputs[7], 0), 0, 1),
            memoryWeight: Utils.clamp(Utils.safeNumber(outputs[8], 0), 0, 1),
        };
    }
    select(behaviors, context, skills = null, myStats = null, enemyStats = null) {
        const myPower = (myStats?.damage || 3) * (myStats?.maxHealth || 100);
        const enemyPower = (enemyStats?.damage || 3) * (enemyStats?.maxHealth || 100);
        if (enemyPower > myPower * 1.5 && context.enemyDistance < 150) {
            behaviors.flee *= 3.0;
            behaviors.combat *= 0.1;
        }
        else if (myPower > enemyPower * 1.2 && context.enemyDistance < 150) {
            behaviors.combat *= 2.5;
            behaviors.hunt *= 0.5;
        }
        else if (context.health < 0.3) {
            behaviors.flee *= 3.0;
            behaviors.combat *= 0.1;
        }
        else if (context.enemyDistance < 100 && context.health > 0.3) {
            behaviors.combat *= 2.0;
        }
        else {
            behaviors.combat *= 0.1;
        }
        if (context.wallDistance < 2.5) {
            behaviors.avoid *= 2.0;
        } else {
            behaviors.avoid *= 0.3;
        }
        if (skills) {
            const skillMap = {
                'hunt': skills.hunting ?? 0.5,
                'flee': skills.fleeing ?? 0.5,
                'explore': skills.exploring ?? 0.5,
                'combat': skills.combat ?? 0.5,
                'avoid': skills.avoiding ?? 0.5
            };
            for (const mode of this.modes) {
                const skill = skillMap[mode];
                behaviors[mode] *= (0.6 + skill * 0.8);
            }
        }
        const scores = this.modes.map(m => behaviors[m]);
        const mode = this.modes[Utils.argmax(scores)];
        return { mode, behaviors };
    }
    calculateTarget(mode, behaviors, agent, world, networkOutputs = null) {
        const { points, enemies, walls } = world;
        switch(mode) {
            case 'hunt': {
                let targets = points.filter(p => !p.collected);
                if (agent.permanent?.memory?.lastFoodPos && behaviors.memoryWeight > 0.5) {
                    const memAge = world.step - (agent.permanent.memory.lastFoodStep || 0);
                    if (memAge < 100) {
                        targets = [...targets, {
                            x: agent.permanent.memory.lastFoodPos.x, 
                            y: agent.permanent.memory.lastFoodPos.y, 
                            value: 1,
                            type: 'remembered'
                        }];
                    }
                }
                if (networkOutputs && networkOutputs.length >= 12) {
                    const dirBiasX = Utils.tanh(networkOutputs[9] || 0) * 30;
                    const dirBiasY = Utils.tanh(networkOutputs[10] || 0) * 30;
                    const priorityMod = (networkOutputs[11] || 0.5) * 2;
                    targets.forEach(t => {
                        t.x += dirBiasX * priorityMod * 0.15;
                        t.y += dirBiasY * priorityMod * 0.15;
                    });
                    targets.sort((a,b) => {
                        const distA = Utils.dist(agent, a) - (priorityMod * 10);
                        const distB = Utils.dist(agent, b) - (priorityMod * 10);
                        return distA - distB;
                    });
                } else {
                    targets.sort((a,b) => Utils.dist(agent, a) - Utils.dist(agent, b));
                }
                return targets[0] || {
                    x: Utils.clamp(agent.x + Utils.rand(-100,100), 25, 795), 
                    y: Utils.clamp(agent.y + Utils.rand(-75,75), 25, 575)
                };
            }
            case 'flee': {
                const threats = enemies.filter(e => e.id !== agent.id && e.alive);
                if (!threats.length) return {
                    x: Utils.clamp(agent.x + Utils.rand(-80,80), 25, 795), 
                    y: Utils.clamp(agent.y + Utils.rand(-60,60), 25, 575)
                };
                let threat = threats.reduce((n, e) => Utils.dist(agent, e) < Utils.dist(agent, n) ? e : n);
                if (agent.predictive?.predictedEnemy && agent.predictive?.confidence > 0.7) {
                    threat = {...threat, ...agent.predictive.predictedEnemy};
                }
                const away = Utils.normalize(agent.x - threat.x, agent.y - threat.y);
                if (networkOutputs && networkOutputs.length >= 12) {
                    const fleeBias = Utils.tanh(networkOutputs[9] || 0) * 0.3;
                    return {
                        x: agent.x + (away.x + fleeBias) * 40,
                        y: agent.y + (away.y + (networkOutputs[10] || 0) * 0.3) * 40
                    };
                }
                return {x: agent.x + away.x * 40, y: agent.y + away.y * 40};
            }
            case 'explore': {
                if (behaviors.curiosity > 0.7 && agent.permanent?.memory?.unvisited?.length) {
                    return agent.permanent.memory.unvisited[
                        Math.floor(Utils.rand(0, agent.permanent.memory.unvisited.length-1))
                    ];
                }
                if (networkOutputs && networkOutputs.length >= 12) {
                    return {
                        x: Utils.clamp(agent.x + Utils.tanh(networkOutputs[9]||0) * 120, 25, 795),
                        y: Utils.clamp(agent.y + Utils.tanh(networkOutputs[10]||0) * 90, 25, 575)
                    };
                }
                return {
                    x: Utils.clamp(agent.x + Utils.rand(-120,120), 25, 795),
                    y: Utils.clamp(agent.y + Utils.rand(-90,90), 25, 575)
                };
            }
            case 'combat': {
                const targets = enemies.filter(e => e.id !== agent.id && e.alive);
                if (!targets.length) return {x: agent.x, y: agent.y};
                let target = targets.reduce((n, e) => Utils.dist(agent, e) < Utils.dist(agent, n) ? e : n);
                if (agent.predictive?.predictedEnemy && agent.predictive?.confidence > 0.65) {
                    target = {...target, ...agent.predictive.predictedEnemy};
                }
                return target;
            }
            case 'avoid': {
                const nearWalls = walls.filter(w => Utils.dist(agent, w) < 30);
                if (!nearWalls.length) return {x: agent.x, y: agent.y};
                const wall = nearWalls.reduce((n, w) => Utils.dist(agent, w) < Utils.dist(agent, n) ? w : n);
                const toWall = Utils.normalize(wall.x - agent.x, wall.y - agent.y);
                const tangent = {x: -toWall.y, y: toWall.x};
                if (networkOutputs && networkOutputs.length >= 12 && networkOutputs[9] < 0) {
                    return {x: agent.x - tangent.x * 25, y: agent.y - tangent.y * 25};
                }
                return {x: agent.x + tangent.x * 25, y: agent.y + tangent.y * 25};
            }
            default: return {x: agent.x, y: agent.y};
        }
    }
}

class SmartPoint {
    constructor(x, y, type='normal') {
        this.x = x; this.y = y;
        this.type = type;
        this.collected = false;
        this.value = type==='rare' ? 20 : (type==='scared' ? 8 : 5);
        this.fleeRadius = type==='scared' ? 7 : 0;
        this.color = type==='rare' ? '#ffaa00' : (type==='scared' ? '#ff66cc' : '#00ff9d');
        this.radius = type==='rare' ? 6 : 4;
        this.vx = 0; this.vy = 0;
    }
    update(nearestAgent, dt) {
        if (this.collected) return;
        if (this.type === 'scared' && nearestAgent && Utils.dist(this, nearestAgent) < this.fleeRadius) {
            const away = Utils.normalize(this.x - nearestAgent.x, this.y - nearestAgent.y);
            this.vx = Utils.lerp(this.vx, away.x * 1.5, 0.1);
            this.vy = Utils.lerp(this.vy, away.y * 1.5, 0.1);
        } else {
            this.vx = Utils.lerp(this.vx, Utils.rand(-0.3, 0.3), 0.02);
            this.vy = Utils.lerp(this.vy, Utils.rand(-0.3, 0.3), 0.02);
        }
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.x = Utils.clamp(this.x, 20, 800);
        this.y = Utils.clamp(this.y, 20, 580);
    }
    draw(ctx) {
        if (this.collected) return;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
        ctx.fill();
        if (this.type === 'rare') {
            ctx.strokeStyle = '#ffdd44';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }
}

class Projectile {
    constructor(x,y,vx,vy,owner,damage=3,life=80) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.owner = owner;
        this.damage = damage; this.life = life; this.alive = true; this.radius = 3;
    }
    update(dt) {
        this.x += this.vx * dt * 8;
        this.y += this.vy * dt * 8;
        this.life -= dt;
        if (this.life <= 0) this.alive = false;
    }
    draw(ctx) {
        if (!this.alive) return;
        ctx.fillStyle = '#ffdd44';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
        ctx.fill();
    }
}

class EnemyPredictor {
    constructor() {
        this.history = [];
        this.maxHistory = 50;
        this.patterns = {
            'movingRight': 0, 'movingLeft': 0, 'movingDown': 0, 'movingUp': 0,
            'fleeing': 0, 'aggressive': 0, 'unpredictable': 0
        };
    }
    recordMove(action, distance, health, aggression) {
        this.history.push({
            action: {...action},
            distance: distance,
            health: health,
            aggression: aggression,
            time: Date.now()
        });
        if (this.history.length > this.maxHistory) this.history.shift();
    }
    predictNextAction() {
        if (this.history.length < 5) return 'unpredictable';
        const recent = this.history.slice(-5);
        const avgX = recent.reduce((s, m) => s + (m.action?.fx || 0), 0) / recent.length;
        const avgY = recent.reduce((s, m) => s + (m.action?.fy || 0), 0) / recent.length;
        const avgAgg = recent.reduce((s, m) => s + (m.action?.aggression || 0.5), 0) / recent.length;
        if (Math.abs(avgAgg) > 0.7) return avgAgg > 0 ? 'aggressive' : 'fleeing';
        else if (Math.abs(avgX) > 0.6) return avgX > 0 ? 'movingRight' : 'movingLeft';
        else if (Math.abs(avgY) > 0.6) return avgY > 0 ? 'movingDown' : 'movingUp';
        return 'unpredictable';
    }
    getWeakpoints() {
        if (this.history.length < 5) return [];
        const recent = this.history.slice(-10);
        return recent.filter(m => m.health < 0.5).map(m => ({direction: m.action, health: m.health}));
    }
}

class StrategyMemory {
    constructor() {
        this.winningStrategies = [];
        this.fightHistory = {};
        this.maxStrategies = 20;
    }
    recordFight(opponentId, won, weights, tactics, accuracy) {
        if (!this.fightHistory[opponentId]) {
            this.fightHistory[opponentId] = {wins: 0, losses: 0, lastTactics: null, bestAccuracy: 0};
        }
        const hist = this.fightHistory[opponentId];
        if (won) { hist.wins++; hist.lastTactics = tactics; hist.bestAccuracy = Math.max(hist.bestAccuracy, accuracy || 0); }
        else { hist.losses++; }
    }
    saveWinningStrategy(weights, opponentId, tactics, accuracy) {
        if (accuracy > 0.65) {
            this.winningStrategies.push({
                weights: JSON.parse(JSON.stringify(weights)),
                against: opponentId,
                tactics: tactics,
                winRate: accuracy,
                timestamp: Date.now()
            });
            if (this.winningStrategies.length > this.maxStrategies) {
                this.winningStrategies.sort((a, b) => a.winRate - b.winRate);
                this.winningStrategies.shift();
            }
        }
    }
    loadSimilarStrategy(opponentId) {
        const strategies = this.winningStrategies.filter(s => s.against === opponentId);
        if (strategies.length > 0) return strategies[strategies.length - 1];
        return null;
    }
}

class Agent {
    constructor(id, x, y, color, seed) {
        this.id = id; this.x = x; this.y = y;
        this.color = color; this.vx = 0; this.vy = 0;
        this.stats = { maxHealth: 100, damage: 3, fireRate: 15, dodgeChance: 0.0 };
        this.health = this.stats.maxHealth;
        this.lastMutationType = null;
        this.seed = seed;
        this.numExperts = 4;
        this.net = new NeuralNetwork({
            inputDim: 57, embeddingDim: 24, hidden1: 48, hidden2: 36, outputDim: 16,
            memoryDim: 16, seed: seed + '_NET', lr: 0.005, gamma: 0.99, lambda: 0.95,
            numHeads: 4, numExperts: this.numExperts
        });
        this.critic = new CriticNetwork({
            inputDim: 57, embeddingDim: 24, hidden: 32,
            seed: seed + '_CRITIC', lr: 0.005, gamma: 0.99
        });
        this.policySelector = new PolicySelector({
            contextDim: 8, skillEmbeddingDim: 5, hidden: 24, numModes: 5,
            seed: seed + '_POLICY', lr: 0.003
        });
        this.experts = [];
        for (let i=0;i<this.numExperts;i++) {
            this.experts.push(new NeuralNetwork({
                inputDim: 57, embeddingDim: 24, hidden1: 48, hidden2: 36, outputDim: 16,
                memoryDim: 16, seed: seed + '_EXP_' + i, lr: 0.005, gamma: 0.99, lambda: 0.95,
                numHeads: 4
            }));
        }
        this.arbiter = new BehaviorArbiter();
        this.mode = 'explore';
        this.target = {x, y};
        this.speed = 1;
        this.stuckCounter = 0;
        this.lastPos = {x, y};
        this.cumulativeReward = 0;
        this.alive = true;
        this.skillEmbedding = [0.3, 0.4, 0.2, 0.5, 0.6];
        this.permanent = {
            skills: {
                hunting: 0.3 + Math.random()*0.2,
                fleeing: 0.4 + Math.random()*0.2,
                combat: 0.2 + Math.random()*0.2,
                exploring: 0.5,
                avoiding: 0.6
            },
            strategies: { huntPattern: 'direct', fleeDirection: 'away', combatStyle: 'direct' },
            preferences: { foodType: 'any', enemyType: 'any', territory: 'any' },
            muscleMemory: new Float32Array(16).fill(0),
            memory: { lastFoodPos: null, lastFoodStep: 0, visited: new Set(), unvisited: [] }
        };
        this.predictive = {
            shortTerm: { positions: [], actions: [], results: [], enemyHistory: [], foodHistory: [] },
            patterns: { enemyMovement: null, foodSpawn: null, dangerZones: new Map() },
            predictions: { enemyPos: {x:0, y:0}, foodPos: {x:0, y:0}, collision: false, success: 0.5 },
            confidence: 0.5, predictionError: 0
        };
        this.enemyPredictor = new EnemyPredictor();
        this.strategyMemory = new StrategyMemory();
        this.currentTactic = 'aggressive';
        this.fightStartTime = 0;
        this.fightOpponent = null;
        this.attackCooldown = 0;
        this.attackRange = 35;
        this.wins = 0; this.mutations = 0;
        this.generation = 1;
        this.trail = [];
        this.lastDecision = null;
        this.learningBuffer = {
            states: [], actions: [], rewards: [], nextStates: [], dones: [], values: [],
            maxBuffer: 32
        };
    }
    getInputs(world) {
        const inputs = [];
        const maxDist = Math.sqrt(820**2 + 600**2);
        
        // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–æ–≤–µ—Ä–∫–∞ world.points
        const points = (world.points || []).filter(p => p && !p.collected)
            .map(p => ({...p, d: Utils.dist(this, p)}))
            .sort((a,b) => a.d - b.d).slice(0,5);
        
        for(let i=0; i<5; i++) {
            const p = points[i];
            if (p) {
                const los = Utils.hasLineOfSight(this, p, world.walls || []) ? 1 : 0;
                inputs.push(Utils.clamp((p.x - this.x)/maxDist, -1, 1));
                inputs.push(Utils.clamp((p.y - this.y)/maxDist, -1, 1));
                inputs.push(Utils.clamp((100 - p.d)/100, 0, 1));
                inputs.push(los);
            } else { inputs.push(0,0,0,0); }
        }
        
        // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–æ–≤–µ—Ä–∫–∞ world.enemies
        const enemies = (world.enemies || []).filter(e => e && e.id !== this.id && e.alive)
            .map(e => ({...e, d: Utils.dist(this, e)}))
            .sort((a,b) => a.d - b.d).slice(0,5);
        
        for(let i=0; i<5; i++) {
            const e = enemies[i];
            if (e) {
                const los = Utils.hasLineOfSight(this, e, world.walls || []) ? 1 : 0;
                inputs.push(Utils.clamp((e.x - this.x)/maxDist, -1, 1));
                inputs.push(Utils.clamp((e.y - this.y)/maxDist, -1, 1));
                inputs.push(Utils.clamp((120 - e.d)/120, 0, 1));
                inputs.push(los);
            } else { inputs.push(0,0,0,0); }
        }
        
        // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–æ–≤–µ—Ä–∫–∞ world.walls
        const walls = (world.walls || []).map(w => ({...w, d: Utils.dist(this, w)}))
            .sort((a,b) => a.d - b.d).slice(0,3);
        
        for(let i=0; i<3; i++) {
            const w = walls[i];
            if (w) {
                inputs.push(Utils.clamp((w.x - this.x)/maxDist, -1, 1));
                inputs.push(Utils.clamp((w.y - this.y)/maxDist, -1, 1));
                inputs.push(Utils.clamp((60 - w.d)/60, 0, 1));
            } else { inputs.push(0,0,0); }
        }
        
        inputs.push(Utils.clamp((400 - this.x)/400, -1, 1));
        inputs.push(Utils.clamp((300 - this.y)/300, -1, 1));
        inputs.push(this.health / this.stats.maxHealth);
        inputs.push(Utils.clamp(world.step/2000, 0, 1));
        inputs.push(Utils.clamp((world.points || []).filter(p => p && !p.collected && Utils.dist(this,p)<120).length/15, 0, 1));
        inputs.push(Utils.clamp((world.enemies || []).filter(e => e && e.id!==this.id && e.alive && Utils.dist(this,e)<160).length/10, 0, 1));
        inputs.push(Utils.clamp(Math.min(this.x, 820-this.x, this.y, 600-this.y)/100, 0, 1));
        inputs.push(Utils.clamp(this.cumulativeReward/20, -1, 1));
        if (inputs.length !== 57) {
            while (inputs.length < 57) inputs.push(0);
            if (inputs.length > 57) inputs.length = 57;
        }
        return inputs.map(v => Utils.safeNumber(v, 0));
    }
    selectBehavior(world, networkOutput) {
        // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–æ–≤–µ—Ä–∫–∞ world.enemies
        const enemies = (world.enemies || []).filter(e => e && e.id !== this.id && e.alive);
        const context = [
            enemies.length > 0 ? Utils.clamp(Utils.dist(this, enemies[0]) / 200, 0, 1) : 1,
            (world.walls || []).length ? Utils.clamp(Math.min(...(world.walls || []).map(w => Utils.dist(this, w))) / 60, 0, 1) : 0,
            this.health / this.stats.maxHealth,
            Utils.clamp(networkOutput[5] || 0.5, 0, 1),
            Utils.clamp(networkOutput[6] || 0.5, 0, 1),
            Utils.clamp(networkOutput[7] || 0.5, 0, 1),
            this.permanent.skills.hunting,
            this.permanent.skills.fleeing
        ];
        const skillEmbedding = [
            this.permanent.skills.hunting, this.permanent.skills.fleeing,
            this.permanent.skills.combat, this.permanent.skills.exploring, this.permanent.skills.avoiding
        ];
        const { probs } = this.policySelector.forward(context, skillEmbedding);
        const modeIdx = Utils.argmax(probs);
        const modes = ['hunt', 'flee', 'explore', 'combat', 'avoid'];
        const selectedMode = modes[modeIdx];
        if (this.lastDecision?.advantage !== undefined) {
            this.policySelector.update(context, skillEmbedding, modeIdx, this.lastDecision.advantage);
        }
        return { mode: selectedMode, modeProbs: probs };
    }
    decide(world) {
        this.updatePredictiveMemory(world);
        const inputs = this.getInputs(world);
        const gateRes = this.net.forward(inputs);
        const output = gateRes.output;
        const { mode, modeProbs } = this.selectBehavior(world, output);
        this.mode = mode;
        const behaviors = {
            speed: Utils.clamp(Utils.safeNumber(output[5], 0), 0, 1),
            curiosity: Utils.clamp(Utils.safeNumber(output[6], 0), 1),
            aggression: Utils.clamp(Utils.safeNumber(output[7], 0), 1),
            memoryWeight: Utils.clamp(Utils.safeNumber(output[8], 0), 1),
        };
        // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–æ–≤–µ—Ä–∫–∞ world.enemies
        const enemies = (world.enemies || []).filter(e => e && e.id !== this.id && e.alive);
        const enemy = enemies.length > 0 ? enemies[0] : null;
        const context = {
            enemyDistance: enemy ? Utils.dist(this, enemy) : 999,
            wallDistance: (world.walls || []).length ? Math.min(...(world.walls || []).map(w => Utils.dist(this, w))) : 999,
            health: this.health / this.stats.maxHealth
        };
        let target = this.arbiter.calculateTarget(mode, behaviors, this, {
            points: world.points || [], enemies: world.enemies || [], walls: world.walls || []
        }, output);
        if (!target || typeof target.x !== 'number' || !isFinite(target.x) || 
            typeof target.y !== 'number' || !isFinite(target.y)) {
            target = {
                x: Utils.clamp(this.x + Utils.rand(-50, 50), 30, 790),
                y: Utils.clamp(this.y + Utils.rand(-50, 50), 30, 570)
            };
        }
        this.target = target;
        const confidenceMod = this.predictive.confidence > 0.7 ? 1.1 : (this.predictive.confidence < 0.4 ? 0.9 : 1);
        this.speed = Utils.lerp(this.speed, behaviors.speed * 2.5 * confidenceMod + 0.5, 0.08);
        if (mode === 'hunt' && behaviors.memoryWeight > 0.5) {
            const nearby = (world.points || []).filter(p => p && !p.collected && Utils.dist(this,p)<20);
            if (nearby.length && !this.permanent.memory.lastFoodPos) {
                this.permanent.memory.lastFoodPos = {...nearby[0]};
                this.permanent.memory.lastFoodStep = world.step;
            }
        }
        const cell = `${Math.floor(this.x/25)},${Math.floor(this.y/25)}`;
        if (!this.permanent.memory.visited.has(cell)) {
            this.permanent.memory.visited.add(cell);
            if (this.permanent.memory.unvisited.length > 60) this.permanent.memory.unvisited.shift();
            this.permanent.memory.unvisited.push({
                x: this.x + Utils.rand(-40,40), y: this.y + Utils.rand(-30,30)
            });
        }
        this.lastDecision = { 
            mode, behaviors, inputs, output, modeProbs,
            value: this.critic.forward(inputs),
            nextValue: null
        };
        return { target: this.target, speed: this.speed, mode, behaviors, inputs, output };
    }
    move(target, speed, walls, dt, networkOutputs = null) {
        const desired = Utils.normalize(target.x - this.x, target.y - this.y);
        const wallRep = this.getWallRepulsion(walls);
        let finalDir;
        if (wallRep.strength > 0.8) {
            const tangent = {x: -wallRep.y, y: wallRep.x};
            const noise = Utils.rand(-0.3, 0.3);
            finalDir = { x: tangent.x + noise, y: tangent.y + noise };
            const mag = Math.hypot(finalDir.x, finalDir.y) || 1;
            finalDir.x /= mag; finalDir.y /= mag;
        } else {
            finalDir = {
                x: Utils.lerp(desired.x, wallRep.x, wallRep.strength * 0.6),
                y: Utils.lerp(desired.y, wallRep.y, wallRep.strength * 0.6)
            };
            const mag = Math.hypot(finalDir.x, finalDir.y);
            if (mag < 0.1) finalDir = desired;
            else { finalDir.x /= mag; finalDir.y /= mag; }
        }
        if (this.currentTactic && this.currentTactic !== 'adaptive') {
            finalDir = this.executeTactic(finalDir, target, walls);
        }
        if (networkOutputs && networkOutputs.length >= 14) {
            const neuralModX = Utils.tanh(networkOutputs[12] || 0) * 0.2;
            const neuralModY = Utils.tanh(networkOutputs[13] || 0) * 0.2;
            finalDir.x = Utils.clamp(finalDir.x + neuralModX, -1, 1);
            finalDir.y = Utils.clamp(finalDir.y + neuralModY, -1, 1);
            const mag = Math.hypot(finalDir.x, finalDir.y) || 1;
            finalDir.x /= mag; finalDir.y /= mag;
        }
        const minSpeed = 0.3;
        const actualSpeed = Math.max(speed, minSpeed);
        this.vx = Utils.lerp(this.vx, finalDir.x * actualSpeed, 0.15);
        this.vy = Utils.lerp(this.vy, finalDir.y * actualSpeed, 0.15);
        if (Math.abs(this.vx) < 0.02) this.vx = finalDir.x * minSpeed;
        if (Math.abs(this.vy) < 0.02) this.vy = finalDir.y * minSpeed;
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        if (this.x < 20) { this.x = 20; this.vx *= -0.4; }
        if (this.x > 800) { this.x = 800; this.vx *= -0.4; }
        if (this.y < 20) { this.y = 20; this.vy *= -0.4; }
        if (this.y > 580) { this.y = 580; this.vy *= -0.4; }
        for(const w of walls) {
            if (Utils.dist(this, w) < 15) {
                const push = Utils.normalize(this.x - w.x, this.y - w.y);
                this.x += push.x * 0.6;
                this.y += push.y * 0.6;
                this.vx *= -0.25; this.vy *= -0.25;
            }
        }
    }
    executeTactic(direction, target, walls) {
        const tactic = this.currentTactic;
        let tacticDir = {...direction};
        // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü–æ–ª–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ window.game
        const enemies = (typeof window !== 'undefined' && window.game && window.game.world && window.game.world.enemies) ? 
            window.game.world.enemies.filter(e => e && e.id !== this.id && e.alive) : [];
        if (enemies.length > 0) {
            const enemy = enemies[0];
            const dist = Utils.dist(this, enemy);
            if (tactic === 'kite' && dist < 50) {
                const angle = Math.atan2(direction.y, direction.x) + Math.PI / 2;
                tacticDir = { x: Math.cos(angle) * 0.8, y: Math.sin(angle) * 0.8 };
            } else if (tactic === 'dodge' && dist < 40) {
                const angle = Math.atan2(direction.y, direction.x) + (Math.random() > 0.5 ? 1 : -1) * Math.PI / 3;
                tacticDir = { x: Math.cos(angle), y: Math.sin(angle) };
            } else if (tactic === 'defensive' && dist < 30) {
                const away = Utils.normalize(this.x - enemy.x, this.y - enemy.y);
                tacticDir = { x: away.x * 0.8, y: away.y * 0.8 };
            } else if (dist < 25) {
                const away = Utils.normalize(this.x - enemy.x, this.y - enemy.y);
                tacticDir = { x: away.x, y: away.y };
            }
        }
        const mag = Math.hypot(tacticDir.x, tacticDir.y) || 1;
        tacticDir.x /= mag; tacticDir.y /= mag;
        return tacticDir;
    }
    getWallRepulsion(walls) {
        let repulsion = {x:0, y:0};
        for(const w of walls) {
            const d = Utils.dist(this, w);
            if (d < 40) {
                const force = (40 - d) / 40;
                const away = Utils.normalize(this.x - w.x, this.y - w.y);
                repulsion.x += away.x * force;
                repulsion.y += away.y * force;
            }
        }
        const mag = Math.hypot(repulsion.x, repulsion.y);
        return mag > 0 ? {x: repulsion.x/mag, y: repulsion.y/mag, strength: Utils.clamp(mag, 0, 1)} : {x:0, y:0, strength:0};
    }
    calculateReward(world, decision) {
        let reward = 0;
        let collectedAny = false;
        for(const p of (world.points || [])) {
            if (p && !p.collected) {
                const d = Utils.dist(this, p);
                if (d < 18) {
                    p.collected = true;
                    reward += p.value;
                    collectedAny = true;
                }
            }
        }
        const veryNear = (world.points || []).find(p => p && !p.collected && Utils.dist(this, p) < 10);
        if (veryNear) { veryNear.collected = true; reward += veryNear.value; }
        const newCell = `${Math.floor(this.x/25)},${Math.floor(this.y/25)}`;
        if (!this.permanent.memory.visited.has(newCell)) reward += 0.06;
        if (decision?.target) {
            const prevDist = Utils.dist(this.lastPos, decision.target);
            const currDist = Utils.dist({x: this.x, y: this.y}, decision.target);
            if (currDist < prevDist - 0.5) reward += 0.02;
        }
        const moved = Math.hypot(this.x - this.lastPos.x, this.y - this.lastPos.y);
        if (moved < 0.6) {
            this.stuckCounter++;
            if (this.stuckCounter > 15) reward -= 0.1;
        } else { this.stuckCounter = 0; }
        if (Math.min(this.x, 820-this.x, this.y, 600-this.y) < 12) reward -= 0.03;
        reward -= (1 - this.health/this.stats.maxHealth) * 0.12;
        this.lastPos = {x: this.x, y: this.y};
        this.cumulativeReward += reward;
        return reward;
    }
    learn(reward, decision, nextInputs = null) {
        if (!decision) return;
        const currentValue = decision.value;
        const nextValue = nextInputs ? this.critic.forward(nextInputs) : 0;
        const criticResult = this.critic.update(decision.inputs, reward, nextValue);
        const tdResult = this.net.tdLearn(
            decision.inputs, decision.output, reward, currentValue, nextValue,
            decision.modeProbs ? Utils.logSoftmax(decision.modeProbs.map(p => Math.log(Math.max(p, 1e-10)) * 10), 1) : null
        );
        this.net.updateDiagnostics({
            win: null, collected: reward >= 5, survival: this.health / this.stats.maxHealth, reward: reward
        });
        if (reward > 3 && settings.enableSkillEvolution) {
            this.updatePermanentSkills(reward, decision.mode, settings.skillGrowthRate);
        }
        if (reward > 4) this.updateMuscleMemory(decision.output, reward);
        this.learningBuffer.states.push(decision.inputs);
        this.learningBuffer.actions.push(decision.output);
        this.learningBuffer.rewards.push(reward);
        this.learningBuffer.values.push(currentValue);
        if (this.learningBuffer.states.length >= this.learningBuffer.maxBuffer) {
            this._batchLearn();
        }
    }
    _batchLearn() {
        const advantages = Utils.computeGAE(
            this.learningBuffer.rewards, this.learningBuffer.values, 0,
            this.net.gamma, this.net.lambda
        );
        for (let t = 0; t < advantages.length; t++) {
            if (this.lastDecision?.modeProbs) {
                const modeIdx = ['hunt','flee','explore','combat','avoid'].indexOf(this.mode);
                if (modeIdx >= 0) {
                    this.policySelector.update([], this.skillEmbedding, modeIdx, advantages[t]);
                }
            }
        }
        this.learningBuffer = {
            states: [], actions: [], rewards: [], nextStates: [], dones: [], values: [],
            maxBuffer: this.learningBuffer.maxBuffer
        };
    }
    updatePermanentSkills(reward, mode, skillGrowthRate) {
        if (reward <= 3 || !settings.enableSkillEvolution) return;
        const skillMap = { 'hunt': 'hunting', 'flee': 'fleeing', 'combat': 'combat', 'explore': 'exploring', 'avoid': 'avoiding' };
        const skillKey = skillMap[mode];
        if (skillKey && this.permanent.skills[skillKey] !== undefined) {
            const correlations = {
                hunting: { combat: 0.4, exploring: 0.2 }, combat: { hunting: 0.4, fleeing: -0.3 },
                fleeing: { avoiding: 0.3, exploring: 0.1 }, exploring: { hunting: 0.2, avoiding: 0.1 },
                avoiding: { fleeing: 0.3, exploring: 0.1 }
            };
            const growth = skillGrowthRate * reward * 0.1;
            this.permanent.skills[skillKey] = Utils.clamp(this.permanent.skills[skillKey] + growth, 0, 1);
            if (correlations[skillKey]) {
                for (const [related, corr] of Object.entries(correlations[skillKey])) {
                    if (this.permanent.skills[related] !== undefined) {
                        const relatedGrowth = growth * corr * 0.5;
                        this.permanent.skills[related] = Utils.clamp(this.permanent.skills[related] + relatedGrowth, 0, 1);
                    }
                }
            }
            this.skillEmbedding = [
                this.permanent.skills.hunting, this.permanent.skills.fleeing,
                this.permanent.skills.combat, this.permanent.skills.exploring, this.permanent.skills.avoiding
            ];
        }
    }
    updateMuscleMemory(outputs, reward) {
        if (reward < 4) return;
        for (let i = 0; i < Math.min(16, outputs.length); i++) {
            const diff = Math.abs(outputs[i] - this.permanent.muscleMemory[i]);
            if (diff > 0.12 && Math.abs(outputs[i]) > 0.4) {
                this.permanent.muscleMemory[i] = Utils.lerp(this.permanent.muscleMemory[i], outputs[i], 0.06);
            }
        }
    }
    updatePredictiveMemory(world) {
        this.predictive.shortTerm.positions.push({x: this.x, y: this.y});
        if (this.predictive.shortTerm.positions.length > 20) this.predictive.shortTerm.positions.shift();
        // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–æ–≤–µ—Ä–∫–∞ world.enemies
        const enemies = (world.enemies || []).filter(e => e && e.id !== this.id && e.alive);
        if (enemies.length > 0) {
            const enemy = enemies[0];
            this.predictive.shortTerm.enemyHistory.push({x: enemy.x, y: enemy.y});
            if (this.predictive.shortTerm.enemyHistory.length > 5) this.predictive.shortTerm.enemyHistory.shift();
            const hist = this.predictive.shortTerm.enemyHistory;
            if (hist.length >= 2) {
                const [prev, last] = [hist[hist.length-2], hist[hist.length-1]];
                const dx = last.x - prev.x, dy = last.y - prev.y;
                this.predictive.predictions.enemyPos = { x: last.x + dx * 0.75, y: last.y + dy * 0.75 };
                const error = Utils.dist(enemy, this.predictive.predictions.enemyPos);
                this.predictive.predictionError = Utils.lerp(this.predictive.predictionError, error / 50, 0.1);
                const accuracy = Math.max(0, 1 - error / 100);
                this.predictive.confidence = Utils.lerp(this.predictive.confidence, accuracy, 0.05);
            }
        } else {
            this.predictive.confidence = Utils.lerp(this.predictive.confidence, 0.5, 0.02);
        }
        const nearbyFood = (world.points || []).filter(p => p && !p.collected && Utils.dist(this, p) < 80);
        if (nearbyFood.length > 0) {
            const food = nearbyFood[0];
            this.predictive.shortTerm.foodHistory.push({x: food.x, y: food.y});
            if (this.predictive.shortTerm.foodHistory.length > 3) this.predictive.shortTerm.foodHistory.shift();
            if (this.predictive.shortTerm.foodHistory.length >= 2) {
                const avgX = this.predictive.shortTerm.foodHistory.reduce((s, f) => s + f.x, 0) / this.predictive.shortTerm.foodHistory.length;
                const avgY = this.predictive.shortTerm.foodHistory.reduce((s, f) => s + f.y, 0) / this.predictive.shortTerm.foodHistory.length;
                this.predictive.predictions.foodPos = {x: avgX, y: avgY};
            }
        }
    }
    selectCombatTactic(enemyDistance, enemyHealth, myHealth, enemyPrediction) {
        const tactics = ['aggressive', 'kite', 'dodge', 'bait', 'defensive'];
        if (enemyPrediction === 'fleeing') return 'aggressive';
        else if (enemyPrediction === 'aggressive') return myHealth < 0.4 ? 'dodge' : 'kite';
        else if (enemyHealth < 0.3) return 'aggressive';
        else if (myHealth < 0.3) return 'defensive';
        else if (enemyDistance < 20) return 'bait';
        return 'adaptive';
    }
    decideCombatAction(enemy, world) {
        const distance = Utils.dist(this, enemy);
        const prediction = this.enemyPredictor.predictNextAction();
        this.currentTactic = this.selectCombatTactic(distance, enemy.health / enemy.stats.maxHealth, this.health / this.stats.maxHealth, prediction);
        this.fightOpponent = enemy.id;
        this.fightStartTime = Date.now();
        return this.currentTactic;
    }
    getLearningMetrics() {
        return {
            avgTDError: this.net.trainingStats.tdErrorHistory.reduce((a,b)=>a+b,0) / Math.max(1, this.net.trainingStats.tdErrorHistory.length),
            avgPredictionError: Array.from(this.net.predictionErrors).reduce((a,b)=>a+b,0) / Math.max(1, this.net.predictionErrors.length),
            avgPolicyEntropy: this.net.trainingStats.policyEntropyHistory.reduce((a,b)=>a+b,0) / Math.max(1, this.net.trainingStats.policyEntropyHistory.length),
            winRate: this.net.trainingStats.winRate,
            collectionRate: this.net.trainingStats.collectionRate,
            survivalTime: this.net.trainingStats.survivalTime,
            totalSteps: this.net.trainingStats.totalSteps
        };
    }
    evolve(mutationRate = 0.1) {
        if (!settings.enableEvolution) return 0;
        const mutations = this.net.mutate(mutationRate, 0.15);
        this.critic.W1.forEach(row => row.forEach((v,i) => {
            if (this.net.rng.next() < mutationRate) {
                row[i] += (this.net.rng.next()*2-1)*0.15;
                row[i] = Utils.clamp(row[i], -2, 2);
            }
        }));
        this.mutations += mutations;
        return mutations;
    }
    reset(x, y) {
        this.x = x; this.y = y; this.vx = 0; this.vy = 0;
        this.health = this.stats.maxHealth; this.stuckCounter = 0;
        this.lastPos = {x, y}; this.cumulativeReward = 0;
        this.mode = 'explore'; this.target = {x, y}; this.trail = [];
        this.predictive.confidence = 0.5; this.predictive.predictionError = 0;
        this.attackCooldown = 0;
        this.learningBuffer = { states: [], actions: [], rewards: [], nextStates: [], dones: [], values: [], maxBuffer: 32 };
        // ‚úÖ FIX #13: Clear predictive short-term memory
        this.predictive.shortTerm = { positions: [], actions: [], results: [], enemyHistory: [], foodHistory: [] };
    }
    draw(ctx, showVision = false, showTrail = true) {
        if (showTrail && this.trail.length > 1) {
            ctx.beginPath(); ctx.moveTo(this.trail[0].x, this.trail[0].y);
            for(let i=1; i<this.trail.length; i++) {
                const t = this.trail[i]; const alpha = 1 - t.age/80;
                ctx.strokeStyle = this.color + Math.floor(alpha * 40).toString(16).padStart(2, '0');
                ctx.lineTo(t.x, t.y);
            } ctx.stroke();
        }
        let drawColor = this.color;
        if (this.lastMutationType === 'dmg') drawColor = '#ff4444';
        else if (this.lastMutationType === 'spd') drawColor = '#4444ff';
        else if (this.lastMutationType === 'hp') drawColor = '#44ff44';
        else if (this.lastMutationType === 'dod') drawColor = '#aa88ff';
        ctx.fillStyle = drawColor; ctx.beginPath(); ctx.arc(this.x, this.y, 11, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.beginPath();
        ctx.moveTo(this.x, this.y); ctx.lineTo(this.x + this.vx*7, this.y + this.vy*7); ctx.stroke();
        const modeColors = { hunt: '#00ff9d', flee: '#ff5577', explore: '#00d4ff', combat: '#ffaa00', avoid: '#aa88ff' };
        ctx.strokeStyle = modeColors[this.mode] || '#888'; ctx.lineWidth = 2.5;
        ctx.beginPath(); ctx.arc(this.x, this.y, 15, 0, Math.PI*2); ctx.stroke();
        ctx.fillStyle = this.predictive.confidence > 0.7 ? '#00ff9d' : (this.predictive.confidence < 0.4 ? '#ff5577' : '#ffaa00');
        ctx.beginPath(); ctx.arc(this.x + 14, this.y - 14, 3, 0, Math.PI*2); ctx.fill();
        if (this.health < this.stats.maxHealth) {
            ctx.fillStyle = '#222'; ctx.fillRect(this.x-14, this.y-20, 28, 4);
            ctx.fillStyle = this.health > this.stats.maxHealth/2 ? '#00ff9d' : '#ff5577';
            ctx.fillRect(this.x-14, this.y-20, 28*(this.health/this.stats.maxHealth), 4);
        }
        ctx.fillStyle = '#fff'; ctx.font = '9px monospace'; ctx.textAlign = 'center';
        ctx.fillText(`HP:${Math.round(this.stats.maxHealth)} DMG:${this.stats.damage}`, this.x, this.y - 25);
        ctx.fillText(`SPD:${this.stats.fireRate} DOD:${Math.round(this.stats.dodgeChance*100)}%`, this.x, this.y - 16);
        ctx.textAlign = 'left';
        if (showVision && this.mode === 'hunt') {
            ctx.strokeStyle = 'rgba(0,255,157,0.25)'; ctx.fillStyle = 'rgba(0,255,157,0.08)';
            ctx.beginPath(); ctx.moveTo(this.x, this.y);
            ctx.arc(this.x, this.y, 70, Math.atan2(this.vy, this.vx)-0.5, Math.atan2(this.vy, this.vx)+0.5);
            ctx.closePath(); ctx.fill(); ctx.stroke();
        }
        ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.setLineDash([4,3]);
        ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.target.x, this.target.y); ctx.stroke();
        ctx.setLineDash([]);
        if (this.trail.length === 0 || this.trail[this.trail.length-1].age > 4) {
            this.trail.push({x: this.x, y: this.y, age: 0});
            if (this.trail.length > 35) this.trail.shift();
        }
        this.trail.forEach(t => t.age++);
    }
    getDebugInfo() {
        const metrics = this.getLearningMetrics();
        return {
            mode: this.mode, target: `${Math.round(this.target.x)},${Math.round(this.target.y)}`,
            speed: this.speed.toFixed(2), aggro: this.lastDecision?.behaviors?.aggression?.toFixed(2) || '‚Äî',
            memory: (this.permanent.memory.visited.size/100).toFixed(2),
            neurons: this.net.activeNeurons.slice(0,3).join(','),
            reward: this.cumulativeReward.toFixed(2), stuck: this.stuckCounter,
            confidence: this.predictive.confidence.toFixed(2),
            predError: metrics.avgPredictionError.toFixed(3),
            health: `${Math.round(this.health)}/${this.stats.maxHealth}`,
            mutations: this.mutations, generation: this.generation,
            tdError: metrics.avgTDError.toFixed(4),
            policyEntropy: metrics.avgPolicyEntropy.toFixed(3),
            winRate: metrics.winRate.toFixed(2), collectionRate: metrics.collectionRate.toFixed(2),
            gate0: this.net.lastGateProbs?.[0]?.toFixed(3) || '‚Äî',
            gate1: this.net.lastGateProbs?.[1]?.toFixed(3) || '‚Äî'
        };
    }
    clone() {
        const agent = new Agent(this.id, this.x, this.y, this.color, this.seed + '_clone_' + Date.now());
        agent.net = this.net.clone(); agent.critic = this.critic.clone();
        agent.policySelector = this.policySelector.clone();
        agent.experts = this.experts.map(e => e.clone());
        agent.health = this.health; agent.stats = {...this.stats};
        agent.lastMutationType = this.lastMutationType;
        agent.cumulativeReward = this.cumulativeReward;
        agent.wins = this.wins; agent.mutations = this.mutations;
        agent.generation = this.generation + 1;
        agent.permanent = {
            skills: {...this.permanent.skills}, strategies: {...this.permanent.strategies},
            preferences: {...this.permanent.preferences},
            muscleMemory: new Float32Array(this.permanent.muscleMemory),
            memory: {
                lastFoodPos: this.permanent.memory.lastFoodPos ? {...this.permanent.memory.lastFoodPos} : null,
                lastFoodStep: this.permanent.memory.lastFoodStep || 0,
                visited: new Set(this.permanent.memory.visited),
                unvisited: this.permanent.memory.unvisited.map(p => ({...p}))
            }
        };
        agent.predictive = {
            shortTerm: { positions: [], actions: [], results: [], enemyHistory: [], foodHistory: [] },
            patterns: { enemyMovement: null, foodSpawn: null, dangerZones: new Map() },
            predictions: { enemyPos: {x:0,y:0}, foodPos: {x:0,y:0}, collision: false, success: 0.5 },
            confidence: this.predictive.confidence, predictionError: this.predictive.predictionError
        };
        agent.skillEmbedding = this.skillEmbedding.slice();
        agent.attackCooldown = this.attackCooldown || 0;
        return agent;
    }
    toJSON() {
        return {
            id: this.id, seed: this.seed, x: this.x, y: this.y,
            health: this.health, stats: this.stats, lastMutationType: this.lastMutationType,
            cumulativeReward: this.cumulativeReward, wins: this.wins, mutations: this.mutations, generation: this.generation,
            net: this.net.toJSON(), critic: this.critic.toJSON(), policySelector: this.policySelector.toJSON(),
            experts: this.experts ? this.experts.map(e => e.toJSON()) : [],
            permanent: {
                skills: this.permanent.skills, strategies: this.permanent.strategies,
                preferences: this.permanent.preferences,
                muscleMemory: Array.from(this.permanent.muscleMemory),
                memory: {
                    lastFoodPos: this.permanent.memory.lastFoodPos, lastFoodStep: this.permanent.memory.lastFoodStep,
                    visited: Array.from(this.permanent.memory.visited).slice(0, 100),
                    unvisited: this.permanent.memory.unvisited.slice(0, 30)
                }
            },
            predictive: { confidence: this.predictive.confidence, predictionError: this.predictive.predictionError },
            skillEmbedding: this.skillEmbedding.slice(),
            strategyMemory: { winningStrategies: this.strategyMemory.winningStrategies.slice(0, 5), fightHistory: this.strategyMemory.fightHistory },
            trainingStats: this.net.trainingStats
        };
    }
    static fromJSON(data, color) {
        const agent = new Agent(data.id, data.x, data.y, color, data.seed);
        agent.net = NeuralNetwork.fromJSON(data.net);
        if (data.critic) agent.critic = CriticNetwork.fromJSON(data.critic);
        if (data.policySelector) agent.policySelector = PolicySelector.fromJSON(data.policySelector);
        if (data.experts && Array.isArray(data.experts) && data.experts.length) {
            agent.experts = data.experts.map(e => NeuralNetwork.fromJSON(e));
        }
        agent.health = data.health ?? 100;
        agent.stats = data.stats || { maxHealth: 100, damage: 3, fireRate: 15, dodgeChance: 0.0 };
        agent.lastMutationType = data.lastMutationType || null;
        agent.cumulativeReward = data.cumulativeReward ?? 0;
        agent.wins = data.wins ?? 0; agent.mutations = data.mutations ?? 0;
        agent.generation = data.generation ?? 1;
        if (data.permanent) {
            agent.permanent.skills = {...(data.permanent.skills || agent.permanent.skills)};
            agent.permanent.strategies = {...(data.permanent.strategies || agent.permanent.strategies)};
            agent.permanent.preferences = {...(data.permanent.preferences || agent.permanent.preferences)};
            if (data.permanent.muscleMemory) agent.permanent.muscleMemory = new Float32Array(data.permanent.muscleMemory);
            if (data.permanent.memory) {
                agent.permanent.memory.lastFoodPos = data.permanent.memory.lastFoodPos;
                agent.permanent.memory.lastFoodStep = data.permanent.memory.lastFoodStep || 0;
                agent.permanent.memory.visited = new Set(data.permanent.memory.visited || []);
                agent.permanent.memory.unvisited = data.permanent.memory.unvisited || [];
            }
        }
        if (data.strategyMemory) {
            agent.strategyMemory.winningStrategies = data.strategyMemory.winningStrategies || [];
            agent.strategyMemory.fightHistory = data.strategyMemory.fightHistory || {};
        }
        if (data.predictive) {
            agent.predictive.confidence = data.predictive.confidence ?? 0.5;
            agent.predictive.predictionError = data.predictive.predictionError ?? 0;
        }
        if (data.skillEmbedding) agent.skillEmbedding = data.skillEmbedding.slice();
        if (data.trainingStats) agent.net.trainingStats = {...data.trainingStats};
        return agent;
    }
}

class World {
    constructor(width, height) {
        this.width = width; 
        this.height = height;
        this.step = 0; 
        this.episode = 0;
        this.points = []; 
        this.walls = []; 
        this.enemies = [];
        this.projectiles = [];
        // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –£–±—Ä–∞–Ω–æ this.reset() –∏–∑ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞
    }
    
    reset() {
        this.step = 0; 
        this.points = []; 
        this.walls = [];
        for(let i=0; i<40; i++) this.points.push(new SmartPoint(35+Utils.rand(0,750), 35+Utils.rand(0,530), 'normal'));
        for(let i=0; i<8; i++) this.points.push(new SmartPoint(35+Utils.rand(0,750), 35+Utils.rand(0,530), 'scared'));
        for(let i=0; i<2; i++) this.points.push(new SmartPoint(35+Utils.rand(0,750), 35+Utils.rand(0,530), 'rare'));
        for(let i=0; i<12; i++) { this.walls.push({ x: 60+Utils.rand(0,700), y: 60+Utils.rand(0,460) }); }
        this.projectiles = [];
    }
    
    spawnAgents() {
        console.log('üîß Spawning agents...');
        try {
            this.enemies = [
                new Agent('blue', 120, 300, '#00d4ff', 'ARENA_V322_BLUE_' + Date.now()),
                new Agent('red', 700, 300, '#ff5577', 'ARENA_V322_RED_' + (Date.now()+1))
            ];
            console.log(`‚úÖ Agents created: ${this.enemies.length}`);
            console.log(`   Blue: ${this.enemies[0] ? 'OK' : 'NULL'}`);
            console.log(`   Red: ${this.enemies[1] ? 'OK' : 'NULL'}`);
        } catch (e) {
            console.error('‚ùå Failed to spawn agents:', e);
            this.enemies = [];
        }
    }
    
    update(dt) {
        this.step++;
        
        // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü–æ–ª–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤ –Ω–∞—á–∞–ª–µ
        if (!this.enemies || this.enemies.length < 2) {
            console.error('‚ùå World.update: Not enough enemies!', this.enemies);
            return { blue: null, red: null, pointsLeft: 0, episode: this.episode };
        }
        
        if (!this.enemies[0] || !this.enemies[1]) {
            console.error('‚ùå World.update: Enemies[0] or [1] is null!');
            return { blue: null, red: null, pointsLeft: 0, episode: this.episode };
        }
        
        // ‚úÖ FIX: Safe enemy access
const validEnemies = (this.enemies || []).filter(e => e && e.alive);
const nearestBlue = validEnemies.find(e => e.id === 'blue') || validEnemies[0] || null;
const nearestRed = validEnemies.find(e => e.id === 'red') || validEnemies[1] || null;

for(const p of this.points) {
    if (!nearestBlue || !nearestRed) {
        p.update(null, dt);
    } else {
        const nearest = Utils.dist(p, nearestBlue) < Utils.dist(p, nearestRed) ? nearestBlue : nearestRed;
        p.update(nearest?.alive ? nearest : null, dt);
    }
}
        
        
        for(const agent of this.enemies) {
            // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–æ–≤–µ—Ä–∫–∞ agent
            if (!agent) {
                console.warn('‚ö†Ô∏è Agent is null in update loop');
                continue;
            }
            if (!agent.alive) continue;
            
            // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–æ–≤–µ—Ä–∫–∞ world.enemies –≤ filter
            const enemies = (this.enemies || []).filter(e => e && e.id !== agent.id && e.alive);
            
            if (enemies.length > 0) {
                const enemy = enemies[0]; 
                const distance = Utils.dist(agent, enemy);
                if (distance < 150) {
                    agent.enemyPredictor.recordMove(
                        agent.lastDecision?.behaviors || {}, 
                        distance, 
                        enemy.health / enemy.stats.maxHealth, 
                        (agent.lastDecision?.behaviors?.aggression || 0.5)
                    );
                    if (distance < 100) agent.decideCombatAction(enemy, this);
                }
            }
            
            const decision = agent.decide(this);
            agent.move(decision.target, decision.speed, this.walls, dt, decision.output);
            agent.attackCooldown = Math.max(0, (agent.attackCooldown || 0) - 1);
            
            if (typeof settings !== 'undefined' && settings.enableFighting) {
                const opponents = (this.enemies || []).filter(e => e && e.id !== agent.id && e.alive);
                if (opponents.length > 0) {
                    const enemy = opponents[0]; 
                    const dist = Utils.dist(agent, enemy);
                    const range = agent.attackRange || 35;
                    
                    if (dist <= range) {
                        if ((agent.attackCooldown || 0) <= 0) {
                            const aggression = agent.lastDecision?.behaviors?.aggression || 0.5;
                            const skill = agent.permanent?.skills?.combat || 0.3;
                            const baseDmg = agent.stats.damage;
                            const damage = Math.floor(Utils.clamp(baseDmg * (0.8 + aggression * 0.4) * (0.7 + skill * 0.6), 1, 10));
                            const dodgeRoll = Math.random();
                            
                            if (dodgeRoll < enemy.stats.dodgeChance) { 
                                Logger.log(`üõ°Ô∏è ${enemy.id.toUpperCase()} —É–∫–ª–æ–Ω–∏–ª—Å—è!`, 'warn'); 
                            } else { 
                                enemy.health -= damage; 
                                Logger.log(`${agent.id.toUpperCase()} ‚Üí ${enemy.id.toUpperCase()} -${damage} HP`, 'info'); 
                            }
                            
                            agent.attackCooldown = agent.stats.fireRate;
                            
                            if (enemy.health <= 0) { 
                                enemy.health = 0; 
                                enemy.alive = false; 
                                Logger.log(`üè≥Ô∏è ${enemy.id.toUpperCase()} –ø–æ–≤–µ—Ä–∂–µ–Ω ${agent.id.toUpperCase()}`, 'success'); 
                            }
                        }
                    } else {
                        if (settings.enableRanged && (agent.attackCooldown || 0) <= 0) {
                            const aggr = agent.lastDecision?.behaviors?.aggression || 0.4;
                            if (aggr > 0.3 && dist > 50 && dist < 200) {
                                const dir = Utils.normalize(enemy.x - agent.x, enemy.y - agent.y);
                                const speed = 10 + Math.random()*4;
                                const dmg = Math.floor(Utils.clamp(agent.stats.damage * 0.5 * (0.8 + aggr * 0.8), 1, 5));
                                const p = new Projectile(agent.x + dir.x*12, agent.y + dir.y*12, dir.x*speed, dir.y*speed, agent.id, dmg, 80);
                                this.projectiles.push(p);
                                agent.attackCooldown = agent.stats.fireRate + 5;
                                Logger.log(`${agent.id.toUpperCase()} —Å—Ç—Ä–µ–ª—è–µ—Ç –ø–æ ${enemy.id.toUpperCase()} (-${dmg} HP)`, 'info');
                            }
                        }
                    }
                }
            }
            
            const reward = agent.calculateReward(this, decision);
            const nextInputs = agent.getInputs(this);
            agent.learn(reward, decision, nextInputs);
        }
        
        for(const p of this.projectiles) {
            if (!p.alive) continue; 
            p.update(dt);
            for(const w of this.walls) { 
                if (Utils.dist(p, w) < 14 + p.radius) { 
                    p.alive = false; 
                    break; 
                } 
            }
            if (!p.alive) continue;
            for(const e of this.enemies) {
                if (!e || !e.alive || e.id === p.owner) continue;
                if (Utils.dist(p, e) < 15) {
                    const dodgeRoll = Math.random();
                    if (dodgeRoll < e.stats.dodgeChance) { 
                        Logger.log(`üõ°Ô∏è ${e.id.toUpperCase()} —É–∫–ª–æ–Ω–∏–ª—Å—è –æ—Ç –ø—É–ª–∏!`, 'warn'); 
                    } else { 
                        e.health -= p.damage; 
                        Logger.log(`üéØ ${p.owner.toUpperCase()} ‚Üí ${e.id.toUpperCase()} -${p.damage} HP`, 'info'); 
                    }
                    p.alive = false;
                    if (e.health <= 0) { 
                        e.health = 0; 
                        e.alive = false; 
                        Logger.log(`üè≥Ô∏è ${e.id.toUpperCase()} —É–±–∏—Ç ${p.owner.toUpperCase()}`, 'success'); 
                    }
                    break;
                }
            }
        }
        this.projectiles = this.projectiles.filter(p => p.alive);
        
        const deadAgents = this.enemies.filter(a => a && !a.alive);
        if (deadAgents.length > 0) {
            this.episode++; 
            Logger.log(`üìä –≠–ø–∏–∑–æ–¥ ${this.episode} –∑–∞–≤–µ—Ä—à–µ–Ω`, 'info');
            for (const agent of deadAgents) {
                const winner = this.enemies.find(e => e && e.id !== agent.id && e.alive);
                if (winner && typeof settings !== 'undefined' && settings.enableEvolution) {
                    if (!winner.net || !winner.experts) { 
                        Logger.log(`‚ö†Ô∏è Winner ${winner.id} –Ω–µ –∏–º–µ–µ—Ç net/experts`, 'warn'); 
                        continue; 
                    }
                    const accuracy = winner.wins / (winner.wins + 1);
                    if (winner.net.W1 && winner.strategyMemory) {
                        winner.strategyMemory.saveWinningStrategy(winner.net.W1, agent.id, winner.currentTactic || 'aggressive', accuracy);
                    }
                    winner.wins++; 
                    winner.net.updateDiagnostics({ win: true });
                    Logger.log(`üèÜ ${winner.id.toUpperCase()} –ø–æ–±–µ–¥–∏–ª! –¢–∞–∫—Ç–∏–∫–∞: ${winner.currentTactic || 'aggressive'}`, 'success');
                    try {
                        const idx = this.enemies.findIndex(e => e && e.id === agent.id);
                        if (idx >= 0) {
                            if (!winner.net || !winner.experts || winner.experts.length === 0) { 
                                Logger.log(`‚ùå –ù–µ–ª—å–∑—è –∫–ª–æ–Ω–∏—Ä–æ–≤–∞—Ç—å ${winner.id}`, 'error'); 
                                continue; 
                            }
                            const child = winner.clone(); 
                            child.id = agent.id; 
                            child.seed = winner.seed + '_child_' + Date.now();
                            if (child.net && typeof child.net.mutate === 'function') { 
                                const muts = child.net.mutate(settings.mutationRate || 0.08, 0.12); 
                                child.mutations += muts; 
                            }
                            const statKeys = ['maxHealth', 'damage', 'fireRate', 'dodgeChance'];
                            const randomStatIdx = Math.floor(Math.random() * 4);
                            const statToMutate = statKeys[randomStatIdx]; 
                            const mutationValue = Utils.randInt(1, 4);
                            if (statToMutate === 'maxHealth') child.stats.maxHealth += mutationValue * 10;
                            else if (statToMutate === 'damage') child.stats.damage += mutationValue;
                            else if (statToMutate === 'fireRate') child.stats.fireRate = Math.max(5, child.stats.fireRate - mutationValue);
                            else if (statToMutate === 'dodgeChance') child.stats.dodgeChance = Math.min(0.5, child.stats.dodgeChance + mutationValue * 0.05);
                            child.lastMutationType = statToMutate;
                            Logger.log(`üß¨ –ú–£–¢–ê–¶–ò–Ø: ${statToMutate} +${mutationValue} (Gen ${child.generation})`, 'success');
                            child.reset(agent.id === 'blue' ? 120 : 700, 300); 
                            child.alive = true; 
                            this.enemies[idx] = child;
                        }
                    } catch(e) { 
                        Logger.log('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–º–µ–Ω–µ –∞–≥–µ–Ω—Ç–∞: ' + e.message, 'error'); 
                        console.error('Full error:', e); 
                    }
                }
            }
        }
        
        const active = (this.points || []).filter(p => p && !p.collected).length;
        if (active < 22 && this.step % 40 === 0) {
            const types = ['normal','normal','normal','scared','rare'];
            this.points.push(new SmartPoint(35+Utils.rand(0,750), 35+Utils.rand(0,530), types[Utils.randInt(0, types.length-1)]));
        }
        
        return { 
            blue: this.enemies[0], 
            red: this.enemies[1], 
            pointsLeft: (this.points || []).filter(p => p && !p.collected).length, 
            episode: this.episode 
        };
    }
    
    resetEpisode() {
        this.points.forEach(p => { if(p) p.collected = false; });
        this.enemies.forEach(a => { 
            if(a) { 
                a.reset(a.id === 'blue' ? 120 : 700, 300); 
                a.alive = true; 
            } 
        });
        Logger.log(`üîÑ –ù–æ–≤—ã–π —ç–ø–∏–∑–æ–¥ ${this.episode} –Ω–∞—á–∞–ª—Å—è`, 'info');
    }
    
    draw(ctx, vision = false, trail = true) {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        const grad = ctx.createLinearGradient(0,0,this.width,this.height);
        grad.addColorStop(0, '#0a0a15'); 
        grad.addColorStop(1, '#1a1a2e');
        ctx.fillStyle = grad; 
        ctx.fillRect(0, 0, this.width, this.height);
        ctx.strokeStyle = 'rgba(50,50,90,0.25)'; 
        ctx.lineWidth = 1;
        for(let x=0; x<this.width; x+=50) { 
            ctx.beginPath(); 
            ctx.moveTo(x,0); 
            ctx.lineTo(x,this.height); 
            ctx.stroke(); 
        }
        for(let y=0; y<this.height; y+=50) { 
            ctx.beginPath(); 
            ctx.moveTo(0,y); 
            ctx.lineTo(this.width,y); 
            ctx.stroke(); 
        }
        ctx.fillStyle = '#4a4a7a';
        for(const w of this.walls) { 
            ctx.beginPath(); 
            ctx.arc(w.x, w.y, 14, 0, Math.PI*2); 
            ctx.fill(); 
            ctx.strokeStyle = '#6a6a9a'; 
            ctx.lineWidth = 2; 
            ctx.stroke(); 
        }
        for(const p of this.points) { 
            if(p) p.draw(ctx); 
        }
        for(const pr of this.projectiles || []) { 
            if(pr) pr.draw(ctx); 
        }
        for(const a of this.enemies) { 
            if(a) a.draw(ctx, vision, trail); 
        }
        ctx.fillStyle = 'rgba(100,100,140,0.5)'; 
        ctx.font = '10px monospace';
        ctx.fillText(`Step: ${this.step} | Ep: ${this.episode}`, 12, this.height-12);
    }
}

const Logger = {
    _escape: str => String(str).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m])),
    _truncate: (str, max=180) => str.length > max ? str.slice(0,max) + '‚Ä¶' : str,
    log(msg, type='info') {
        const safeMsg = Logger._escape(Logger._truncate(msg));
        const safeType = ['info','success','warn','error','learning'].includes(type) ? type : 'info';
        const logEl = document.getElementById('eventLog');
        if (!logEl) {
            console.log(`[${safeType}] ${safeMsg}`);
            return;
        }
        const entry = document.createElement('div');
        entry.className = `log-entry ${safeType}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${safeMsg}`;
        logEl.insertBefore(entry, logEl.firstChild);
        while (logEl.children.length > 60) logEl.removeChild(logEl.lastChild);
        logEl.scrollTop = 0;
    }
};

class GameEngine {
    constructor() {
        console.log('üîß GameEngine constructor started...');
        this.canvas = document.getElementById('gameCanvas');
        if (!this.canvas) {
            console.error('‚ùå Canvas not found!');
            alert('–û—à–∏–±–∫–∞: Canvas —ç–ª–µ–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω!');
            return;
        }
        this.ctx = this.canvas.getContext('2d');
        if (!this.ctx) {
            console.error('‚ùå Canvas context not found!');
            alert('–û—à–∏–±–∫–∞: –ö–æ–Ω—Ç–µ–∫—Å—Ç canvas –Ω–µ –ø–æ–ª—É—á–µ–Ω!');
            return;
        }
        this.settings = {...window.settings};
        this.resize();
        console.log(`üìê Canvas size: ${this.canvas.width}x${this.canvas.height}`);
        
        // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –°–æ–∑–¥–∞–µ–º world –ë–ï–ó –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ reset
        this.world = new World(820, 600);
        
        this.running = false;
        this.lastTime = 0;
        this.fps = 60;
        this.vision = false;
        this.debug = false;
        this.showMetrics = true;
        this.selectedAgent = null;
        this.rafId = null;
        
        this._onResize = this._onResize.bind(this);
        this._onClick = this._onClick.bind(this);
        this.setupEvents();
        this.init();
        console.log('‚úÖ GameEngine constructor completed');
    }
    
    resize() {
        if (!this.canvas || !this.canvas.parentElement) {
            console.warn('‚ö†Ô∏è Canvas or parent not ready');
            return;
        }
        this.canvas.width = this.canvas.parentElement.clientWidth;
        this.canvas.height = this.canvas.parentElement.clientHeight;
    }
    
    _onResize() { this.resize(); }
    
    setupEvents() {
        console.log('üîß Setting up events...');
        window.addEventListener('resize', this._onResize);
        this.canvas.addEventListener('click', this._onClick);
        const btnStart = document.getElementById('btnStart');
        if (btnStart) {
            btnStart.onclick = () => this.toggle();
            console.log('‚úÖ btnStart handler set');
        } else {
            console.error('‚ùå btnStart not found!');
        }
        document.getElementById('btnReset').onclick = () => this.reset();
        document.getElementById('btnSave').onclick = () => this.save();
        document.getElementById('btnLoad').onclick = () => this.load();
        document.getElementById('btnExport').onclick = () => this.exportWeights();
        document.getElementById('btnPretrain').onclick = () => document.getElementById('filePretrain').click();
        document.getElementById('filePretrain').onchange = (e) => this.importPretrained(e);
        document.getElementById('btnImport').onclick = () => document.getElementById('fileImport').click();
        document.getElementById('fileImport').onchange = (e) => this.importWeights(e);
        document.getElementById('btnDebug').onclick = () => this.toggleDebug();
        document.getElementById('btnVision').onclick = () => { this.vision = !this.vision; this.updateBtns(); };
        document.getElementById('btnMetrics').onclick = () => { this.showMetrics = !this.showMetrics; this.updateBtns(); };
        
        const bindSlider = (id, key, displayId) => {
            const slider = document.getElementById(id);
            const display = document.getElementById(displayId);
            if (slider && display) {
                slider.oninput = (e) => {
                    this.settings[key] = parseFloat(e.target.value);
                    display.textContent = e.target.value;
                    if (this.world && this.world.enemies) {
                        this.world.enemies.forEach(a => {
                            if (a && a.net) { 
                                a.net.lr = this.settings.learningRate; 
                                a.net.lambda = this.settings.lambda; 
                                a.net.gamma = this.settings.gamma; 
                                a.net.entropyCoeff = this.settings.entropyCoeff; 
                            }
                            if (a && a.critic) a.critic.lr = this.settings.learningRate;
                            if (a && a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6;
                        });
                    }
                };
            }
        };
        bindSlider('learningRate', 'learningRate', 'learningRateValue');
        bindSlider('lambda', 'lambda', 'lambdaValue');
        bindSlider('gamma', 'gamma', 'gammaValue');
        bindSlider('entropyCoeff', 'entropyCoeff', 'entropyValue');
        bindSlider('mutationRate', 'mutationRate', 'mutationRateValue');
        bindSlider('skillGrowth', 'skillGrowthRate', 'skillGrowthValue');
        
        const bindToggle = (id, key) => {
            const toggle = document.getElementById(id);
            if (toggle) {
                toggle.onchange = (e) => { this.settings[key] = e.target.checked; };
            }
        };
        bindToggle('enableTraining', 'enableTraining');
        bindToggle('enableCritic', 'enableCritic');
        bindToggle('enablePolicySelector', 'enablePolicySelector');
        bindToggle('enableEvolution', 'enableEvolution');
        bindToggle('enableSkillEvolution', 'enableSkillEvolution');
        bindToggle('enableMoE', 'enableMoE');
        bindToggle('enableConsolidation', 'enableConsolidation');
        bindToggle('enableFighting', 'enableFighting');
        bindToggle('enableRanged', 'enableRanged');
        bindToggle('enableVisualization', 'enableVisualization');
        console.log('‚úÖ Events setup completed');
    }
    
    _onClick(e) {
        if (!this.debug) return;
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        let nearest = null, minD = 25;
        for(const a of this.world.enemies) {
            if (!a) continue;
            const d = Math.hypot(a.x - x, a.y - y);
            if (d < minD) { minD = d; nearest = a; }
        }
        this.selectedAgent = nearest;
        if (nearest) Logger.log(`üîç –í—ã–±—Ä–∞–Ω –∞–≥–µ–Ω—Ç ${nearest.id}`, 'info');
        this.updateDebugPanel();
    }
    
    init() {
        console.log('üîß Initializing world...');
        
        // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –Ø–≤–Ω—ã–π –≤—ã–∑–æ–≤ reset –∏ spawnAgents
        this.world.reset();
        console.log('üîß Spawning agents...');
        this.world.spawnAgents();
        
        // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü–æ–ª–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è
        if (!this.world.enemies) {
            console.error('‚ùå this.world.enemies is undefined!');
            alert('–û—à–∏–±–∫–∞: –º–∞—Å—Å–∏–≤ –∞–≥–µ–Ω—Ç–æ–≤ –Ω–µ —Å–æ–∑–¥–∞–Ω!');
            return;
        }
        
        if (this.world.enemies.length === 0) {
            console.error('‚ùå this.world.enemies is empty!');
            alert('–û—à–∏–±–∫–∞: –º–∞—Å—Å–∏–≤ –∞–≥–µ–Ω—Ç–æ–≤ –ø—É—Å—Ç!');
            return;
        }
        
        if (this.world.enemies.length < 2) {
            console.error(`‚ùå Not enough agents: ${this.world.enemies.length}`);
            alert(`–û—à–∏–±–∫–∞: —Å–æ–∑–¥–∞–Ω–æ —Ç–æ–ª—å–∫–æ ${this.world.enemies.length} –∞–≥–µ–Ω—Ç(–æ–≤)!`);
            return;
        }
        
        if (!this.world.enemies[0]) {
            console.error('‚ùå this.world.enemies[0] is null/undefined!');
            alert('–û—à–∏–±–∫–∞: –ø–µ—Ä–≤—ã–π –∞–≥–µ–Ω—Ç –Ω–µ —Å–æ–∑–¥–∞–Ω!');
            return;
        }
        
        if (!this.world.enemies[1]) {
            console.error('‚ùå this.world.enemies[1] is null/undefined!');
            alert('–û—à–∏–±–∫–∞: –≤—Ç–æ—Ä–æ–π –∞–≥–µ–Ω—Ç –Ω–µ —Å–æ–∑–¥–∞–Ω!');
            return;
        }
        
        console.log(`‚úÖ Agents spawned: ${this.world.enemies.length}`);
        console.log(`   Blue agent:`, this.world.enemies[0]);
        console.log(`   Red agent:`, this.world.enemies[1]);
        
        this.world.enemies.forEach(a => {
            if (!a) return;
            a.net.lr = this.settings.learningRate;
            a.net.lambda = this.settings.lambda;
            a.net.gamma = this.settings.gamma;
            if (a.critic) a.critic.lr = this.settings.learningRate;
            if (a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6;
        });
        
        this.updateStats();
        this.updateMetrics();
        Logger.log('üöÄ AI ARENA v3.2.2 PROFESSIONAL –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞', 'success');
        Logger.log('üîß TD(Œª) + Actor-Critic + Learnable Policy + MoE + Consolidation', 'success');
        Logger.log('üîë Seed-derived initialization: –∫–ª—é—á –∞–∫—Ç–∏–≤–Ω–æ –≤–ª–∏—è–µ—Ç –Ω–∞ –≤–µ—Å–∞', 'success');
        Logger.log('üìä Metrics: TD-Error‚Üì Pred-Error‚Üì Entropy‚Üì WinRate‚Üë', 'learning');
        
        // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ –∞–≥–µ–Ω—Ç—ã –∂–∏–≤—ã –ø–µ—Ä–µ–¥ –æ—Ç—Ä–∏—Å–æ–≤–∫–æ–π
        if (this.world.enemies[0] && this.world.enemies[1]) {
            this.world.draw(this.ctx, false, true);
            console.log('‚úÖ Init completed, first frame drawn');
        } else {
            console.error('‚ùå Cannot draw: agents are null!');
        }
    }
    
    toggle() {
        console.log('üîß Toggle called, current running:', this.running);
        this.running = !this.running;
        const btn = document.getElementById('btnStart');
        if (!btn) {
            console.error('‚ùå btnStart not found!');
            return;
        }
        btn.textContent = this.running ? '‚è∏ –ü–∞—É–∑–∞' : '‚ñ∂ –°—Ç–∞—Ä—Ç';
        btn.className = this.running ? 'btn-danger' : 'btn-primary';
        Logger.log(this.running ? '‚ñ∂ –°–∏–º—É–ª—è—Ü–∏—è –∑–∞–ø—É—â–µ–Ω–∞' : '‚è∏ –ü–∞—É–∑–∞', 'info');
        if (this.running) {
            this.lastTime = performance.now();
            console.log('üîÑ Starting loop...');
            this.loop();
        }
    }
    
    reset() {
        this.running = false;
        const btn = document.getElementById('btnStart');
        if (btn) {
            btn.textContent = '‚ñ∂ –°—Ç–∞—Ä—Ç';
            btn.className = 'btn-primary';
        }
        this.world = new World(820, 600);
        this.world.reset();
        this.world.spawnAgents();
        this.world.enemies.forEach(a => {
            if (!a) return;
            a.net.lr = this.settings.learningRate;
            a.net.lambda = this.settings.lambda;
            a.net.gamma = this.settings.gamma;
            if (a.critic) a.critic.lr = this.settings.learningRate;
            if (a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6;
        });
        this.episode = 0;
        Logger.log('üîÑ –°–∏–º—É–ª—è—Ü–∏—è —Å–±—Ä–æ—à–µ–Ω–∞', 'warn');
        this.updateStats();
        this.updateMetrics();
    }
    
    loop() {
        if (!this.running) return;
        if (!this.ctx || !this.world) {
            console.error('‚ùå Context or world lost!');
            this.running = false;
            return;
        }
        
        // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–æ–≤–µ—Ä–∫–∞ –µ—Å—Ç—å –ª–∏ –∞–≥–µ–Ω—Ç—ã –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
        if (!this.world.enemies || this.world.enemies.length < 2 || !this.world.enemies[0] || !this.world.enemies[1]) {
            console.error('‚ùå No valid agents in world! Stopping.');
            this.running = false;
            Logger.log('‚ùå –û—à–∏–±–∫–∞: –∞–≥–µ–Ω—Ç—ã –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –∏–ª–∏ –Ω–µ–≤–∞–ª–∏–¥–Ω—ã', 'error');
            return;
        }
        
        const now = performance.now();
        const dt = Math.min((now - this.lastTime) / 16.67, 3);
        this.fps = Math.round(1000 / (now - this.lastTime + 0.001));
        this.lastTime = now;
        
        const fpsEl = document.getElementById('fpsCounter');
        if (fpsEl) fpsEl.textContent = `FPS: ${this.fps}`;
        
        try {
            const state = this.world.update(dt);
            
            // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–µ—Ä–Ω—É–ª –ª–∏ update –≤–∞–ª–∏–¥–Ω—ã–π state
            if (!state || !state.blue || !state.red) {
                console.warn('‚ö†Ô∏è World.update returned invalid state');
            }
            
            this.world.draw(this.ctx, this.vision);
            this.updateStats(state);
            if (this.showMetrics) this.updateMetrics();
            if (this.debug) this.updateDebugPanel();
        } catch (e) {
            console.error('‚ùå Loop error:', e);
            console.error('   Stack:', e.stack);
            Logger.log(`‚ùå –û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ: ${e.message}`, 'error');
            this.running = false;
            return;
        }
        
        // ‚úÖ FIX #36: Store rafId for cancellation
        this.rafId = requestAnimationFrame(() => this.loop());
    }
    
    updateStats(state) {
        if (!state) {
            if (!this.world || !this.world.enemies || this.world.enemies.length < 2 || !this.world.enemies[0] || !this.world.enemies[1]) {
                console.warn('‚ö†Ô∏è Cannot update stats: not enough valid agents');
                return;
            }
            state = {
                blue: this.world.enemies[0],
                red: this.world.enemies[1],
                pointsLeft: this.world.points ? this.world.points.filter(p => p && !p.collected).length : 0,
                episode: this.world.episode
            };
        }
        
        const { blue, red, pointsLeft, episode } = state;
        
        // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–Ω—ã –ª–∏ –∞–≥–µ–Ω—Ç—ã
        if (!blue || !red) {
            console.error('‚ùå blue or red agent is null/undefined!');
            return;
        }
        
        const blueHealthEl = document.getElementById('blue-health');
        const redHealthEl = document.getElementById('red-health');
        if (blueHealthEl) blueHealthEl.style.width = `${(blue.health/blue.stats.maxHealth)*100}%`;
        if (redHealthEl) redHealthEl.style.width = `${(red.health/red.stats.maxHealth)*100}%`;
        
        const blueRewardEl = document.getElementById('blue-reward');
        const redRewardEl = document.getElementById('red-reward');
        if (blueRewardEl) blueRewardEl.textContent = blue.cumulativeReward.toFixed(2);
        if (redRewardEl) redRewardEl.textContent = red.cumulativeReward.toFixed(2);
        
        const updateMode = (el, mode) => {
            if (el) el.innerHTML = `<span class="mode-badge mode-${mode}">${mode.toUpperCase()}</span>`;
        };
        updateMode(document.getElementById('blue-mode'), blue.mode);
        updateMode(document.getElementById('red-mode'), red.mode);
        
        const blueWinsEl = document.getElementById('blue-wins');
        const redWinsEl = document.getElementById('red-wins');
        if (blueWinsEl) blueWinsEl.textContent = blue.wins;
        if (redWinsEl) redWinsEl.textContent = red.wins;
        
        const blueGenEl = document.getElementById('blue-gen');
        const redGenEl = document.getElementById('red-gen');
        if (blueGenEl) blueGenEl.textContent = blue.generation;
        if (redGenEl) redGenEl.textContent = red.generation;
        
        const episodeEl = document.getElementById('episodeStat');
        const stepEl = document.getElementById('stepStat');
        const dotsEl = document.getElementById('dotsStat');
        const obstaclesEl = document.getElementById('obstaclesStat');
        if (episodeEl) episodeEl.textContent = episode;
        if (stepEl) stepEl.textContent = this.world.step;
        if (dotsEl) dotsEl.textContent = pointsLeft;
        if (obstaclesEl) obstaclesEl.textContent = this.world.walls.length;
        
        const avgFit = (blue.cumulativeReward + red.cumulativeReward) / 2;
        const bestFit = Math.max(blue.cumulativeReward, red.cumulativeReward);
        const fitnessEl = document.getElementById('fitnessStat');
        const bestFitnessEl = document.getElementById('bestFitnessStat');
        if (fitnessEl) fitnessEl.textContent = avgFit.toFixed(1);
        if (bestFitnessEl) bestFitnessEl.textContent = bestFit.toFixed(1);
        
        const progressEl = document.getElementById('episodeProgress');
        if (progressEl) progressEl.style.width = `${(episode % 10) * 10}%`;
    }
    
    updateMetrics() {
        if (!this.showMetrics || !this.world || !this.world.enemies || this.world.enemies.length < 2 || !this.world.enemies[0] || !this.world.enemies[1]) return;
        const blue = this.world.enemies[0], red = this.world.enemies[1];
        const blueMetrics = blue.getLearningMetrics(), redMetrics = red.getLearningMetrics();
        const avgTD = (blueMetrics.avgTDError + redMetrics.avgTDError) / 2;
        const avgPred = (blueMetrics.avgPredictionError + redMetrics.avgPredictionError) / 2;
        const avgEnt = (blueMetrics.avgPolicyEntropy + redMetrics.avgPolicyEntropy) / 2;
        const avgWin = (blueMetrics.winRate + redMetrics.winRate) / 2;
        const avgColl = (blueMetrics.collectionRate + redMetrics.collectionRate) / 2;
        const avgSurv = (blueMetrics.survivalTime + redMetrics.survivalTime) / 2;
        
        const tdEl = document.getElementById('metricTDError');
        const predEl = document.getElementById('metricPredError');
        const entEl = document.getElementById('metricEntropy');
        const winEl = document.getElementById('metricWinRate');
        const collEl = document.getElementById('metricCollection');
        const survEl = document.getElementById('metricSurvival');
        
        if (tdEl) { tdEl.textContent = avgTD.toFixed(4); tdEl.className = `metric-value${avgTD < 0.5 ? ' good' : avgTD > 2 ? ' degrading' : ''}`; }
        if (predEl) { predEl.textContent = avgPred.toFixed(3); predEl.className = `metric-value${avgPred < 0.3 ? ' good' : avgPred > 0.7 ? ' degrading' : ''}`; }
        if (entEl) { entEl.textContent = avgEnt.toFixed(3); entEl.className = `metric-value${avgEnt > 0.1 && avgEnt < 0.8 ? ' good' : ''}`; }
        if (winEl) winEl.textContent = avgWin.toFixed(2);
        if (collEl) collEl.textContent = avgColl.toFixed(2);
        if (survEl) survEl.textContent = avgSurv.toFixed(2);
        
        const progressTDEl = document.getElementById('progressTD');
        const progressEntropyEl = document.getElementById('progressEntropy');
        const progressPredEl = document.getElementById('progressPred');
        if (progressTDEl) progressTDEl.style.width = `${Utils.clamp(100 - avgTD * 20, 0, 100)}%`;
        if (progressEntropyEl) progressEntropyEl.style.width = `${Utils.clamp(avgEnt * 100, 0, 100)}%`;
        if (progressPredEl) progressPredEl.style.width = `${Utils.clamp(100 - avgPred * 100, 0, 100)}%`;
    }
    
    updateDebugPanel() {
        const panel = document.getElementById('debugPanel');
        panel.classList.toggle('active', this.debug && this.selectedAgent);
        if (!this.debug || !this.selectedAgent) return;
        const info = this.selectedAgent.getDebugInfo();
        const setDebugValue = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value;
        };
        setDebugValue('dbgMode', info.mode);
        setDebugValue('dbgTarget', info.target);
        setDebugValue('dbgSpeed', info.speed);
        setDebugValue('dbgAggro', info.aggro);
        setDebugValue('dbgMemory', info.memory);
        setDebugValue('dbgNeurons', info.neurons);
        setDebugValue('dbgReward', info.reward);
        setDebugValue('dbgStuck', info.stuck);
        setDebugValue('dbgConf', info.confidence);
        setDebugValue('dbgTDErr', info.tdError);
        setDebugValue('dbgEntropy', info.policyEntropy);
        setDebugValue('dbgPredErr', info.predError);
        setDebugValue('dbgWinRate', info.winRate);
        setDebugValue('dbgCollection', info.collectionRate);
        setDebugValue('dbgGate0', info.gate0);
        setDebugValue('dbgGate1', info.gate1);
        const confBar = document.getElementById('dbgConfBar');
        const confVal = document.getElementById('dbgConfVal');
        if (confBar) confBar.style.width = `${(this.selectedAgent.predictive.confidence || 0.5) * 100}%`;
        if (confVal) confVal.textContent = info.confidence;
    }
    
    toggleDebug() {
        this.debug = !this.debug;
        const btn = document.getElementById('btnDebug');
        if (btn) btn.classList.toggle('active', this.debug);
        const panel = document.getElementById('debugPanel');
        if (panel) panel.classList.toggle('active', this.debug && this.selectedAgent);
        Logger.log(`üîç Debug ${this.debug?'–≤–∫–ª—é—á—ë–Ω':'–≤—ã–∫–ª—é—á–µ–Ω'}`, this.debug?'success':'info');
    }
    
    updateBtns() {
        const visionBtn = document.getElementById('btnVision');
        const metricsBtn = document.getElementById('btnMetrics');
        if (visionBtn) visionBtn.classList.toggle('active', this.vision);
        if (metricsBtn) metricsBtn.classList.toggle('active', this.showMetrics);
    }
    
    save() {
        try {
            const data = {
                version: '3.2.2',
                timestamp: Date.now(),
                settings: this.settings,
                world: {
                    episode: this.world.episode,
                    step: this.world.step,
                    points: this.world.points.map(p => ({x:p.x,y:p.y,type:p.type,collected:p.collected})),
                    walls: this.world.walls.map(w => ({x:w.x,y:w.y}))
                },
                agents: this.world.enemies.map(a => a ? a.toJSON() : null).filter(a => a)
            };
            localStorage.setItem('aiArenaV322Save', JSON.stringify(data));
            Logger.log('üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ (v3.2.2 Professional)', 'success');
        } catch(e) {
            if (e.name === 'QuotaExceededError') {
                Logger.log('üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ: –ø—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç —Ö—Ä–∞–Ω–∏–ª–∏—â–∞', 'error');
            } else {
                Logger.log(`‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: ${e.message}`, 'error');
            }
        }
    }
    
    load() {
        try {
            const raw = localStorage.getItem('aiArenaV322Save');
            if (!raw) { Logger.log('‚ùå –ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–π v3.2.2', 'error'); return; }
            const data = JSON.parse(raw);
            if (data.version !== '3.2.2') { Logger.log('‚ö†Ô∏è –¢—Ä–µ–±—É–µ—Ç—Å—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ v3.2.2', 'warn'); return; }
            this.settings = {...this.settings, ...data.settings};
            document.getElementById('learningRate').value = this.settings.learningRate;
            document.getElementById('lambda').value = this.settings.lambda;
            document.getElementById('gamma').value = this.settings.gamma;
            document.getElementById('entropyCoeff').value = this.settings.entropyCoeff;
            document.getElementById('mutationRate').value = this.settings.mutationRate;
            document.getElementById('skillGrowth').value = this.settings.skillGrowthRate;
            document.getElementById('learningRateValue').textContent = this.settings.learningRate;
            document.getElementById('lambdaValue').textContent = this.settings.lambda;
            document.getElementById('gammaValue').textContent = this.settings.gamma;
            document.getElementById('entropyValue').textContent = this.settings.entropyCoeff;
            document.getElementById('mutationRateValue').textContent = this.settings.mutationRate;
            document.getElementById('skillGrowthValue').textContent = this.settings.skillGrowthRate;
            this.world.episode = data.world?.episode || 0;
            this.world.step = data.world?.step || 0;
            this.world.points = data.world?.points.map(p => Object.assign(new SmartPoint(p.x,p.y,p.type), {collected:p.collected})) || [];
            this.world.walls = data.world?.walls || [];
            this.world.enemies = data.agents?.map((a,i) => a ? Agent.fromJSON(a, i===0?'#00d4ff':'#ff5577') : null).filter(a => a) || [];
            this.world.enemies.forEach(a => {
                if (!a) return;
                a.net.lr = this.settings.learningRate; a.net.lambda = this.settings.lambda; a.net.gamma = this.settings.gamma;
                if (a.critic) a.critic.lr = this.settings.learningRate;
                if (a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6;
            });
            Logger.log('üìÇ –ó–∞–≥—Ä—É–∂–µ–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ v3.2.2', 'success');
            this.updateStats({blue:this.world.enemies[0], red:this.world.enemies[1], pointsLeft:this.world.points.filter(p=>p&&!p.collected).length, episode:this.world.episode});
            this.updateMetrics();
        } catch(e) {
            Logger.log(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ${e.message}`, 'error');
        }
    }
    
    exportWeights() {
        try {
            const data = {
                version: '3.2.2',
                timestamp: Date.now(),
                blue: this.world.enemies[0] ? this.world.enemies[0].toJSON() : null,
                red: this.world.enemies[1] ? this.world.enemies[1].toJSON() : null
            };
            const blob = new Blob([JSON.stringify(data)], {type:'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `arena-v3.2.2-agents-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            Logger.log('üì§ –ê–≥–µ–Ω—Ç—ã —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã', 'success');
        } catch(e) {
            Logger.log(`‚ùå –û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞: ${e.message}`, 'error');
        }
    }
    
    importWeights(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                const data = JSON.parse(ev.target.result);
                if (data.version !== '3.2.2') throw new Error('–¢—Ä–µ–±—É–µ—Ç—Å—è —Ñ–æ—Ä–º–∞—Ç v3.2.2');
                if (data.blue) this.world.enemies[0] = Agent.fromJSON(data.blue, '#00d4ff');
                if (data.red) this.world.enemies[1] = Agent.fromJSON(data.red, '#ff5577');
                this.world.enemies.forEach(a => {
                    if (!a) return;
                    a.net.lr = this.settings.learningRate; a.net.lambda = this.settings.lambda; a.net.gamma = this.settings.gamma;
                    if (a.critic) a.critic.lr = this.settings.learningRate;
                    if (a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6;
                });
                Logger.log('üì• –ê–≥–µ–Ω—Ç—ã –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã', 'success');
            } catch(err) {
                Logger.log(`‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: ${err.message}`, 'error');
            }
        };
        reader.readAsText(file);
        e.target.value = '';
    }
    
    importPretrained(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                const data = JSON.parse(ev.target.result);
                if (data.blue && this.world.enemies[0]) {
                    const b = data.blue;
                    if (b.net) this.world.enemies[0].net = NeuralNetwork.fromJSON(b.net);
                    if (b.critic) this.world.enemies[0].critic = CriticNetwork.fromJSON(b.critic);
                    if (b.policySelector) this.world.enemies[0].policySelector = PolicySelector.fromJSON(b.policySelector);
                }
                if (data.red && this.world.enemies[1]) {
                    const r = data.red;
                    if (r.net) this.world.enemies[1].net = NeuralNetwork.fromJSON(r.net);
                    if (r.critic) this.world.enemies[1].critic = CriticNetwork.fromJSON(r.critic);
                    if (r.policySelector) this.world.enemies[1].policySelector = PolicySelector.fromJSON(r.policySelector);
                }
                this.world.enemies.forEach(a => {
                    if (!a) return;
                    a.net.lr = this.settings.learningRate; a.net.lambda = this.settings.lambda; a.net.gamma = this.settings.gamma;
                    if (a.critic) a.critic.lr = this.settings.learningRate;
                    if (a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6;
                });
                Logger.log('üì• Pretrained weights –∑–∞–≥—Ä—É–∂–µ–Ω—ã', 'success');
            } catch(err) {
                Logger.log(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ pretrain: ${err.message}`, 'error');
            }
        };
        reader.readAsText(file);
        e.target.value = '';
    }
    
    // ‚úÖ FIX #24: Cleanup method for event listeners
    destroy() {
        if (this.rafId) cancelAnimationFrame(this.rafId);
        window.removeEventListener('resize', this._onResize);
        this.canvas?.removeEventListener('click', this._onClick);
    }
}

let game;

window.onload = () => {
    console.log('üìÑ DOM loaded, creating game...');
    try {
        game = new GameEngine();
        if (game) {
            window.settings = game.settings;
            console.log('‚úÖ Game created successfully');
        }
    } catch (e) {
        console.error('‚ùå Failed to create game:', e);
        console.error('   Stack:', e.stack);
        alert('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: ' + e.message);
    }
};

window.onbeforeunload = () => {
    if (game) {
        game.running = false;
        game.destroy?.();
    }
};
</script>
</body>
</html>


