<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ö° HC Arena v17.3 ‚Äî Web Worker</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: monospace; }
        body { background: #0a0a15; color: #fff; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        h1 { color: #00f2ff; margin-bottom: 10px; text-shadow: 0 0 20px rgba(0,242,255,0.5); }
        .badge { background: linear-gradient(90deg, #00f2ff, #00ff9d); color: #000; padding: 5px 15px; border-radius: 20px; font-weight: bold; font-size: 0.8rem; margin-bottom: 15px; }
        #arena { border: 2px solid #00f2ff; background: #050510; border-radius: 8px; }
        .controls { margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
        button { padding: 12px 24px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; text-transform: uppercase; }
        .btn-start { background: #00f2ff; color: #000; }
        .btn-stop { background: #ff6600; color: #fff; }
        .btn-train { background: #ff0055; color: #fff; }
        .btn-reverse { background: #00ff9d; color: #000; }
        .btn-reset { background: #333; color: #fff; }
        .stats { margin-top: 15px; color: #888; display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        .stat { background: #121225; padding: 8px 15px; border-radius: 6px; border: 1px solid #2a2a40; }
        .stat-value { color: #00f2ff; font-weight: bold; }
        .log { margin-top: 15px; background: #000; border: 1px solid #333; padding: 10px; max-height: 150px; overflow-y: auto; font-size: 0.75rem; width: 800px; border-radius: 6px; }
        .health { margin-top: 10px; display: flex; gap: 40px; }
        .hp-box { width: 200px; }
        .bar { width: 100%; height: 12px; background: #333; border-radius: 6px; overflow: hidden; }
        .fill { height: 100%; transition: width 0.3s; }
        .blue { background: linear-gradient(90deg, #0066ff, #00f2ff); }
        .red { background: linear-gradient(90deg, #ff0055, #ff6688); }
        .arch-info { margin-top: 15px; background: #121225; padding: 15px; border-radius: 8px; border: 1px solid #2a2a40; max-width: 800px; font-size: 0.8rem; }
        .arch-row { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid #2a2a40; }
        .arch-row:last-child { border-bottom: none; }
        .worker-status { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; }
        .worker-ok { background: #00ff9d; box-shadow: 0 0 10px #00ff9d; }
        .worker-err { background: #ff0055; }
        .disabled { opacity: 0.5; pointer-events: none; }
    </style>
</head>
<body>
    <h1>‚ö° HC ARENA v17.3</h1>
    <div class="badge">üîÑ Web Worker | 338 dim | 16-Head | 12 Reversible Blocks</div>
    
    <canvas id="arena" width="800" height="600"></canvas>
    
    <div class="health">
        <div class="hp-box">
            <div style="color:#00f2ff">üü¶ BLUE AGENT</div>
            <div class="bar"><div class="fill blue" id="blueBar" style="width:100%"></div></div>
            <div style="font-size:0.75rem;color:#666;margin-top:5px;">DMG: <span id="blueDmg">0</span></div>
        </div>
        <div class="hp-box">
            <div style="color:#ff0055">üü• RED AGENT</div>
            <div class="bar"><div class="fill red" id="redBar" style="width:100%"></div></div>
            <div style="font-size:0.75rem;color:#666;margin-top:5px;">DMG: <span id="redDmg">0</span></div>
        </div>
    </div>
    
    <div class="controls">
        <button class="btn-start" id="btnStart" onclick="startGame()">‚ñ∂Ô∏è START</button>
        <button class="btn-stop" id="btnStop" onclick="stopGame()" disabled>‚èπÔ∏è STOP</button>
        <button class="btn-train" id="btnTrain" onclick="toggleTrain()">üß† Train</button>
        <button class="btn-reverse" id="btnReverse" onclick="doReverse()">üîÑ Reverse</button>
        <button class="btn-reset" id="btnReset" onclick="resetGame()">‚Ü∫ Reset</button>
    </div>
    
    <div class="stats">
        <span class="stat"><span class="worker-status worker-ok" id="workerStatus"></span>Worker: <span class="stat-value" id="workerState">READY</span></span>
        <span class="stat">Gen: <span class="stat-value" id="gen">0</span></span>
        <span class="stat">Episode: <span class="stat-value" id="ep">0</span></span>
        <span class="stat">Blue: <span class="stat-value" id="blueWins">0</span></span>
        <span class="stat">Red: <span class="stat-value" id="redWins">0</span></span>
        <span class="stat">Reversed: <span class="stat-value" id="reversed">0</span></span>
        <span class="stat">FPS: <span class="stat-value" id="fps">0</span></span>
    </div>
    
    <div class="arch-info">
        <div style="color:#00f2ff;font-weight:bold;margin-bottom:10px;">üèóÔ∏è HC ARCHITECTURE (per agent)</div>
        <div class="arch-row"><span>State Dimensions:</span><span style="color:#00ff9d">338</span></div>
        <div class="arch-row"><span>Working State:</span><span style="color:#00ff9d">236 dim (70%)</span></div>
        <div class="arch-row"><span>Memory Channel:</span><span style="color:#00ff9d">102 dim (30%)</span></div>
        <div class="arch-row"><span>Attention Heads:</span><span style="color:#00ff9d">16</span></div>
        <div class="arch-row"><span>Reversible Blocks:</span><span style="color:#00ff9d">12 (Coupling Layers)</span></div>
        <div class="arch-row"><span>Processing:</span><span style="color:#00ff9d">Web Worker (separate thread)</span></div>
    </div>
    
    <div class="log" id="log"></div>

<script>
const canvas = document.getElementById('arena');
const ctx = canvas.getContext('2d');

let blue, red, obstacles;
let running = false, training = false, gameStarted = false;
let generation = 0, episode = 0, blueWins = 0, redWins = 0, totalReverse = 0;
let worker = null;
let lastFrameTime = performance.now();
let frameCount = 0;
let fps = 0;

function initWorker() {
    worker = new Worker('arena-worker.js');
    
    worker.onmessage = function(e) {
        const { type, data } = e.data;
        
        if(type === 'AGENT_INIT') {
            log('‚úÖ Worker: Agents initialized', 'info');
            document.getElementById('workerState').innerText = 'READY';
            document.getElementById('workerStatus').className = 'worker-status worker-ok';
        }
        
        if(type === 'ACTIONS') {
            applyActions(data.actions);
        }
        
        if(type === 'TRAIN_COMPLETE') {
            generation++;
            log('üß† Generation ' + generation + ' complete', 'train');
            document.getElementById('gen').innerText = generation;
        }
        
        if(type === 'REVERSE_RESULT') {
            totalReverse++;
            document.getElementById('reversed').innerText = totalReverse;
            log('üîÑ Reversed ' + data.steps + ' steps | Trajectory: ' + data.trajectoryLength, 'train');
        }
        
        if(type === 'ERROR') {
            log('‚ùå Worker Error: ' + data.message, 'err');
            document.getElementById('workerState').innerText = 'ERROR';
            document.getElementById('workerStatus').className = 'worker-status worker-err';
        }
    };
    
    worker.onerror = function(e) {
        log('‚ùå Worker Error: ' + e.message, 'err');
        document.getElementById('workerState').innerText = 'ERROR';
        document.getElementById('workerStatus').className = 'worker-status worker-err';
    };
    
    log('üîß Worker initialized', 'info');
}

function initGame() {
    blue = { x: 200, y: 300, vx: 0, vy: 0, hp: 100, size: 40, damageDealt: 0 };
    red = { x: 600, y: 300, vx: 0, vy: 0, hp: 100, size: 40, damageDealt: 0 };
    
    obstacles = [
        { x: 400, y: 150, w: 200, h: 20 },
        { x: 400, y: 450, w: 200, h: 20 },
        { x: 250, y: 300, w: 20, h: 200 },
        { x: 550, y: 300, w: 20, h: 200 }
    ];
    
    episode++;
    updateUI();
}

function applyActions(actions) {
    if(!running) return;
    
    const { blue: a1, red: a2 } = actions;
    
    const sp1 = 0.4 + a1.aggression * 0.6;
    const sp2 = 0.4 + a2.aggression * 0.6;
    
    blue.vx += a1.fx * sp1;
    blue.vy += a1.fy * sp1;
    red.vx += a2.fx * sp2;
    red.vy += a2.fy * sp2;
    
    blue.vx *= 0.90;
    blue.vy *= 0.90;
    red.vx *= 0.90;
    red.vy *= 0.90;
    
    blue.x += blue.vx;
    blue.y += blue.vy;
    red.x += red.vx;
    red.y += red.vy;
    
    if(blue.x < 20 || blue.x > canvas.width-20) { blue.vx *= -1.5; blue.x = Math.max(20, Math.min(canvas.width-20, blue.x)); }
    if(blue.y < 20 || blue.y > canvas.height-20) { blue.vy *= -1.5; blue.y = Math.max(20, Math.min(canvas.height-20, blue.y)); }
    if(red.x < 20 || red.x > canvas.width-20) { red.vx *= -1.5; red.x = Math.max(20, Math.min(canvas.width-20, red.x)); }
    if(red.y < 20 || red.y > canvas.height-20) { red.vy *= -1.5; red.y = Math.max(20, Math.min(canvas.height-20, red.y)); }
    
    for(let obs of obstacles) {
        if(blue.x > obs.x - obs.w/2 - 20 && blue.x < obs.x + obs.w/2 + 20 &&
           blue.y > obs.y - obs.h/2 - 20 && blue.y < obs.y + obs.h/2 + 20) {
            blue.vx *= -1.5; blue.vy *= -1.5;
        }
        if(red.x > obs.x - obs.w/2 - 20 && red.x < obs.x + obs.w/2 + 20 &&
           red.y > obs.y - obs.h/2 - 20 && red.y < obs.y + obs.h/2 + 20) {
            red.vx *= -1.5; red.vy *= -1.5;
        }
    }
    
    const dist = Math.hypot(blue.x - red.x, blue.y - red.y);
    if(dist < 40) {
        const bSp = Math.hypot(blue.vx, blue.vy);
        const rSp = Math.hypot(red.vx, red.vy);
        const tot = bSp + rSp;
        if(tot > 0) {
            const bDmg = (rSp / tot) * 10 + 3;
            const rDmg = (bSp / tot) * 10 + 3;
            blue.hp -= bDmg;
            red.hp -= rDmg;
            blue.damageDealt += rDmg;
            red.damageDealt += bDmg;
            document.getElementById('blueDmg').innerText = blue.damageDealt.toFixed(0);
            document.getElementById('redDmg').innerText = red.damageDealt.toFixed(0);
        }
        const ang = Math.atan2(blue.y - red.y, blue.x - red.x);
        blue.vx += Math.cos(ang) * 4;
        blue.vy += Math.sin(ang) * 4;
        red.vx -= Math.cos(ang) * 4;
        red.vy -= Math.sin(ang) * 4;
    }
    
    if(blue.hp <= 0 || red.hp <= 0) {
        const w = blue.hp > 0 ? 'BLUE' : 'RED';
        if(w === 'BLUE') blueWins++; else redWins++;
        log('üèÜ ' + w + ' WINS! (DMG: B=' + blue.damageDealt.toFixed(0) + ' R=' + red.damageDealt.toFixed(0) + ')', 'battle');
        if(training) {
            worker.postMessage({ type: 'TRAIN_STEP', data: { winner: w } });
        }
        setTimeout(initGame, 2000);
    }
    
    updateUI();
}

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = '#2a2a40';
    for(let obs of obstacles) {
        ctx.fillRect(obs.x - obs.w/2, obs.y - obs.h/2, obs.w, obs.h);
    }
    
    ctx.fillStyle = '#00f2ff';
    ctx.shadowColor = '#00f2ff';
    ctx.shadowBlur = blue.hp < 30 ? 30 : 20;
    ctx.fillRect(blue.x - 20, blue.y - 20, 40, 40);
    
    ctx.fillStyle = '#ff0055';
    ctx.shadowColor = '#ff0055';
    ctx.shadowBlur = red.hp < 30 ? 30 : 20;
    ctx.fillRect(red.x - 20, red.y - 20, 40, 40);
    
    ctx.shadowBlur = 0;
    
    frameCount++;
    const now = performance.now();
    if(now - lastFrameTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastFrameTime = now;
        document.getElementById('fps').innerText = fps;
    }
    
    requestAnimationFrame(render);
}

function updateUI() {
    document.getElementById('blueBar').style.width = Math.max(0, blue.hp) + '%';
    document.getElementById('redBar').style.width = Math.max(0, red.hp) + '%';
    document.getElementById('ep').innerText = episode;
    document.getElementById('blueWins').innerText = blueWins;
    document.getElementById('redWins').innerText = redWins;
    document.getElementById('btnStart').disabled = running;
    document.getElementById('btnStop').disabled = !running;
    document.getElementById('btnTrain').classList.toggle('disabled', !gameStarted);
    document.getElementById('btnReverse').classList.toggle('disabled', !gameStarted);
}

function log(msg, type) {
    const l = document.getElementById('log');
    const d = document.createElement('div');
    d.innerText = '[' + new Date().toLocaleTimeString() + '] ' + msg;
    d.style.color = type === 'train' ? '#00ff9d' : type === 'battle' ? '#ffaa00' : type === 'err' ? '#ff0055' : '#00f2ff';
    l.insertBefore(d, l.firstChild);
    if(l.children.length > 15) l.removeChild(l.lastChild);
}

function startGame() {
    if(!worker) initWorker();
    
    gameStarted = true;
    running = true;
    initGame();
    log('‚ñ∂Ô∏è Game STARTED | Worker active', 'info');
    updateUI();
    
    worker.postMessage({ type: 'START', data: { training: training, episode: episode } });
    
    requestActions();
}

function requestActions() {
    if(!running || !worker) return;
    
    const input1 = getInput(blue, red);
    const input2 = getInput(red, blue);
    
    worker.postMessage({
        type: 'GET_ACTIONS',
        data: { input1: input1, input2: input2, episode: episode, training: training }
    });
    
    setTimeout(requestActions, 1000/60);
}

function stopGame() {
    running = false;
    log('‚èπÔ∏è Game STOPPED', 'info');
    updateUI();
}

function toggleTrain() {
    training = !training;
    log(training ? 'üß† Training ON' : 'üß† Training OFF', 'train');
    if(worker) {
        worker.postMessage({ type: 'SET_TRAINING', data: { training: training } });
    }
}

function doReverse() {
    if(!worker || !gameStarted) { log('‚ùå Start game first!', 'err'); return; }
    worker.postMessage({ type: 'REVERSE', data: { steps: 5 } });
}

function resetGame() {
    running = false;
    gameStarted = false;
    generation = 0;
    episode = 0;
    blueWins = 0;
    redWins = 0;
    totalReverse = 0;
    
    if(worker) {
        worker.terminate();
        worker = null;
    }
    
    initWorker();
    initGame();
    log('‚Ü∫ Reset complete', 'info');
    updateUI();
}

function raycast(x, y, angle, maxDist) {
    for(let i=0; i<maxDist; i+=15) {
        const tx = x + Math.cos(angle) * i;
        const ty = y + Math.sin(angle) * i;
        for(let obs of obstacles) {
            if(tx > obs.x - obs.w/2 && tx < obs.x + obs.w/2 &&
               ty > obs.y - obs.h/2 && ty < obs.y + obs.h/2) {
                return i / maxDist;
            }
        }
        if(tx < 0 || tx > canvas.width || ty < 0 || ty > canvas.height) return i / maxDist;
    }
    return 1;
}

function getInput(me, enemy) {
    const distToEnemy = Math.hypot(enemy.x - me.x, enemy.y - me.y);
    const angleToEnemy = Math.atan2(enemy.y - me.y, enemy.x - me.x);
    const cornerPenalty = ((me.x < 100 ? 1 : 0) + (me.x > canvas.width-100 ? 1 : 0) + (me.y < 100 ? 1 : 0) + (me.y > canvas.height-100 ? 1 : 0)) / 4;
    
    return [
        me.x / canvas.width, me.y / canvas.height,
        me.vx * 0.5, me.vy * 0.5,
        (enemy.x - me.x) / canvas.width, (enemy.y - me.y) / canvas.height,
        enemy.vx * 0.5, enemy.vy * 0.5,
        distToEnemy / canvas.width,
        Math.cos(angleToEnemy), Math.sin(angleToEnemy),
        me.hp / 100, enemy.hp / 100,
        cornerPenalty,
        raycast(me.x, me.y, 0, 300),
        raycast(me.x, me.y, Math.PI/4, 300),
        raycast(me.x, me.y, Math.PI/2, 300),
        raycast(me.x, me.y, 3*Math.PI/4, 300),
        raycast(me.x, me.y, Math.PI, 300),
        raycast(me.x, me.y, 5*Math.PI/4, 300),
    ];
}

window.onload = function() {
    initWorker();
    initGame();
    render();
    log('‚ö° HC v17.3 Ready | Press ‚ñ∂Ô∏è START', 'info');
    updateUI();
};
</script>
</body>
</html>

