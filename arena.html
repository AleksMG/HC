<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ö° HC Arena ‚Äî Neural Network Battles</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Courier New', monospace; }
        body { 
            background: #0a0a15; 
            color: #e0e0e0; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            padding: 20px;
            min-height: 100vh;
        }

        h1 { color: #00f2ff; margin-bottom: 10px; text-shadow: 0 0 20px rgba(0,242,255,0.5); }
        .subtitle { color: #666; margin-bottom: 20px; }

        .container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }

        .panel {
            background: #121225;
            border: 1px solid #2a2a40;
            border-radius: 12px;
            padding: 20px;
        }

        #arena { 
            border: 2px solid #00f2ff; 
            border-radius: 8px; 
            background: #050510;
        }

        .stats { min-width: 300px; }
        .stat-row { 
            display: flex; 
            justify-content: space-between; 
            padding: 8px 0; 
            border-bottom: 1px solid #2a2a40;
        }
        .stat-label { color: #888; }
        .stat-value { color: #00f2ff; font-weight: bold; }
        .stat-value.ok { color: #00ff9d; }
        .stat-value.err { color: #ff0055; }

        .controls { 
            display: flex; 
            gap: 10px; 
            margin-top: 15px; 
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 120px;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.3s;
        }

        .btn-start { background: #00f2ff; color: #000; }
        .btn-start:hover { background: #fff; }
        .btn-train { background: #ff0055; color: #fff; }
        .btn-train:hover { background: #ff5588; }
        .btn-reset { background: #333; color: #fff; }

        .log {
            background: #000;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.75rem;
        }

        .log-entry { margin-bottom: 5px; }
        .log-info { color: #00f2ff; }
        .log-train { color: #00ff9d; }
        .log-battle { color: #ffaa00; }

        .agent-info {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,242,255,0.05);
            border-radius: 6px;
        }

        .health-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0055, #00ff9d);
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <h1>‚ö° HC ARENA</h1>
    <p class="subtitle">Neural Network vs Neural Network | Reversible AI Battles</p>

    <div class="container">
        <div class="panel">
            <canvas id="arena" width="800" height="600"></canvas>
        </div>

        <div class="panel stats">
            <h3 style="color: #00f2ff; margin-bottom: 15px;">üìä BATTLE STATS</h3>
            
            <div class="stat-row">
                <span class="stat-label">Generation:</span>
                <span class="stat-value" id="statGen">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Episode:</span>
                <span class="stat-value" id="statEp">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Time:</span>
                <span class="stat-value" id="statTime">0s</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">HC Blocks:</span>
                <span class="stat-value">12</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Attention:</span>
                <span class="stat-value">16 heads</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">State Dim:</span>
                <span class="stat-value">338</span>
            </div>

            <div class="agent-info">
                <div style="display:flex;justify-content:space-between;">
                    <span style="color:#00f2ff;">üü¶ BLUE AGENT</span>
                    <span class="stat-value" id="blueHealth">100%</span>
                </div>
                <div class="health-bar">
                    <div class="health-fill" id="blueHealthBar" style="width: 100%;"></div>
                </div>
            </div>

            <div class="agent-info">
                <div style="display:flex;justify-content:space-between;">
                    <span style="color:#ff0055;">üü• RED AGENT</span>
                    <span class="stat-value" id="redHealth">100%</span>
                </div>
                <div class="health-bar">
                    <div class="health-fill" id="redHealthBar" style="width: 100%;"></div>
                </div>
            </div>

            <div class="controls">
                <button class="btn-start" onclick="togglePause()">‚èØÔ∏è Pause</button>
                <button class="btn-train" onclick="toggleTrain()">üß† Train</button>
                <button class="btn-reset" onclick="resetBattle()">‚Ü∫ Reset</button>
            </div>

            <div class="log" id="log"></div>
        </div>
    </div>

<script>
/**
 * HC ARENA ‚Äî NEURAL NETWORK BATTLES
 * 
 * Square agents controlled by HC Engine (v17.3)
 * Matter.js physics + Raycasting + Self-play learning
 */

// ============ MATTER.JS SETUP ============
const Matter = window.Matter;
const Engine = Matter.Engine,
      Render = Matter.Render,
      Runner = Matter.Runner,
      Bodies = Matter.Bodies,
      Body = Matter.Body,
      Composite = Matter.Composite,
      Events = Matter.Events,
      Vector = Matter.Vector;

// ============ HC ENGINE (v17.3 simplified) ============
const tanh = x => Math.tanh(x);
const mod = (n, m) => ((n % m) + m) % m;

class SeededRandom {
    constructor(seedStr) {
        let h = 0x811c9dc5;
        for(let i=0; i<seedStr.length; i++) {
            h ^= seedStr.charCodeAt(i);
            h = Math.imul(h, 0x01000193);
        }
        this.seed = h >>> 0;
    }
    next() {
        this.seed = (this.seed * 1664525 + 1013904223) >>> 0;
        return this.seed / 0xFFFFFFFF;
    }
    nextInt(max) { return Math.floor(this.next() * max); }
}

class HCAgent {
    constructor(password, id) {
        this.id = id;
        this.dim = 338;
        this.blocks = 12;
        this.password = password;
        
        // Initialize weights
        const rng = new SeededRandom(password + id);
        this.W_input = [];
        for(let i=0; i<this.dim; i++) {
            let row = [];
            for(let j=0; j<20; j++) {
                row.push((rng.next() * 2 - 1) * 0.3);
            }
            this.W_input.push(row);
        }
        
        this.blocks_W = [];
        for(let b=0; b<this.blocks; b++) {
            let W_f = [], W_g = [];
            const half = Math.floor(this.dim / 2);
            for(let i=0; i<half; i++) {
                let row_f = [], row_g = [];
                for(let j=0; j<half; j++) {
                    row_f.push((rng.next() * 2 - 1) * 0.1);
                    row_g.push((rng.next() * 2 - 1) * 0.1);
                }
                W_f.push(row_f);
                W_g.push(row_g);
            }
            this.blocks_W.push({ W_f, W_g });
        }
        
        this.memory = new Array(102).fill(0);
        this.step = 0;
    }
    
    getState(input) {
        let state = [];
        for(let i=0; i<this.dim; i++) {
            let sum = 0;
            for(let j=0; j<input.length; j++) {
                sum += input[j] * this.W_input[i][j];
            }
            state.push(tanh(sum));
        }
        return state;
    }
    
    forward(state) {
        let current = state.slice();
        const half = Math.floor(this.dim / 2);
        
        for(let b=0; b<this.blocks; b++) {
            const { W_f, W_g } = this.blocks_W[b];
            const x1 = current.slice(0, half);
            const x2 = current.slice(half);
            
            let f_out = [];
            for(let i=0; i<half; i++) {
                let sum = 0;
                for(let j=0; j<half; j++) {
                    sum += x2[j] * W_f[i][j];
                }
                f_out.push(tanh(sum));
            }
            
            const y1 = x1.map((v, i) => v + f_out[i]);
            
            let g_out = [];
            for(let i=0; i<half; i++) {
                let sum = 0;
                for(let j=0; j<half; j++) {
                    sum += y1[j] * W_g[i][j];
                }
                g_out.push(tanh(sum));
            }
            
            const y2 = x2.map((v, i) => v + g_out[i]);
            current = y1.concat(y2);
        }
        
        return current;
    }
    
    decide(input) {
        let state = this.getState(input);
        state = this.forward(state);
        
        // Extract 4 forces from state
        return {
            fx: tanh(state[0]),
            fy: tanh(state[1]),
            health: state[2],
            confidence: Math.abs(state[3])
        };
    }
    
    mutate(rate=0.1) {
        const rng = new SeededRandom(this.password + this.id + Date.now());
        for(let i=0; i<this.W_input.length; i++) {
            for(let j=0; j<this.W_input[i].length; j++) {
                if(rng.next() < rate) {
                    this.W_input[i][j] += (rng.next() * 2 - 1) * 0.5;
                }
            }
        }
    }
}

// ============ ARENA SETUP ============
const canvas = document.getElementById('arena');
const ctx = canvas.getContext('2d');

const engine = Engine.create();
engine.world.gravity.y = 0; // Top-down, no gravity

let agent1, agent2, obstacles = [];
let hc1, hc2;
let running = true;
let training = false;
let generation = 0;
let episode = 0;
let startTime = Date.now();

// ============ GAME OBJECTS ============
function createAgent(x, y, color) {
    return Bodies.rectangle(x, y, 40, 40, {
        friction: 0.3,
        restitution: 0.5,
        frictionAir: 0.05,
        render: { fillStyle: color }
    });
}

function createObstacle(x, y, w, h) {
    return Bodies.rectangle(x, y, w, h, {
        isStatic: true,
        render: { fillStyle: '#2a2a40' }
    });
}

function initArena() {
    Composite.clear(engine.world);
    engine.events = {};
    
    // Agents
    agent1 = createAgent(200, 300, '#00f2ff');
    agent2 = createAgent(600, 300, '#ff0055');
    
    // Obstacles
    obstacles = [
        createObstacle(400, 150, 200, 20),
        createObstacle(400, 450, 200, 20),
        createObstacle(250, 300, 20, 200),
        createObstacle(550, 300, 20, 200)
    ];
    
    Composite.add(engine.world, [agent1, agent2, ...obstacles]);
    
    // HC Agents
    hc1 = new HCAgent('ARENA_V1', '_BLUE');
    hc2 = new HCAgent('ARENA_V1', '_RED');
    
    // Health
    agent1.health = 100;
    agent2.health = 100;
    
    episode++;
    startTime = Date.now();
    
    log(`Episode ${episode} started`, 'info');
}

// ============ RAYCASTING ============
function castRay(from, angle, maxLength) {
    const step = 10;
    const steps = maxLength / step;
    
    for(let i=0; i<steps; i++) {
        const x = from.x + Math.cos(angle) * i * step;
        const y = from.y + Math.sin(angle) * i * step;
        
        // Check obstacles
        for(let obs of obstacles) {
            const bounds = obs.bounds;
            if(x >= bounds.min.x && x <= bounds.max.x &&
               y >= bounds.min.y && y <= bounds.max.y) {
                return i * step;
            }
        }
        
        // Check arena bounds
        if(x < 0 || x > canvas.width || y < 0 || y > canvas.height) {
            return i * step;
        }
    }
    
    return maxLength;
}

function getAgentInput(agent, enemy) {
    const input = [];
    
    // Position (normalized)
    input.push(agent.position.x / canvas.width);
    input.push(agent.position.y / canvas.height);
    
    // Velocity
    input.push(agent.velocity.x);
    input.push(agent.velocity.y);
    
    // Enemy relative position
    input.push((enemy.position.x - agent.position.x) / canvas.width);
    input.push((enemy.position.y - agent.position.y) / canvas.height);
    input.push(enemy.velocity.x);
    input.push(enemy.velocity.y);
    
    // Raycasting (8 directions)
    const angles = [0, Math.PI/4, Math.PI/2, 3*Math.PI/4, Math.PI, 
                    5*Math.PI/4, 3*Math.PI/2, 7*Math.PI/4];
    for(let angle of angles) {
        input.push(castRay(agent.position, angle, 300) / 300);
    }
    
    // Health
    input.push(agent.health / 100);
    input.push(enemy.health / 100);
    
    // Pad to 20 inputs
    while(input.length < 20) input.push(0);
    
    return input;
}

// ============ GAME LOOP ============
function update() {
    if(!running) return;
    
    Engine.update(engine, 1000 / 60);
    
    // HC decisions
    const input1 = getAgentInput(agent1, agent2);
    const input2 = getAgentInput(agent2, agent1);
    
    const action1 = hc1.decide(input1);
    const action2 = hc2.decide(input2);
    
    // Apply forces
    Body.applyForce(agent1, agent1.position, { 
        x: action1.fx * 0.002, 
        y: action1.fy * 0.002 
    });
    Body.applyForce(agent2, agent2.position, { 
        x: action2.fx * 0.002, 
        y: action2.fy * 0.002 
    });
    
    // Collision damage
    const dist = Vector.magnitude(Vector.sub(agent1.position, agent2.position));
    if(dist < 40) {
        agent1.health -= 0.5;
        agent2.health -= 0.5;
        
        if(training) {
            // Reward for dealing damage
            hc1.step += 0.1;
            hc2.step += 0.1;
        }
    }
    
    // Check death
    if(agent1.health <= 0 || agent2.health <= 0) {
        const winner = agent1.health > 0 ? 'BLUE' : 'RED';
        log(`üèÜ ${winner} WINS!`, 'battle');
        
        if(training) {
            // Mutate winner
            if(winner === 'BLUE') hc1.mutate(0.05);
            else hc2.mutate(0.05);
            
            generation++;
        }
        
        setTimeout(initArena, 2000);
    }
    
    // Update UI
    updateStats();
}

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Obstacles
    ctx.fillStyle = '#2a2a40';
    for(let obs of obstacles) {
        ctx.fillRect(
            obs.bounds.min.x, 
            obs.bounds.min.y, 
            obs.bounds.max.x - obs.bounds.min.x, 
            obs.bounds.max.y - obs.bounds.min.y
        );
    }
    
    // Agents
    ctx.save();
    ctx.translate(agent1.position.x, agent1.position.y);
    ctx.rotate(agent1.angle);
    ctx.fillStyle = '#00f2ff';
    ctx.shadowColor = '#00f2ff';
    ctx.shadowBlur = 20;
    ctx.fillRect(-20, -20, 40, 40);
    ctx.restore();
    
    ctx.save();
    ctx.translate(agent2.position.x, agent2.position.y);
    ctx.rotate(agent2.angle);
    ctx.fillStyle = '#ff0055';
    ctx.shadowColor = '#ff0055';
    ctx.shadowBlur = 20;
    ctx.fillRect(-20, -20, 40, 40);
    ctx.restore();
    
    // Rays (visualization)
    ctx.strokeStyle = 'rgba(0,242,255,0.3)';
    ctx.lineWidth = 1;
    const angles = [0, Math.PI/4, Math.PI/2, 3*Math.PI/4, Math.PI, 
                    5*Math.PI/4, 3*Math.PI/2, 7*Math.PI/4];
    for(let angle of angles) {
        const dist = castRay(agent1.position, angle, 300);
        ctx.beginPath();
        ctx.moveTo(agent1.position.x, agent1.position.y);
        ctx.lineTo(
            agent1.position.x + Math.cos(angle) * dist,
            agent1.position.y + Math.sin(angle) * dist
        );
        ctx.stroke();
    }
    
    requestAnimationFrame(render);
}

function updateStats() {
    document.getElementById('statGen').innerText = generation;
    document.getElementById('statEp').innerText = episode;
    document.getElementById('statTime').innerText = 
        ((Date.now() - startTime) / 1000).toFixed(1) + 's';
    
    document.getElementById('blueHealth').innerText = 
        Math.max(0, agent1.health).toFixed(0) + '%';
    document.getElementById('blueHealthBar').style.width = 
        Math.max(0, agent1.health) + '%';
    
    document.getElementById('redHealth').innerText = 
        Math.max(0, agent2.health).toFixed(0) + '%';
    document.getElementById('redHealthBar').style.width = 
        Math.max(0, agent2.health) + '%';
}

function log(msg, type) {
    const c = document.getElementById('log');
    const d = document.createElement('div');
    d.className = 'log-entry log-' + type;
    d.innerText = '[' + new Date().toLocaleTimeString() + '] ' + msg;
    c.insertBefore(d, c.firstChild);
    if(c.children.length > 20) c.removeChild(c.lastChild);
}

// ============ CONTROLS ============
function togglePause() {
    running = !running;
    log(running ? '‚ñ∂Ô∏è Resumed' : '‚è∏Ô∏è Paused', 'info');
}

function toggleTrain() {
    training = !training;
    log(training ? 'üß† Training ON (mutation enabled)' : 'üß† Training OFF', 'train');
}

function resetBattle() {
    generation = 0;
    episode = 0;
    hc1 = new HCAgent('ARENA_V1', '_BLUE');
    hc2 = new HCAgent('ARENA_V1', '_RED');
    initArena();
    log('‚Ü∫ Battle reset', 'info');
}

// ============ START ============
initArena();
setInterval(update, 1000 / 60);
render();
log('‚ö° HC Arena ready. Press Train to start learning!', 'info');
</script>
</body>
</html>
