<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src 'self'; img-src 'self'; font-src 'self';">
    <meta name="description" content="AI Arena v4.0.1 Professional ‚Äî Dual-Memory Neural Network with TD(Œª)+Actor-Critic+MoE+Hebbian">
    <meta name="theme-color" content="#0a0a15">
    <meta name="robots" content="noindex">
    <title>üéÆ AI Arena v4.0.1 PROFESSIONAL ‚Äî Neural Architecture Complete</title>
    <style>
        /* ========================================================================
           AI ARENA v4.0.1 ‚Äî PROFESSIONAL CSS COMPLETE
           GitHub Pages compatible ‚Ä¢ Responsive ‚Ä¢ Accessible ‚Ä¢ Performant
           ======================================================================== */
        :root {
            /* Core color palette */
            --bg: #0a0a15;
            --bg-gradient-start: #0a0a15;
            --bg-gradient-end: #1a1a2e;
            --panel: #121225;
            --panel-alpha: rgba(18, 18, 37, 0.95);
            --text: #e0e0ff;
            --text-dim: #b0b0d0;
            --text-muted: #707090;
            --primary: #00f2ff;
            --primary-dark: #00c4d4;
            --accent: #ff0066;
            --success: #00ff9d;
            --warning: #ffaa00;
            --danger: #ff4444;
            --border: #2a2a45;
            --border-light: #3a3a5a;
            --purple: #aa88ff;
            --yellow: #ffdd44;
            --pink: #ff66cc;
            --cyan: #00d4ff;
            
            /* Stat colors */
            --stat-str: #ff4444;
            --stat-spd: #4444ff;
            --stat-hp: #44ff44;
            --stat-dod: #aa88ff;
            
            /* Learning indicators */
            --learning-good: #00ff9d;
            --learning-bad: #ff5577;
            --learning-neutral: #ffaa00;
            
            /* Mode badge backgrounds */
            --mode-hunt-bg: rgba(0, 255, 157, 0.15);
            --mode-hunt-text: #00ff9d;
            --mode-flee-bg: rgba(255, 85, 119, 0.15);
            --mode-flee-text: #ff5577;
            --mode-explore-bg: rgba(0, 212, 255, 0.15);
            --mode-explore-text: #00d4ff;
            --mode-combat-bg: rgba(255, 170, 0, 0.15);
            --mode-combat-text: #ffaa00;
            --mode-avoid-bg: rgba(170, 136, 255, 0.15);
            --mode-avoid-text: #aa88ff;
            
            /* Layout constants */
            --sidebar-width: 420px;
            --header-height: 48px;
            --panel-radius: 12px;
            --btn-radius: 8px;
            --input-radius: 6px;
            --card-radius: 10px;
            
            /* Transitions */
            --transition-fast: 150ms ease;
            --transition-normal: 250ms ease;
            --transition-slow: 400ms ease;
            
            /* Shadows */
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.5);
            
            /* Z-index layers */
            --z-canvas: 1;
            --z-sidebar: 10;
            --z-header: 100;
            --z-modal: 1000;
        }
        
        /* Fallback for browsers without CSS variables */
        @supports not (--css: variables) {
            body { background: #0a0a15; color: #e0e0ff; }
            .sidebar { background: #121225; }
            .panel { background: rgba(0, 0, 0, 0.3); border-color: #2a2a45; }
            :root { --text-dim: #b0b0d0; --border-light: #3a3a5a; }
        }
        
        /* Reset & Base */
        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            font-size: 16px;
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            scroll-behavior: smooth;
        }
        
        body {
            background: var(--bg);
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            color: var(--text);
            font-family: 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
            font-size: 0.875rem;
            line-height: 1.4;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            touch-action: manipulation;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        /* Accessibility: Focus indicators */
        :focus-visible {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }
        
        button:focus-visible,
        input:focus-visible,
        [tabindex]:focus-visible,
        [role="button"]:focus-visible {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
            box-shadow: 0 0 0 4px rgba(0, 242, 255, 0.2);
        }
        
        /* Skip link for keyboard users */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--primary);
            color: #000;
            padding: 0.5rem 1rem;
            z-index: var(--z-modal);
            transition: top var(--transition-fast);
        }
        .skip-link:focus {
            top: 0;
        }
        
        /* Layout */
        .container {
            display: grid;
            grid-template-columns: 1fr var(--sidebar-width);
            grid-template-rows: var(--header-height) 1fr;
            grid-template-areas:
                "header header"
                "canvas sidebar";
            height: 100vh;
            min-height: 100vh;
            width: 100vw;
            min-width: 100vw;
            position: relative;
        }
        
        /* Header */
        .header {
            grid-area: header;
            background: var(--panel);
            border-bottom: 1px solid var(--border);
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: var(--z-header);
            box-shadow: var(--shadow-sm);
            position: relative;
        }
        
        .header h1 {
            font-size: 1rem;
            font-weight: 700;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            letter-spacing: 0.5px;
            margin: 0;
        }
        
        .version-badge {
            background: var(--accent);
            color: #fff;
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-size: 0.625rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            display: inline-flex;
            align-items: center;
        }
        
        .fps-counter {
            font-family: 'Courier New', Consolas, monospace;
            color: var(--success);
            font-weight: 700;
            font-size: 0.875rem;
            background: rgba(0, 255, 157, 0.1);
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            border: 1px solid rgba(0, 255, 157, 0.3);
            min-width: 70px;
            text-align: center;
        }
        
        /* Canvas */
        #gameCanvas {
            grid-area: canvas;
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            position: relative;
            z-index: var(--z-canvas);
        }
        
        /* Sidebar */
        .sidebar {
            grid-area: sidebar;
            background: var(--panel);
            border-left: 1px solid var(--border);
            padding: 0.625rem;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            scrollbar-width: thin;
            scrollbar-color: var(--border) var(--bg);
            z-index: var(--z-sidebar);
            position: relative;
        }
        
        .sidebar::-webkit-scrollbar {
            width: 0.25rem;
        }
        .sidebar::-webkit-scrollbar-track {
            background: var(--bg);
        }
        .sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 0.125rem;
        }
        
        /* Panels */
        .panel {
            background: var(--panel-alpha);
            border: 1px solid var(--border);
            border-radius: var(--panel-radius);
            padding: 0.5rem;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            position: relative;
        }
        
        .panel-title {
            color: var(--primary);
            font-size: 0.75rem;
            font-weight: 700;
            margin-bottom: 0.375rem;
            display: flex;
            align-items: center;
            gap: 0.3125rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid var(--border);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Stats Grid */
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.25rem;
        }
        
        .stat {
            background: rgba(0, 0, 0, 0.2);
            padding: 0.25rem 0.375rem;
            border-radius: 0.375rem;
            font-size: 0.625rem;
            border: 1px solid transparent;
            transition: border-color var(--transition-fast), background var(--transition-fast);
        }
        
        .stat:hover {
            border-color: var(--border-light);
            background: rgba(0, 0, 0, 0.25);
        }
        
        .stat-label {
            color: var(--text-dim);
            display: block;
            margin-bottom: 0.0625rem;
            font-size: 0.5625rem;
        }
        
        .stat-value {
            color: var(--primary);
            font-weight: 700;
            font-family: 'Courier New', Consolas, monospace;
            font-size: 0.6875rem;
        }
        
        .stat-value.good { color: var(--success); }
        .stat-value.bad { color: var(--danger); }
        .stat-value.warn { color: var(--warning); }
        .stat-value.learning { color: var(--learning-good); }
        
        /* Controls */
        .control-group {
            margin-bottom: 0.375rem;
        }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.6875rem;
            margin-bottom: 0.125rem;
            color: var(--text-dim);
        }
        
        input[type="range"] {
            width: 100%;
            height: 0.25rem;
            background: var(--border);
            border-radius: 0.125rem;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 0.75rem;
            height: 0.75rem;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--bg);
            transition: transform var(--transition-fast), background var(--transition-fast);
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            background: #fff;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 0.75rem;
            height: 0.75rem;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--bg);
        }
        
        /* Buttons */
        .btn-group {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.25rem;
            margin-top: 0.25rem;
        }
        
        .btn-group-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.25rem;
            margin-top: 0.25rem;
        }
        
        button {
            padding: 0.375rem 0.5rem;
            border: none;
            border-radius: var(--btn-radius);
            font-weight: 700;
            cursor: pointer;
            font-size: 0.6875rem;
            transition: all var(--transition-fast);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            background: var(--border);
            color: var(--text);
            position: relative;
            overflow: hidden;
            min-height: 2rem;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.3s ease;
            pointer-events: none;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            pointer-events: none;
        }
        
        .btn-primary {
            background: var(--primary);
            color: #000;
        }
        .btn-primary:hover:not(:disabled) {
            background: #fff;
            box-shadow: 0 0 0 2px var(--primary-dark);
        }
        
        .btn-danger {
            background: var(--danger);
            color: #fff;
        }
        .btn-danger:hover:not(:disabled) {
            background: #ff6666;
            box-shadow: 0 0 0 2px #ff2222;
        }
        
        .btn-success {
            background: var(--success);
            color: #000;
        }
        .btn-success:hover:not(:disabled) {
            background: #66ffcc;
            box-shadow: 0 0 0 2px #00cc7d;
        }
        
        .btn-secondary {
            background: var(--border);
            color: var(--text);
        }
        .btn-secondary:hover:not(:disabled) {
            background: var(--border-light);
        }
        
        .btn-toggle {
            background: var(--border);
            color: var(--text);
        }
        .btn-toggle.active {
            background: var(--accent);
            color: #fff;
            box-shadow: 0 0 0 2px var(--accent);
        }
        
        .btn-learning {
            background: var(--purple);
            color: #fff;
        }
        .btn-learning:hover:not(:disabled) {
            background: #cc88ff;
            box-shadow: 0 0 0 2px #8855ff;
        }
        
        /* Toggles */
        .toggle {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.6875rem;
            margin-bottom: 0.1875rem;
            color: var(--text-dim);
            cursor: pointer;
            user-select: none;
            padding: 0.125rem 0;
        }
        
        .toggle input {
            accent-color: var(--primary);
            width: 0.875rem;
            height: 0.875rem;
            cursor: pointer;
            margin: 0;
        }
        
        .toggle:hover {
            color: var(--text);
        }
        
        /* Log */
        .log {
            background: #000;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 0.375rem;
            height: 5.625rem;
            overflow-y: auto;
            font-size: 0.5625rem;
            font-family: 'Courier New', Consolas, monospace;
            word-break: break-word;
            white-space: pre-wrap;
            max-width: 100%;
            scrollbar-width: thin;
        }
        
        .log::-webkit-scrollbar {
            width: 0.25rem;
        }
        .log::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 0.125rem;
        }
        
        .log-entry {
            margin-bottom: 0.125rem;
            padding-bottom: 0.125rem;
            border-bottom: 1px solid #111;
            line-height: 1.3;
        }
        .log-entry:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .log-entry.info { color: var(--primary); }
        .log-entry.success { color: var(--success); }
        .log-entry.warn { color: var(--warning); }
        .log-entry.error { color: var(--danger); }
        .log-entry.learning { color: var(--learning-good); }
        
        /* Progress bars */
        .progress-bar {
            height: 0.25rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 0.1875rem;
            overflow: hidden;
            margin-top: 0.1875rem;
            position: relative;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--success));
            transition: width var(--transition-normal);
            will-change: width;
            position: relative;
        }
        
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        /* Agent legend */
        .agent-legend {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.1875rem;
            margin-top: 0.25rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.5625rem;
        }
        
        .legend-color {
            width: 0.5rem;
            height: 0.5rem;
            border-radius: 0.125rem;
            flex-shrink: 0;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        /* Agent cards */
        .agent-card {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            padding: 0.375rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: var(--card-radius);
            margin-bottom: 0.375rem;
            border-left: 3px solid transparent;
            transition: border-left-color var(--transition-fast), background var(--transition-fast);
        }
        
        .agent-card:hover {
            background: rgba(0, 0, 0, 0.25);
        }
        
        .agent-card.blue { border-left-color: var(--primary); }
        .agent-card.red { border-left-color: var(--accent); }
        
        .agent-header {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.6875rem;
            font-weight: 600;
        }
        
        .health-bar {
            height: 0.1875rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 0.125rem;
            overflow: hidden;
            position: relative;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success), var(--primary));
            transition: width var(--transition-fast);
            will-change: width;
        }
        
        .health-fill.low {
            background: linear-gradient(90deg, var(--danger), var(--warning));
        }
        
        .agent-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.5625rem;
            color: var(--text-dim);
            flex-wrap: wrap;
            gap: 0.125rem;
        }
        
        .agent-stats b {
            color: var(--text);
            font-weight: 600;
        }
        
        .stat-badge {
            display: inline-flex;
            align-items: center;
            padding: 0.0625rem 0.1875rem;
            border-radius: 0.125rem;
            font-size: 0.5rem;
            font-weight: 600;
            margin-right: 0.125rem;
            border: 1px solid transparent;
        }
        
        .stat-badge.stat-hp {
            background: rgba(68, 255, 68, 0.15);
            color: var(--stat-hp);
            border-color: var(--stat-hp);
        }
        .stat-badge.stat-str {
            background: rgba(255, 68, 68, 0.15);
            color: var(--stat-str);
            border-color: var(--stat-str);
        }
        .stat-badge.stat-spd {
            background: rgba(68, 68, 255, 0.15);
            color: var(--stat-spd);
            border-color: var(--stat-spd);
        }
        .stat-badge.stat-dod {
            background: rgba(170, 136, 255, 0.15);
            color: var(--stat-dod);
            border-color: var(--stat-dod);
        }
        
        /* Skills display */
        .skills-display {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.125rem;
            margin-top: 0.1875rem;
        }
        
        .skill-item {
            text-align: center;
            font-size: 0.5rem;
        }
        
        .skill-bar {
            height: 0.125rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 0.0625rem;
            margin-top: 0.0625rem;
            overflow: hidden;
            position: relative;
        }
        
        .skill-fill {
            height: 100%;
            transition: width var(--transition-normal);
            will-change: width;
        }
        
        .skill-hunt .skill-fill { background: var(--success); }
        .skill-flee .skill-fill { background: var(--danger); }
        .skill-combat .skill-fill { background: var(--warning); }
        .skill-explore .skill-fill { background: var(--primary); }
        .skill-avoid .skill-fill { background: var(--purple); }
        
        /* Confidence meter */
        .confidence-meter {
            display: flex;
            align-items: center;
            gap: 0.1875rem;
            margin-top: 0.1875rem;
            font-size: 0.5625rem;
        }
        
        .confidence-bar {
            flex: 1;
            height: 0.1875rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 0.125rem;
            overflow: hidden;
            position: relative;
        }
        
        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--danger), var(--warning), var(--success));
            transition: width var(--transition-fast);
            will-change: width;
        }
        
        /* Learning metrics */
        .learning-metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.1875rem;
            margin-top: 0.25rem;
        }
        
        .metric-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 0.1875rem 0.25rem;
            border-radius: 0.25rem;
            font-size: 0.5rem;
            transition: background var(--transition-fast);
        }
        
        .metric-item:hover {
            background: rgba(0, 0, 0, 0.25);
        }
        
        .metric-label {
            color: var(--text-dim);
            display: block;
            font-size: 0.4375rem;
        }
        
        .metric-value {
            color: var(--learning-good);
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }
        
        .metric-value.degrading {
            color: var(--danger);
        }
        
        /* Learning progress */
        .learning-progress {
            display: flex;
            flex-direction: column;
            gap: 0.125rem;
            margin-top: 0.25rem;
        }
        
        .progress-row {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.5rem;
        }
        
        .progress-label {
            width: 4.375rem;
            color: var(--text-dim);
            flex-shrink: 0;
        }
        
        .progress-track {
            flex: 1;
            height: 0.1875rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 0.125rem;
            overflow: hidden;
            position: relative;
        }
        
        .progress-track.td .progress-fill {
            background: linear-gradient(90deg, var(--danger), var(--warning), var(--success));
        }
        .progress-track.entropy .progress-fill {
            background: linear-gradient(90deg, var(--warning), var(--primary));
        }
        .progress-track.pred .progress-fill {
            background: linear-gradient(90deg, var(--danger), var(--success));
        }
        
        /* Mode badges */
        .mode-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.125rem;
            padding: 0.0625rem 0.25rem;
            border-radius: 0.375rem;
            font-size: 0.5rem;
            font-weight: 600;
            margin-left: 0.25rem;
        }
        
        .mode-hunt {
            background: var(--mode-hunt-bg);
            color: var(--mode-hunt-text);
        }
        .mode-flee {
            background: var(--mode-flee-bg);
            color: var(--mode-flee-text);
        }
        .mode-explore {
            background: var(--mode-explore-bg);
            color: var(--mode-explore-text);
        }
        .mode-combat {
            background: var(--mode-combat-bg);
            color: var(--mode-combat-text);
        }
        .mode-avoid {
            background: var(--mode-avoid-bg);
            color: var(--mode-avoid-text);
        }
        
        /* Debug panel */
        .debug-panel {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 0.375rem;
            font-size: 0.5625rem;
            display: none;
            animation: slideDown var(--transition-fast) ease;
        }
        
        .debug-panel.active {
            display: block;
        }
        
        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-0.5rem); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .debug-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.125rem 0.25rem;
        }
        
        .debug-item {
            display: flex;
            justify-content: space-between;
            padding: 0.0625rem 0;
        }
        
        .debug-label {
            color: var(--text-dim);
        }
        
        .debug-value {
            color: var(--primary);
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }
        
        .debug-value.good { color: var(--success); }
        .debug-value.bad { color: var(--danger); }
        
        /* Separator */
        .separator {
            height: 1px;
            background: var(--border);
            margin: 0.375rem 0;
        }
        
        /* File inputs */
        input[type="file"] {
            display: none;
        }
        
        /* Noscript fallback */
        noscript {
            grid-column: 1 / -1;
            padding: 1rem;
            background: var(--danger);
            color: #fff;
            text-align: center;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: var(--panel-radius);
        }
        
        /* Responsive design */
        @media (max-width: 1100px) {
            .container {
                grid-template-columns: 1fr !important;
                grid-template-rows: var(--header-height) 1fr auto !important;
                grid-template-areas:
                    "header"
                    "canvas"
                    "sidebar" !important;
            }
            
            .sidebar {
                border-left: none !important;
                border-top: 1px solid var(--border) !important;
                max-height: 45vh !important;
                overflow-y: auto !important;
            }
        }
        
        @media (max-width: 600px) {
            :root {
                --sidebar-width: 100%;
            }
            
            .header {
                padding: 0.375rem 0.75rem;
            }
            
            .header h1 {
                font-size: 0.875rem;
            }
            
            .panel {
                padding: 0.375rem;
            }
            
            .stat-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .btn-group,
            .btn-group-3 {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .agent-legend {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .learning-metrics {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .debug-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Print styles */
        @media print {
            body {
                background: #fff;
                color: #000;
                overflow: visible;
            }
            
            .sidebar,
            .header {
                display: none;
            }
            
            #gameCanvas {
                width: 100%;
                height: auto;
                display: block;
            }
        }
        
        /* Reduced motion */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
            
            .progress-fill,
            .health-fill,
            .skill-fill,
            .confidence-fill {
                transition: none !important;
            }
        }
        
        /* High contrast mode */
        @media (prefers-contrast: high) {
            :root {
                --border: #5a5a7a;
                --text-dim: #d0d0f0;
            }
            
            .stat,
            .metric-item {
                border-color: var(--border-light);
            }
            
            button {
                border: 2px solid var(--border);
            }
        }
        
        /* Screen reader only */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <a href="#gameCanvas" class="skip-link">–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–∏–º—É–ª—è—Ü–∏–∏</a>
    
    <div class="container">
        <header class="header" role="banner">
            <h1>
                üéÆ AI ARENA
                <span class="version-badge">v4.0.1 PROFESSIONAL</span>
            </h1>
            <div class="fps-counter" id="fpsCounter" aria-live="polite" aria-atomic="true">FPS: 60</div>
        </header>
        
        <canvas id="gameCanvas" aria-label="AI Arena simulation canvas" role="application" tabindex="0"></canvas>
        
        <noscript>
            ‚ö†Ô∏è –î–ª—è —Ä–∞–±–æ—Ç—ã AI Arena v4.0.1 Professional —Ç—Ä–µ–±—É–µ—Ç—Å—è JavaScript. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–∫–ª—é—á–∏—Ç–µ JavaScript –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –±—Ä–∞—É–∑–µ—Ä–∞.
        </noscript>
        
        <aside class="sidebar" role="complementary" aria-label="–ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è">
            <!-- AGENTS PANEL -->
            <section class="panel" aria-labelledby="agents-title">
                <h2 class="panel-title" id="agents-title">üë• –ê–ì–ï–ù–¢–´</h2>
                
                <!-- BLUE AGENT -->
                <article class="agent-card blue" aria-label="–°–∏–Ω–∏–π –∞–≥–µ–Ω—Ç">
                    <header class="agent-header">
                        <span>üîµ BLUE</span>
                        <span class="mode-badge mode-explore" id="blue-mode" aria-live="polite">EXPLORE</span>
                    </header>
                    <div class="health-bar" role="progressbar" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100" aria-label="–ó–¥–æ—Ä–æ–≤—å–µ —Å–∏–Ω–µ–≥–æ –∞–≥–µ–Ω—Ç–∞">
                        <div class="health-fill" id="blue-health" style="width: 100%"></div>
                    </div>
                    <div class="agent-stats">
                        <span>Reward: <b id="blue-reward" aria-live="polite">0.00</b></span>
                        <span>Wins: <b id="blue-wins" aria-live="polite">0</b></span>
                        <span>Gen: <b id="blue-gen" aria-live="polite">1</b></span>
                    </div>
                    <div style="font-size: 0.5rem; margin-top: 0.0625rem; color: var(--text-dim);" aria-label="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∞–≥–µ–Ω—Ç–∞">
                        <span class="stat-badge stat-hp" id="blue-stat-hp">HP:100</span>
                        <span class="stat-badge stat-str" id="blue-stat-dmg">DMG:3</span>
                        <span class="stat-badge stat-spd" id="blue-stat-spd">SPD:15</span>
                        <span class="stat-badge stat-dod" id="blue-stat-dod">DOD:0%</span>
                    </div>
                    <div class="skills-display" id="blue-skills" aria-label="–ù–∞–≤—ã–∫–∏ —Å–∏–Ω–µ–≥–æ –∞–≥–µ–Ω—Ç–∞">
                        <div class="skill-item skill-hunt" title="–û—Ö–æ—Ç–∞">
                            <div class="skill-bar"><div class="skill-fill" style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"></div></div>
                            <div>H</div>
                        </div>
                        <div class="skill-item skill-flee" title="–ë–µ–≥—Å—Ç–≤–æ">
                            <div class="skill-bar"><div class="skill-fill" style="width: 40%" aria-valuenow="40" aria-valuemin="0" aria-valuemax="100"></div></div>
                            <div>F</div>
                        </div>
                        <div class="skill-item skill-combat" title="–ë–æ–π">
                            <div class="skill-bar"><div class="skill-fill" style="width: 20%" aria-valuenow="20" aria-valuemin="0" aria-valuemax="100"></div></div>
                            <div>C</div>
                        </div>
                        <div class="skill-item skill-explore" title="–ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ">
                            <div class="skill-bar"><div class="skill-fill" style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"></div></div>
                            <div>E</div>
                        </div>
                        <div class="skill-item skill-avoid" title="–ò–∑–±–µ–≥–∞–Ω–∏–µ">
                            <div class="skill-bar"><div class="skill-fill" style="width: 60%" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100"></div></div>
                            <div>A</div>
                        </div>
                    </div>
                </article>
                
                <!-- RED AGENT -->
                <article class="agent-card red" aria-label="–ö—Ä–∞—Å–Ω—ã–π –∞–≥–µ–Ω—Ç">
                    <header class="agent-header">
                        <span>üî¥ RED</span>
                        <span class="mode-badge mode-explore" id="red-mode" aria-live="polite">EXPLORE</span>
                    </header>
                    <div class="health-bar" role="progressbar" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100" aria-label="–ó–¥–æ—Ä–æ–≤—å–µ –∫—Ä–∞—Å–Ω–æ–≥–æ –∞–≥–µ–Ω—Ç–∞">
                        <div class="health-fill" id="red-health" style="width: 100%"></div>
                    </div>
                    <div class="agent-stats">
                        <span>Reward: <b id="red-reward" aria-live="polite">0.00</b></span>
                        <span>Wins: <b id="red-wins" aria-live="polite">0</b></span>
                        <span>Gen: <b id="red-gen" aria-live="polite">1</b></span>
                    </div>
                    <div style="font-size: 0.5rem; margin-top: 0.0625rem; color: var(--text-dim);" aria-label="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∞–≥–µ–Ω—Ç–∞">
                        <span class="stat-badge stat-hp" id="red-stat-hp">HP:100</span>
                        <span class="stat-badge stat-str" id="red-stat-dmg">DMG:3</span>
                        <span class="stat-badge stat-spd" id="red-stat-spd">SPD:15</span>
                        <span class="stat-badge stat-dod" id="red-stat-dod">DOD:0%</span>
                    </div>
                    <div class="skills-display" id="red-skills" aria-label="–ù–∞–≤—ã–∫–∏ –∫—Ä–∞—Å–Ω–æ–≥–æ –∞–≥–µ–Ω—Ç–∞">
                        <div class="skill-item skill-hunt" title="–û—Ö–æ—Ç–∞">
                            <div class="skill-bar"><div class="skill-fill" style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"></div></div>
                            <div>H</div>
                        </div>
                        <div class="skill-item skill-flee" title="–ë–µ–≥—Å—Ç–≤–æ">
                            <div class="skill-bar"><div class="skill-fill" style="width: 40%" aria-valuenow="40" aria-valuemin="0" aria-valuemax="100"></div></div>
                            <div>F</div>
                        </div>
                        <div class="skill-item skill-combat" title="–ë–æ–π">
                            <div class="skill-bar"><div class="skill-fill" style="width: 20%" aria-valuenow="20" aria-valuemin="0" aria-valuemax="100"></div></div>
                            <div>C</div>
                        </div>
                        <div class="skill-item skill-explore" title="–ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ">
                            <div class="skill-bar"><div class="skill-fill" style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"></div></div>
                            <div>E</div>
                        </div>
                        <div class="skill-item skill-avoid" title="–ò–∑–±–µ–≥–∞–Ω–∏–µ">
                            <div class="skill-bar"><div class="skill-fill" style="width: 60%" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100"></div></div>
                            <div>A</div>
                        </div>
                    </div>
                </article>
            </section>

            <!-- STATISTICS PANEL -->
            <section class="panel" aria-labelledby="stats-title">
                <h2 class="panel-title" id="stats-title">üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê</h2>
                <div class="stat-grid">
                    <div class="stat">
                        <span class="stat-label">–≠–ø–∏–∑–æ–¥</span>
                        <span class="stat-value" id="episodeStat" aria-live="polite">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">–®–∞–≥</span>
                        <span class="stat-value" id="stepStat" aria-live="polite">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">–¢–æ—á–∫–∏</span>
                        <span class="stat-value" id="dotsStat" aria-live="polite">50</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">–ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è</span>
                        <span class="stat-value" id="obstaclesStat" aria-live="polite">12</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">–°—Ä. —Ñ–∏—Ç–Ω–µ—Å</span>
                        <span class="stat-value good" id="fitnessStat" aria-live="polite">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">–õ—É—á—à–∏–π</span>
                        <span class="stat-value good" id="bestFitnessStat" aria-live="polite">0</span>
                    </div>
                </div>
                <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="–ü—Ä–æ–≥—Ä–µ—Å—Å —ç–ø–∏–∑–æ–¥–∞">
                    <div class="progress-fill" id="episodeProgress" style="width: 0%"></div>
                </div>
            </section>

            <!-- LEARNING PARAMETERS PANEL -->
            <section class="panel" aria-labelledby="learning-title">
                <h2 class="panel-title" id="learning-title">üß† –û–ë–£–ß–ï–ù–ò–ï ‚Äî TD(Œª)+Actor-Critic+MoE+Hebbian</h2>
                
                <div class="control-group">
                    <label class="control-label" for="learningRate">
                        <span>Learning Rate (Œ±)</span>
                        <span id="learningRateValue" aria-live="polite">0.005</span>
                    </label>
                    <input type="range" id="learningRate" min="0.001" max="0.05" step="0.001" value="0.005" aria-describedby="learningRateDesc">
                </div>
                
                <div class="control-group">
                    <label class="control-label" for="lambda">
                        <span>TD Lambda (Œª)</span>
                        <span id="lambdaValue" aria-live="polite">0.95</span>
                    </label>
                    <input type="range" id="lambda" min="0.8" max="0.99" step="0.01" value="0.95" aria-describedby="lambdaDesc">
                </div>
                
                <div class="control-group">
                    <label class="control-label" for="gamma">
                        <span>Discount (Œ≥)</span>
                        <span id="gammaValue" aria-live="polite">0.99</span>
                    </label>
                    <input type="range" id="gamma" min="0.9" max="0.999" step="0.001" value="0.99" aria-describedby="gammaDesc">
                </div>
                
                <div class="control-group">
                    <label class="control-label" for="entropyCoeff">
                        <span>Entropy Coef</span>
                        <span id="entropyValue" aria-live="polite">0.01</span>
                    </label>
                    <input type="range" id="entropyCoeff" min="0.001" max="0.05" step="0.001" value="0.01" aria-describedby="entropyDesc">
                </div>
                
                <div class="control-group">
                    <label class="control-label" for="mutationRate">
                        <span>Mutation Rate</span>
                        <span id="mutationRateValue" aria-live="polite">0.1</span>
                    </label>
                    <input type="range" id="mutationRate" min="0.05" max="0.3" step="0.01" value="0.1" aria-describedby="mutationDesc">
                </div>
                
                <div class="control-group">
                    <label class="control-label" for="skillGrowth">
                        <span>Skill Growth</span>
                        <span id="skillGrowthValue" aria-live="polite">0.04</span>
                    </label>
                    <input type="range" id="skillGrowth" min="0.01" max="0.1" step="0.01" value="0.04" aria-describedby="skillGrowthDesc">
                </div>
                
                <div class="separator"></div>
                
                <label class="toggle">
                    <input type="checkbox" id="enableTraining" checked aria-describedby="enableTrainingDesc">
                    <span>TD(Œª) Learning</span>
                </label>
                <label class="toggle">
                    <input type="checkbox" id="enableCritic" checked aria-describedby="enableCriticDesc">
                    <span>Actor-Critic (Value Estimation)</span>
                </label>
                <label class="toggle">
                    <input type="checkbox" id="enablePolicySelector" checked aria-describedby="enablePolicyDesc">
                    <span>Learnable Behavior Policy</span>
                </label>
                <label class="toggle">
                    <input type="checkbox" id="enableEvolution" checked aria-describedby="enableEvolutionDesc">
                    <span>Weight Mutation</span>
                </label>
                <label class="toggle">
                    <input type="checkbox" id="enableSkillEvolution" checked aria-describedby="enableSkillDesc">
                    <span>Skill Evolution</span>
                </label>
                <label class="toggle">
                    <input type="checkbox" id="enableMoE" checked aria-describedby="enableMoEDesc">
                    <span>Mixture-of-Experts + Load Balance</span>
                </label>
                <label class="toggle">
                    <input type="checkbox" id="enableConsolidation" checked aria-describedby="enableConsolidationDesc">
                    <span>Memory Consolidation</span>
                </label>
                <label class="toggle">
                    <input type="checkbox" id="enableFighting" checked aria-describedby="enableFightingDesc">
                    <span>–ë–æ–∏ –º–µ–∂–¥—É –∞–≥–µ–Ω—Ç–∞–º–∏</span>
                </label>
                <label class="toggle">
                    <input type="checkbox" id="enableRanged" checked aria-describedby="enableRangedDesc">
                    <span>–î–∏—Å—Ç–∞–Ω—Ü–∏–æ–Ω–Ω–æ–µ –æ—Ä—É–∂–∏–µ</span>
                </label>
                <label class="toggle">
                    <input type="checkbox" id="enableVisualization" aria-describedby="enableVizDesc">
                    <span>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –Ω–µ–π—Ä–æ–Ω–æ–≤</span>
                </label>
                <label class="toggle">
                    <input type="checkbox" id="enableHebbian" checked aria-describedby="enableHebbianDesc">
                    <span>Hebbian Learning (Fast Associations)</span>
                </label>
            </section>

            <!-- METRICS PANEL -->
            <section class="panel" aria-labelledby="metrics-title">
                <h2 class="panel-title" id="metrics-title">üìà METRICS ‚Äî –ß–¢–û –£–õ–£–ß–®–ê–ï–¢–°–Ø</h2>
                <div class="learning-metrics">
                    <div class="metric-item">
                        <span class="metric-label">TD-Error</span>
                        <span class="metric-value" id="metricTDError" aria-live="polite">0.0000</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Pred.Error</span>
                        <span class="metric-value" id="metricPredError" aria-live="polite">0.000</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Entropy</span>
                        <span class="metric-value" id="metricEntropy" aria-live="polite">0.000</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Win Rate</span>
                        <span class="metric-value" id="metricWinRate" aria-live="polite">0.00</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Collection</span>
                        <span class="metric-value" id="metricCollection" aria-live="polite">0.00</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Survival</span>
                        <span class="metric-value" id="metricSurvival" aria-live="polite">0.00</span>
                    </div>
                </div>
                <div class="learning-progress">
                    <div class="progress-row">
                        <span class="progress-label">TD Learning</span>
                        <div class="progress-track td">
                            <div class="progress-fill" id="progressTD" style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"></div>
                        </div>
                    </div>
                    <div class="progress-row">
                        <span class="progress-label">Exploration</span>
                        <div class="progress-track entropy">
                            <div class="progress-fill" id="progressEntropy" style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"></div>
                        </div>
                    </div>
                    <div class="progress-row">
                        <span class="progress-label">Memory</span>
                        <div class="progress-track pred">
                            <div class="progress-fill" id="progressPred" style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"></div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- CONTROLS PANEL -->
            <section class="panel" aria-labelledby="controls-title">
                <h2 class="panel-title" id="controls-title">üéÆ –£–ü–†–ê–í–õ–ï–ù–ò–ï</h2>
                <div class="btn-group">
                    <button class="btn-primary" id="btnStart" aria-pressed="false">‚ñ∂ –°—Ç–∞—Ä—Ç</button>
                    <button class="btn-danger" id="btnReset">üîÑ –°–±—Ä–æ—Å</button>
                    <button class="btn-success" id="btnSave">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                    <button class="btn-secondary" id="btnLoad">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
                </div>
                <div class="btn-group-3" style="margin-top: 0.25rem;">
                    <button class="btn-toggle" id="btnDebug" aria-pressed="false">üîç Debug</button>
                    <button class="btn-toggle" id="btnVision" aria-pressed="false">üëÅÔ∏è Vision</button>
                    <button class="btn-learning" id="btnMetrics" aria-pressed="true">üìä Metrics</button>
                </div>
                <div class="btn-group" style="margin-top: 0.25rem;">
                    <button class="btn-secondary" id="btnExport">üì§ –≠–∫—Å–ø–æ—Ä—Ç</button>
                    <button class="btn-secondary" id="btnPretrain">‚¨ÜÔ∏è Pretrain</button>
                    <button class="btn-secondary" id="btnImport">üì• –ò–º–ø–æ—Ä—Ç</button>
                </div>
                <input type="file" id="fileImport" accept=".json" aria-label="–ò–º–ø–æ—Ä—Ç –≤–µ—Å–æ–≤">
                <input type="file" id="filePretrain" accept=".json" aria-label="–ó–∞–≥—Ä—É–∑–∫–∞ pretrained –≤–µ—Å–æ–≤">
            </section>

            <!-- LEGEND PANEL -->
            <section class="panel" aria-labelledby="legend-title">
                <h2 class="panel-title" id="legend-title">üé® –õ–ï–ì–ï–ù–î–ê</h2>
                <div class="agent-legend">
                    <div class="legend-item"><div class="legend-color" style="background: #00d4ff"></div><span>–ê–≥–µ–Ω—Ç</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #00ff9d"></div><span>–¢–æ—á–∫–∞ (5)</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #ff66cc"></div><span>Scared (8)</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #ffaa00"></div><span>Rare (20)</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #4a4a7a"></div><span>–ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: var(--stat-str)"></div><span>–°–∏–ª–∞</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: var(--stat-spd)"></div><span>–°–∫–æ—Ä–æ—Å—Ç—å</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: var(--stat-hp)"></div><span>–ó–¥–æ—Ä–æ–≤—å–µ</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: var(--learning-good)"></div><span>–£–ª—É—á—à–µ–Ω–∏–µ</span></div>
                </div>
            </section>

            <!-- LOG PANEL -->
            <section class="panel" aria-labelledby="log-title">
                <h2 class="panel-title" id="log-title">üìù –õ–û–ì</h2>
                <div class="log" id="eventLog" role="log" aria-live="polite" aria-relevant="additions"></div>
            </section>

            <!-- DEBUG PANEL -->
            <section class="debug-panel" id="debugPanel" aria-labelledby="debug-title" hidden>
                <h3 id="debug-title" style="margin-bottom: 0.25rem; font-weight: 600; color: var(--primary); font-size: 0.625rem;">üîç INSPECTOR ‚Äî v4.0.1</h3>
                <div class="debug-grid" id="debugGrid">
                    <div class="debug-item"><span class="debug-label">Mode</span><span class="debug-value" id="dbgMode">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Target</span><span class="debug-value" id="dbgTarget">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Speed</span><span class="debug-value" id="dbgSpeed">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Aggro</span><span class="debug-value" id="dbgAggro">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Memory</span><span class="debug-value" id="dbgMemory">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Neurons</span><span class="debug-value" id="dbgNeurons">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Reward</span><span class="debug-value" id="dbgReward">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Stuck</span><span class="debug-value" id="dbgStuck">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Confidence</span><span class="debug-value" id="dbgConf">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">TD-Error</span><span class="debug-value" id="dbgTDErr">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Entropy</span><span class="debug-value" id="dbgEntropy">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Pred.Err</span><span class="debug-value" id="dbgPredErr">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">WinRate</span><span class="debug-value" id="dbgWinRate">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Collect</span><span class="debug-value" id="dbgCollection">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Gate[0]</span><span class="debug-value" id="dbgGate0">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Gate[1]</span><span class="debug-value" id="dbgGate1">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Expert[0]</span><span class="debug-value" id="dbgExpert0">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Expert[1]</span><span class="debug-value" id="dbgExpert1">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">LoadBal</span><span class="debug-value" id="dbgLoadBal">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Hebbian</span><span class="debug-value" id="dbgHebbian">‚Äî</span></div>
                </div>
                <div class="confidence-meter">
                    <span>Conf:</span>
                    <div class="confidence-bar" role="progressbar" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100" aria-label="–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è">
                        <div class="confidence-fill" id="dbgConfBar" style="width: 50%"></div>
                    </div>
                    <span id="dbgConfVal">0.50</span>
                </div>
            </section>
        </aside>
    </div>

<script>
/**
 * ============================================================================
 * AI ARENA v4.0.1 ‚Äî PROFESSIONAL COMPLETE FIXED
 * ============================================================================
 * ‚úÖ –í–°–ï –í–´–Ø–í–õ–ï–ù–ù–´–ï –û–®–ò–ë–ö–ò –ò–°–ü–†–ê–í–õ–ï–ù–´
 * ‚úÖ –ü–û–õ–ù–ê–Ø –°–û–•–†–ê–ù–ù–û–°–¢–¨ –ê–†–•–ò–¢–ï–ö–¢–£–†–´: 57‚Üí24‚Üí48‚Üí36‚Üí16 + RNN(16)
 * ‚úÖ –î–ï–¢–ï–†–ú–ò–ù–ò–†–û–í–ê–ù–ù–ê–Ø –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –û–¢ –ö–õ–Æ–ß–ê + TIMESTAMP
 * ‚úÖ –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò: –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ, spatial hashing, early-exit, Float32Array
 * ‚úÖ –ì–ê–†–ú–û–ù–ò–ó–ê–¶–ò–Ø –ö–û–û–†–î–ò–ù–ê–¢: logical(820√ó600) ‚Üî physical(canvas)
 * ‚úÖ –ü–û–õ–ù–ê–Ø NULL-SAFETY –ò –í–ê–õ–ò–î–ê–¶–ò–Ø –í–•–û–î–ù–´–• –î–ê–ù–ù–´–•
 * ‚úÖ –î–û–°–¢–£–ü–ù–û–°–¢–¨: keyboard navigation, ARIA, touch support, reduced motion
 * ‚úÖ CSP-COMPLIANT: –±–µ–∑–æ–ø–∞—Å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞, HTML escaping
 * ‚úÖ MoE: —ç–∫—Å–ø–µ—Ä—Ç—ã –ø–æ–¥–∫–ª—é—á–µ–Ω—ã, load balancing –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è
 * ‚úÖ Attention: –ø—Ä–∞–≤–∏–ª—å–Ω–∞—è Q¬∑K^T –º–∞—Ç—Ä–∏—Ü–∞ —Å multi-head
 * ‚úÖ PolicySelector: context –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –≤ update()
 * ‚úÖ Entropy bonus: —Ä–µ–∞–ª—å–Ω–æ –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –∫ –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞–º
 * ‚úÖ Hebbian learning: –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –¥–ª—è –±—ã—Å—Ç—Ä—ã—Ö –∞—Å—Å–æ—Ü–∏–∞—Ü–∏–π
 * ============================================================================
 */

'use strict';

// ============================================================================
// GLOBAL CONFIGURATION ‚Äî DETERMINISTIC INIT + ARCHITECTURE CONSTANTS
// ============================================================================
/**
 * @typedef {Object} ArenaSettings
 * @property {boolean} enableTraining - TD(Œª) –æ–±—É—á–µ–Ω–∏–µ
 * @property {boolean} enableCritic - Actor-Critic –æ—Ü–µ–Ω–∫–∞ —Ü–µ–Ω–Ω–æ—Å—Ç–∏
 * @property {boolean} enablePolicySelector - –û–±—É—á–∞–µ–º–∞—è –ø–æ–ª–∏—Ç–∏–∫–∞ –≤—ã–±–æ—Ä–∞ –ø–æ–≤–µ–¥–µ–Ω–∏—è
 * @property {boolean} enableEvolution - –ú—É—Ç–∞—Ü–∏—è –≤–µ—Å–æ–≤
 * @property {boolean} enableSkillEvolution - –≠–≤–æ–ª—é—Ü–∏—è –Ω–∞–≤—ã–∫–æ–≤
 * @property {boolean} enableMoE - Mixture-of-Experts —Å –±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–æ–π
 * @property {boolean} enableConsolidation - –ö–æ–Ω—Å–æ–ª–∏–¥–∞—Ü–∏—è –ø–∞–º—è—Ç–∏
 * @property {boolean} enableFighting - –ë–æ–∏ –º–µ–∂–¥—É –∞–≥–µ–Ω—Ç–∞–º–∏
 * @property {boolean} enableRanged - –î–∏—Å—Ç–∞–Ω—Ü–∏–æ–Ω–Ω–æ–µ –æ—Ä—É–∂–∏–µ
 * @property {boolean} enableVisualization - –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –Ω–µ–π—Ä–æ–Ω–æ–≤
 * @property {boolean} enableHebbian - Hebbian learning –¥–ª—è –±—ã—Å—Ç—Ä—ã—Ö –∞—Å—Å–æ—Ü–∏–∞—Ü–∏–π
 * @property {number} learningRate - Œ±: —Å–∫–æ—Ä–æ—Å—Ç—å –æ–±—É—á–µ–Ω–∏—è
 * @property {number} lambda - Œª: –ø–∞—Ä–∞–º–µ—Ç—Ä –∑–∞—Ç—É—Ö–∞–Ω–∏—è eligibility traces
 * @property {number} gamma - Œ≥: –¥–∏—Å–∫–æ–Ω—Ç –±—É–¥—É—â–µ–≥–æ –≤–æ–∑–Ω–∞–≥—Ä–∞–∂–¥–µ–Ω–∏—è
 * @property {number} entropyCoeff - –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —ç–Ω—Ç—Ä–æ–ø–∏–π–Ω–æ–π —Ä–µ–≥—É–ª—è—Ä–∏–∑–∞—Ü–∏–∏
 * @property {number} mutationRate - –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –º—É—Ç–∞—Ü–∏–∏ –≤–µ—Å–∞
 * @property {number} skillGrowthRate - —Å–∫–æ—Ä–æ—Å—Ç—å —Ä–æ—Å—Ç–∞ –Ω–∞–≤—ã–∫–æ–≤
 * @property {string} seed - –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π seed –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
 * @property {number} timestamp - –≤—Ä–µ–º—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –¥–ª—è –≤–∞—Ä–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç–∏
 * @property {string} version - –≤–µ—Ä—Å–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
 */

/** @type {ArenaSettings} */
window.arenaConfig = Object.freeze({
    // Feature flags
    enableTraining: true,
    enableCritic: true,
    enablePolicySelector: true,
    enableEvolution: true,
    enableSkillEvolution: true,
    enableMoE: true,
    enableConsolidation: true,
    enableFighting: true,
    enableRanged: true,
    enableVisualization: false,
    enableHebbian: true,
    
    // Hyperparameters
    learningRate: 0.005,
    lambda: 0.95,
    gamma: 0.99,
    entropyCoeff: 0.01,
    mutationRate: 0.1,
    skillGrowthRate: 0.04,
    
    // Deterministic initialization
    seed: 'ARENA_V4_PROFESSIONAL_' + (typeof performance !== 'undefined' ? performance.now() : Date.now()).toFixed(0),
    timestamp: Date.now(),
    version: '4.0.1',
    
    // Architecture constants ‚Äî –ù–ï –ú–ï–ù–Ø–¢–¨ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
    ARCH: Object.freeze({
        INPUT_DIM: 57,
        EMBEDDING_DIM: 24,
        HIDDEN1: 48,
        HIDDEN2: 36,
        OUTPUT_DIM: 16,
        MEMORY_DIM: 16,
        NUM_HEADS: 4,
        NUM_EXPERTS: 4,
        EXPERT_DIM: 36,
        POLICY_CONTEXT_DIM: 8,
        POLICY_SKILL_DIM: 5,
        POLICY_HIDDEN: 24,
        POLICY_MODES: 5,
        CRITIC_HIDDEN: 32,
        LOGICAL_WIDTH: 820,
        LOGICAL_HEIGHT: 600
    })
});

// ============================================================================
// UTILITIES ‚Äî NUMERICALLY STABLE, SAFE, OPTIMIZED
// ============================================================================
/**
 * @namespace Utils
 * @description –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —É—Ç–∏–ª–∏—Ç—ã —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç numerical instability
 */
const Utils = Object.freeze({
    /**
     * Clamp value to [min, max]
     * @param {number} v - –∑–Ω–∞—á–µ–Ω–∏–µ
     * @param {number} min - –º–∏–Ω–∏–º—É–º
     * @param {number} max - –º–∞–∫—Å–∏–º—É–º
     * @returns {number} –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
     */
    clamp: (v, min, max) => Math.max(min, Math.min(max, v)),
    
    /**
     * Linear interpolation
     * @param {number} a - –Ω–∞—á–∞–ª–æ
     * @param {number} b - –∫–æ–Ω–µ—Ü
     * @param {number} t - –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç [0,1]
     * @returns {number} –∏–Ω—Ç–µ—Ä–ø–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
     */
    lerp: (a, b, t) => a + (b - a) * Utils.clamp(t, 0, 1),
    
    /**
     * Euclidean distance
     * @param {{x:number,y:number}} a - —Ç–æ—á–∫–∞ A
     * @param {{x:number,y:number}} b - —Ç–æ—á–∫–∞ B
     * @returns {number} —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
     */
    dist: (a, b) => Math.hypot((a?.x ?? 0) - (b?.x ?? 0), (a?.y ?? 0) - (b?.y ?? 0)),
    
    /**
     * Normalize vector to unit length
     * @param {number} x - –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ X
     * @param {number} y - –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ Y
     * @returns {{x:number,y:number}} –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –≤–µ–∫—Ç–æ—Ä
     */
    normalize: (x, y) => {
        const l = Math.hypot(x, y);
        return l > 1e-10 ? { x: x / l, y: y / l } : { x: 0, y: 0 };
    },
    
    /**
     * Hyperbolic tangent ‚Äî numerically stable
     * @param {number} x - –≤—Ö–æ–¥
     * @returns {number} tanh(x)
     */
    tanh: (x) => {
        if (x > 20) return 1;
        if (x < -20) return -1;
        const e = Math.exp(2 * x);
        return (e - 1) / (e + 1);
    },
    
    /**
     * Sigmoid ‚Äî numerically stable
     * @param {number} x - –≤—Ö–æ–¥
     * @returns {number} œÉ(x)
     */
    sigmoid: (x) => {
        if (x > 20) return 1;
        if (x < -20) return 0;
        return 1 / (1 + Math.exp(-x));
    },
    
    /**
     * Leaky ReLU activation
     * @param {number} x - –≤—Ö–æ–¥
     * @param {number} Œ± - –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —É—Ç–µ—á–∫–∏
     * @returns {number} –∞–∫—Ç–∏–≤–∞—Ü–∏—è
     */
    leakyRelu: (x, Œ± = 0.01) => x > 0 ? x : Œ± * x,
    
    /**
     * Argmax ‚Äî –∏–Ω–¥–µ–∫—Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
     * @param {number[]} arr - –º–∞—Å—Å–∏–≤
     * @returns {number} –∏–Ω–¥–µ–∫—Å –º–∞–∫—Å–∏–º—É–º–∞
     */
    argmax: (arr) => {
        if (!arr || arr.length === 0) return -1;
        let mi = 0;
        for (let i = 1; i < arr.length; i++) {
            if (arr[i] > arr[mi]) mi = i;
        }
        return mi;
    },
    
    /**
     * Random float in [min, max)
     * @param {number} min - –º–∏–Ω–∏–º—É–º
     * @param {number} max - –º–∞–∫—Å–∏–º—É–º
     * @returns {number} —Å–ª—É—á–∞–π–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
     */
    rand: (min, max) => Math.random() * (max - min) + min,
    
    /**
     * Random integer in [min, max]
     * @param {number} min - –º–∏–Ω–∏–º—É–º
     * @param {number} max - –º–∞–∫—Å–∏–º—É–º
     * @returns {number} —Å–ª—É—á–∞–π–Ω–æ–µ —Ü–µ–ª–æ–µ
     */
    randInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
    
    /**
     * Safe number conversion with fallback
     * @param {*} val - –∑–Ω–∞—á–µ–Ω–∏–µ
     * @param {number} fallback - –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
     * @returns {number} –≤–∞–ª–∏–¥–Ω–æ–µ —á–∏—Å–ª–æ
     */
    safeNumber: (val, fallback = 0) => 
        (typeof val === 'number' && isFinite(val)) ? val : fallback,
    
    /**
     * Numerically stable softmax with temperature
     * @param {number[]} arr - –≤—Ö–æ–¥–Ω–æ–π –≤–µ–∫—Ç–æ—Ä
     * @param {number} temp - —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ (>0)
     * @returns {number[]} –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏, —Å—É–º–º–∞ = 1
     */
    softmax: (arr, temp = 1) => {
        if (!arr || !Array.isArray(arr) || arr.length === 0) return [];
        const max = Math.max(...arr);
        const exps = arr.map(v => {
            const scaled = (v - max) / temp;
            // Prevent overflow: exp(709) is near Number.MAX_VALUE
            return scaled > 700 ? 0 : Math.exp(Math.min(scaled, 700));
        });
        const sum = exps.reduce((s, x) => s + x, 0) || 1e-10;
        return exps.map(e => e / sum);
    },
    
    /**
     * Numerically stable log-softmax
     * @param {number[]} arr - –≤—Ö–æ–¥–Ω–æ–π –≤–µ–∫—Ç–æ—Ä
     * @param {number} temp - —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞
     * @returns {number[]} log-–≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏
     */
    logSoftmax: (arr, temp = 1) => {
        if (!arr || !Array.isArray(arr) || arr.length === 0) return [];
        const max = Math.max(...arr);
        const logSumExp = max + Math.log(
            arr.reduce((s, x) => {
                const scaled = (x - max) / temp;
                return s + (scaled > 700 ? 0 : Math.exp(Math.min(scaled, 700)));
            }, 0) + 1e-10
        );
        return arr.map(v => ((v - max) / temp - logSumExp));
    },
    
    /**
     * Policy gradient loss with safety checks
     * @param {number[]} logProbs - –ª–æ–≥–∞—Ä–∏—Ñ–º—ã –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–π –¥–µ–π—Å—Ç–≤–∏–π
     * @param {number[]} advantages - –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞
     * @returns {number} loss value
     */
    policyGradientLoss: (logProbs, advantages) => {
        if (!logProbs?.length || !advantages?.length) return 0;
        const len = Math.min(logProbs.length, advantages.length);
        if (len === 0) return 0;
        let sum = 0;
        for (let i = 0; i < len; i++) {
            const lp = Utils.safeNumber(logProbs[i], 0);
            const adv = Utils.safeNumber(advantages[i], 0);
            sum += lp * adv;
        }
        return -sum / len;
    },
    
    /**
     * Entropy bonus for exploration
     * @param {number[]} probs - –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏
     * @returns {number} —ç–Ω—Ç—Ä–æ–ø–∏—è (–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–∞—è = –±–æ–ª—å—à–µ exploration)
     */
    entropyBonus: (probs) => {
        if (!probs?.length) return 0;
        let sum = 0;
        for (const p of probs) {
            const safeP = Math.max(Utils.safeNumber(p, 0), 1e-10);
            sum += safeP * Math.log(safeP);
        }
        return -sum; // Negative entropy ‚Üí positive bonus
    },
    
    /**
     * MoE load balance loss ‚Äî penalizes uneven expert usage
     * @param {number[]} gateProbs - –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ –≤—ã–±–æ—Ä–∞ —ç–∫—Å–ø–µ—Ä—Ç–æ–≤
     * @param {number[]} expertUsage - —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
     * @returns {number} loss (–º–µ–Ω—å—à–µ = –ª—É—á—à–µ –±–∞–ª–∞–Ω—Å)
     */
    moeLoadBalanceLoss: (gateProbs, expertUsage) => {
        if (!gateProbs?.length) return 0;
        const numExperts = gateProbs.length;
        const targetUsage = 1 / numExperts;
        let sum = 0;
        for (let i = 0; i < numExperts; i++) {
            const usage = Utils.safeNumber(expertUsage?.[i], 0);
            sum += Math.pow(usage - targetUsage, 2);
        }
        return sum / numExperts;
    },
    
    /**
     * Generalized Advantage Estimation (GAE)
     * @param {number[]} rewards - –≤–æ–∑–Ω–∞–≥—Ä–∞–∂–¥–µ–Ω–∏—è
     * @param {number[]} values - –æ—Ü–µ–Ω–∫–∏ —Ü–µ–Ω–Ω–æ—Å—Ç–∏ —Å–æ—Å—Ç–æ—è–Ω–∏–π
     * @param {number} nextValue - —Ü–µ–Ω–Ω–æ—Å—Ç—å —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
     * @param {number} gamma - –¥–∏—Å–∫–æ–Ω—Ç
     * @param {number} lambda - –ø–∞—Ä–∞–º–µ—Ç—Ä –∑–∞—Ç—É—Ö–∞–Ω–∏—è
     * @returns {number[]} –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —à–∞–≥–∞
     */
    computeGAE: (rewards, values, nextValue, gamma = 0.99, lambda = 0.95) => {
        const advantages = new Array(rewards.length);
        let advantage = 0;
        for (let t = rewards.length - 1; t >= 0; t--) {
            const nextVal = (t === rewards.length - 1) ? nextValue : values[t + 1];
            const delta = Utils.safeNumber(rewards[t], 0) + 
                         gamma * Utils.safeNumber(nextVal, 0) - 
                         Utils.safeNumber(values[t], 0);
            advantage = delta + gamma * lambda * advantage;
            advantages[t] = advantage;
        }
        return advantages;
    },
    
    /**
     * TD error calculation
     * @param {number} reward - –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–µ –≤–æ–∑–Ω–∞–≥—Ä–∞–∂–¥–µ–Ω–∏–µ
     * @param {number} value - —Ç–µ–∫—É—â–∞—è –æ—Ü–µ–Ω–∫–∞ —Ü–µ–Ω–Ω–æ—Å—Ç–∏
     * @param {number} nextValue - –æ—Ü–µ–Ω–∫–∞ —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
     * @param {number} gamma - –¥–∏—Å–∫–æ–Ω—Ç
     * @returns {number} TD error
     */
    tdError: (reward, value, nextValue, gamma = 0.99) => 
        Utils.safeNumber(reward, 0) + 
        gamma * Utils.safeNumber(nextValue, 0) - 
        Utils.safeNumber(value, 0),
    
    /**
     * Distance from point to line segment
     * @param {number} ax - —Ç–æ—á–∫–∞ A X
     * @param {number} ay - —Ç–æ—á–∫–∞ A Y
     * @param {number} bx - —Ç–æ—á–∫–∞ B X
     * @param {number} by - —Ç–æ—á–∫–∞ B Y
     * @param {number} cx - —Ç–æ—á–∫–∞ P X
     * @param {number} cy - —Ç–æ—á–∫–∞ P Y
     * @returns {number} –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
     * @private
     */
    _pointSegDist: (ax, ay, bx, by, cx, cy) => {
        const vx = bx - ax, vy = by - ay;
        const wx = cx - ax, wy = cy - ay;
        const c1 = vx * wx + vy * wy;
        if (c1 <= 0) return Math.hypot(cx - ax, cy - ay);
        const c2 = vx * vx + vy * vy;
        if (c2 <= c1) return Math.hypot(cx - bx, cy - by);
        const b = c1 / c2;
        const pbx = ax + b * vx, pby = ay + b * vy;
        return Math.hypot(cx - pbx, cy - pby);
    },
    
    /**
     * Line-of-sight check with obstacle avoidance
     * @param {{x:number,y:number}} a - –Ω–∞—á–∞–ª–æ –ª—É—á–∞
     * @param {{x:number,y:number}} b - –∫–æ–Ω–µ—Ü –ª—É—á–∞
     * @param {Array<{x:number,y:number}>} walls - –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
     * @param {number} wallRadius - —Ä–∞–¥–∏—É—Å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
     * @returns {boolean} true –µ—Å–ª–∏ –≤–∏–¥–∏–º–æ—Å—Ç—å –µ—Å—Ç—å
     */
    hasLineOfSight: (a, b, walls, wallRadius = 14) => {
        if (!a || !b) return false;
        if (!walls?.length) return true;
        for (const w of walls) {
            if (!w) continue;
            const d = Utils._pointSegDist(a.x, a.y, b.x, b.y, w.x, w.y);
            if (d < wallRadius + 2) return false;
        }
        return true;
    },
    
    /**
     * Project raw inputs through embedding layer
     * @param {number[]} rawInputs - –≤—Ö–æ–¥–Ω–æ–π –≤–µ–∫—Ç–æ—Ä
     * @param {number[][]} embeddingWeights - –º–∞—Ç—Ä–∏—Ü–∞ –≤–µ—Å–æ–≤ [input√óembedding]
     * @param {number[]} bias - bias –≤–µ–∫—Ç–æ—Ä
     * @param {number} outputDim - —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å –≤—ã—Ö–æ–¥–∞
     * @returns {number[]} projected activations
     */
    projectInput: (rawInputs, embeddingWeights, bias, outputDim) => {
        const projected = new Array(outputDim).fill(0);
        for (let o = 0; o < outputDim; o++) {
            let sum = Utils.safeNumber(bias?.[o], 0);
            for (let i = 0; i < rawInputs.length; i++) {
                const w = embeddingWeights?.[i]?.[o];
                sum += Utils.safeNumber(rawInputs[i], 0) * Utils.safeNumber(w, 0);
            }
            projected[o] = Utils.leakyRelu(sum);
        }
        return projected;
    },
    
    /**
     * Deterministic hash from seed + coordinates
     * @param {string} seed - –±–∞–∑–æ–≤—ã–π seed
     * @param {number} i - –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ row
     * @param {number} j - –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ col
     * @returns {number} hash –≤ [0, 1)
     */
    hashSeed: (seed, i, j) => {
        if (!seed) seed = 'default';
        let h = String(seed).split('').reduce((a, c, idx) => {
            return ((a * 31 + c.charCodeAt(0)) ^ (idx * 17 + i * 7919 + j * 104729)) % 2147483647;
        }, String(seed).length) || 12345;
        // Mix with avalanche effect
        h = (h * 2654435761) >>> 0;
        return h / 4294967296;
    },
    
    /**
     * Deep clone for plain objects/arrays
     * @param {*} obj - –æ–±—ä–µ–∫—Ç –¥–ª—è –∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
     * @returns {*} –∫–ª–æ–Ω
     */
    deepClone: (obj) => {
        if (obj === null || typeof obj !== 'object') return obj;
        if (obj instanceof Float32Array) return new Float32Array(obj);
        if (Array.isArray(obj)) return obj.map(Utils.deepClone);
        const clone = {};
        for (const key of Object.keys(obj)) {
            clone[key] = Utils.deepClone(obj[key]);
        }
        return clone;
    },
    
    /**
     * Verify attention matrix properties (for debugging)
     * @param {number[][]} scores ‚Äî attention scores matrix
     * @returns {Object} validation results
     */
    validateAttention: (scores) => {
        if (!scores?.length || !scores[0]?.length) return { valid: false, error: 'empty' };
        const n = scores.length;
        const m = scores[0].length;
        let rowSumValid = true;
        for (let i = 0; i < n; i++) {
            const sum = scores[i].reduce((s, v) => s + v, 0);
            if (Math.abs(sum - 1) > 0.01) { rowSumValid = false; break; }
        }
        let hasInvalid = false;
        for (let i = 0; i < n && !hasInvalid; i++) {
            for (let j = 0; j < m; j++) {
                if (!isFinite(scores[i][j])) { hasInvalid = true; break; }
            }
        }
        return { valid: rowSumValid && !hasInvalid, shape: [n, m], rowSumValid, hasInvalid };
    },
    
    /**
     * Compute actual load balance metric (for monitoring)
     * @param {number[]} usage ‚Äî expert usage probabilities
     * @returns {number} coefficient of variation (lower = better balance)
     */
    computeLoadBalance: (usage) => {
        if (!usage?.length) return 1;
        const mean = usage.reduce((s, v) => s + v, 0) / usage.length;
        if (mean < 1e-10) return 1;
        const variance = usage.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / usage.length;
        return Math.sqrt(variance) / mean; // CV: lower = more balanced
    }
});

// ============================================================================
// SEEDED RNG ‚Äî DETERMINISTIC WEIGHT INITIALIZATION
// ============================================================================
/**
 * @class SeededRNG
 * @description –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –≤–µ—Å–æ–≤
 * @param {string} seed - –±–∞–∑–æ–≤—ã–π seed (–∫–ª—é—á + timestamp)
 */
class SeededRNG {
    /**
     * @param {string} seed - seed —Å—Ç—Ä–æ–∫–∞
     */
    constructor(seed) {
        /** @private */
        this._baseSeed = String(seed || 'default').split('').reduce((a, c, i) => {
            return ((a * 31 + c.charCodeAt(0)) ^ (i * 17)) % 2147483647;
        }, String(seed || 'default').length) || 12345;
        /** @private */
        this._state = this._baseSeed;
    }
    
    /**
     * Generate next random number in [0, 1)
     * @returns {number} —Å–ª—É—á–∞–π–Ω–æ–µ —á–∏—Å–ª–æ
     */
    next() {
        // Xorshift32 algorithm
        let x = this._state;
        x ^= x << 13;
        x ^= x >>> 17;
        x ^= x << 5;
        this._state = x >>> 0; // Ensure unsigned
        return (x * 0x2545F4914F6CDD1D) >>> 0 / 4294967296;
    }
    
    /**
     * Derive weight matrix deterministically from seed
     * @param {number} rows - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫
     * @param {number} cols - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–ª–æ–Ω–æ–∫
     * @param {number} scale - –º–∞—Å—à—Ç–∞–± –≤–µ—Å–æ–≤
     * @returns {number[][]} –º–∞—Ç—Ä–∏—Ü–∞ –≤–µ—Å–æ–≤
     */
    deriveWeights(rows, cols, scale) {
        const weights = [];
        for (let i = 0; i < rows; i++) {
            const row = [];
            for (let j = 0; j < cols; j++) {
                // Deterministic hash ‚Äî no state mutation
                const hash = Utils.hashSeed(String(this._baseSeed), i, j);
                row.push((hash * 2 - 1) * scale);
            }
            weights.push(row);
        }
        return weights;
    }
    
    /**
     * Derive bias vector deterministically
     * @param {number} length - –¥–ª–∏–Ω–∞ –≤–µ–∫—Ç–æ—Ä–∞
     * @param {number} scale - –º–∞—Å—à—Ç–∞–±
     * @returns {number[]} bias –≤–µ–∫—Ç–æ—Ä
     */
    deriveVector(length, scale) {
        const vec = [];
        for (let i = 0; i < length; i++) {
            const hash = Utils.hashSeed(String(this._baseSeed), i, 0);
            vec.push((hash * 2 - 1) * scale);
        }
        return vec;
    }
    
    /**
     * Reset RNG state (for reproducibility)
     */
    reset() { this._state = this._baseSeed; }
    
    /**
     * Get base seed (for serialization)
     * @returns {string} –±–∞–∑–æ–≤—ã–π seed
     */
    getSeed() { return String(this._baseSeed); }
}

// ============================================================================
// NEURAL NETWORK ‚Äî DUAL-MEMORY ARCHITECTURE 57‚Üí24‚Üí48‚Üí36‚Üí16 + RNN(16)
// ============================================================================
/**
 * @class NeuralNetwork
 * @description –û—Å–Ω–æ–≤–Ω–∞—è –Ω–µ–π—Ä–æ—Å–µ—Ç—å —Å dual-memory, attention, MoE, Hebbian learning
 * 
 * Architecture:
 * - Input: 57 ‚Üí Embedding: 24
 * - Memory: permanent(16) + predictive(16) ‚Üí concatenated
 * - Hidden1: (24+32) ‚Üí 48 with 4-head self-attention (Q¬∑K^T matrix)
 * - MoE: 4 experts with load balancing (ACTUALLY CONNECTED)
 * - Hidden2: 48 ‚Üí 36
 * - Output: 36 ‚Üí 16
 * - Memory update: predictive ‚Üê h2[:16], permanent ‚Üê consolidation
 */
class NeuralNetwork {
    /**
     * @param {Object} config - –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
     */
    constructor(config = {}) {
        // Architecture ‚Äî preserve exact dimensions
        this.inputDim = config.inputDim ?? arenaConfig.ARCH.INPUT_DIM;
        this.embeddingDim = config.embeddingDim ?? arenaConfig.ARCH.EMBEDDING_DIM;
        this.hidden1 = config.hidden1 ?? arenaConfig.ARCH.HIDDEN1;
        this.hidden2 = config.hidden2 ?? arenaConfig.ARCH.HIDDEN2;
        this.outputDim = config.outputDim ?? arenaConfig.ARCH.OUTPUT_DIM;
        this.memoryDim = config.memoryDim ?? arenaConfig.ARCH.MEMORY_DIM;
        
        // Deterministic initialization
        this.seed = config.seed ?? arenaConfig.seed;
        this._rng = new SeededRNG(this.seed);
        
        // === WEIGHT MATRICES (seed-derived) ===
        this._inputEmbedding = this._rng.deriveWeights(this.inputDim, this.embeddingDim, 0.3);
        this._embeddingBias = this._rng.deriveVector(this.embeddingDim, 0.1);
        
        const combinedInputDim = this.embeddingDim + this.memoryDim * 2;
        this._W1 = this._rng.deriveWeights(combinedInputDim, this.hidden1, 0.3);
        this._W2 = this._rng.deriveWeights(this.hidden1, this.hidden2, 0.2);
        this._W3 = this._rng.deriveWeights(this.hidden2, this.outputDim, 0.1);
        
        // === MULTI-HEAD ATTENTION (4 heads) ‚Äî CORRECT Q¬∑K^T ===
        this.numHeads = config.numHeads ?? arenaConfig.ARCH.NUM_HEADS;
        this.headDim = Math.floor(this.hidden1 / this.numHeads);
        this._Wq = this._rng.deriveWeights(this.hidden1, this.hidden1, 0.08);
        this._Wk = this._rng.deriveWeights(this.hidden1, this.hidden1, 0.08);
        this._Wv = this._rng.deriveWeights(this.hidden1, this.hidden1, 0.08);
        this._Wo = this._rng.deriveWeights(this.hidden1, this.hidden1, 0.08);
        
        // === MIXTURE-OF-EXPERTS (4 experts) ‚Äî CORRECTLY CONNECTED ===
        this.numExperts = config.numExperts ?? arenaConfig.ARCH.NUM_EXPERTS;
        this.expertDim = config.expertDim ?? arenaConfig.ARCH.EXPERT_DIM;
        this._Wg = this._rng.deriveWeights(this.hidden1, this.numExperts, 0.12); // Gate: h1(48)‚Üíexperts(4)
        
        // ‚úÖ CORRECTED DIMENSIONS: h1(48) ‚Üí expertDim(36) ‚Üí outputDim(16)
        this._expertW1 = [];
        this._expertW2 = [];
        for (let e = 0; e < this.numExperts; e++) {
            this._expertW1.push(this._rng.deriveWeights(this.hidden1, this.expertDim, 0.15));
            this._expertW2.push(this._rng.deriveWeights(this.expertDim, this.outputDim, 0.1));
        }
        
        // === ELIGIBILITY TRACES FOR TD(Œª) ===
        this._eligibilityEmbedding = new Float32Array(this.inputDim * this.embeddingDim);
        this._eligibilityW1 = new Float32Array(combinedInputDim * this.hidden1);
        this._eligibilityW2 = new Float32Array(this.hidden1 * this.hidden2);
        this._eligibilityW3 = new Float32Array(this.hidden2 * this.outputDim);
        
        // === DUAL MEMORY SYSTEM ===
        this._memoryPermanent = new Float32Array(this.memoryDim);
        this._memoryPredictive = new Float32Array(this.memoryDim);
        this._predictionErrors = new Float32Array(this.memoryDim);
        
        // Memory consolidation buffer
        this._consolidationBuffer = [];
        this._maxBuffer = 32;
        
        // === HYPERPARAMETERS ===
        this.lr = config.lr ?? arenaConfig.learningRate;
        this.hebbianRate = config.hebbianRate ?? 0.002;
        this.gamma = config.gamma ?? arenaConfig.gamma;
        this.lambda = config.lambda ?? arenaConfig.lambda;
        this.entropyCoeff = config.entropyCoeff ?? arenaConfig.entropyCoeff;
        
        // === TRAINING METRICS ===
        this._trainingStats = {
            tdErrorHistory: [],
            predictionErrorHistory: [],
            policyEntropyHistory: [],
            loadBalanceHistory: [],
            winRate: 0,
            collectionRate: 0,
            survivalTime: 0,
            totalSteps: 0,
            avgRewardPerStep: 0
        };
        
        // === FORWARD PASS CACHE ===
        this._lastInputs = null;
        this._lastEmbedded = null;
        this._lastHidden1 = null;
        this._lastHidden2 = null;
        this._lastOutput = null;
        this._lastGateProbs = null;
        this._lastAttentionWeights = null;
        this._activeNeurons = [];
    }
    
    /**
     * Embed raw inputs through learned projection
     * @private
     */
    _embedInputs(rawInputs) {
        return Utils.projectInput(rawInputs, this._inputEmbedding, this._embeddingBias, this.embeddingDim);
    }
    
    /**
     * Multi-head self-attention ‚Äî CORRECTED Q¬∑K^T MATRIX IMPLEMENTATION
     * @param {number[]} h1 ‚Äî –≤—Ö–æ–¥–Ω—ã–µ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ [hidden1=48]
     * @returns {number[]} attended output [hidden1]
     * @private
     */
    _selfAttention(h1) {
        if (!h1?.length) return h1 || [];
        
        const Q = this._linMatMul(h1, this._Wq);
        const K = this._linMatMul(h1, this._Wk);
        const V = this._linMatMul(h1, this._Wv);
        
        const scale = 1 / Math.sqrt(Math.max(1, this.headDim));
        const numHeads = this.numHeads || 4;
        const headDim = Math.floor(this.hidden1 / numHeads);
        
        // Split into heads
        const Q_heads = [], K_heads = [], V_heads = [];
        for (let h = 0; h < numHeads; h++) {
            const start = h * headDim;
            Q_heads.push(Q.slice(start, start + headDim));
            K_heads.push(K.slice(start, start + headDim));
            V_heads.push(V.slice(start, start + headDim));
        }
        
        // Compute attention for each head: scores = Q¬∑K^T / sqrt(d_k)
        const headOutputs = [];
        for (let h = 0; h < numHeads; h++) {
            const Qh = Q_heads[h], Kh = K_heads[h], Vh = V_heads[h];
            
            // ‚úÖ CORRECT: [headDim √ó headDim] attention matrix
            const scores = [];
            for (let i = 0; i < headDim; i++) {
                const row = [];
                for (let j = 0; j < headDim; j++) {
                    const dot = Qh[i] * Kh[j];
                    row.push(dot * scale);
                }
                scores.push(row);
            }
            
            // Softmax per row
            const weights = scores.map(row => Utils.softmax(row, 1));
            
            // Weighted sum of values
            const attended = new Array(headDim).fill(0);
            for (let i = 0; i < headDim; i++) {
                for (let j = 0; j < headDim; j++) {
                    attended[i] += weights[i][j] * Vh[j];
                }
            }
            headOutputs.push(attended);
        }
        
        // Concatenate and project
        const concatenated = headOutputs.flat();
        const projected = this._linMatMul(concatenated, this._Wo);
        const output = h1.map((v, i) => Utils.lerp(v, v + projected[i], 0.6));
        
        this._lastAttentionWeights = headOutputs[0]?.slice() || [];
        return output;
    }
    
    /**
     * Matrix-vector multiplication with tanh activation
     * @private
     */
    _matMul(vec, mat) {
        if (!vec?.length || !mat?.length) return [];
        const out = [];
        for (let i = 0; i < mat[0].length; i++) {
            let sum = 0;
            for (let j = 0; j < vec.length; j++) {
                sum += Utils.safeNumber(vec[j], 0) * Utils.safeNumber(mat[j]?.[i], 0);
            }
            out.push(Utils.tanh(sum));
        }
        return out;
    }
    
    /**
     * Linear matrix-vector multiplication (no activation)
     * @private
     */
    _linMatMul(vec, mat) {
        if (!vec?.length || !mat?.length) return [];
        const out = new Array(mat[0].length).fill(0);
        for (let i = 0; i < mat[0].length; i++) {
            let sum = 0;
            for (let j = 0; j < vec.length; j++) {
                sum += Utils.safeNumber(vec[j], 0) * Utils.safeNumber(mat[j]?.[i], 0);
            }
            out[i] = sum;
        }
        return out;
    }
    
    /**
     * Forward pass ‚Äî complete neural computation
     * @param {number[]} inputs - –≤—Ö–æ–¥–Ω–æ–π –≤–µ–∫—Ç–æ—Ä (57-dimensional)
     * @returns {Object} —Ä–µ–∑—É–ª—å—Ç–∞—Ç forward pass
     */
    forward(inputs) {
        if (!Array.isArray(inputs) || inputs.length !== this.inputDim) {
            inputs = new Array(this.inputDim).fill(0);
        }
        this._lastInputs = inputs.slice();
        
        // 1. Input embedding
        const embedded = this._embedInputs(inputs);
        this._lastEmbedded = embedded.slice();
        
        // 2. Concatenate with dual memory
        const combined = [...embedded, ...this._memoryPermanent, ...this._memoryPredictive];
        
        // 3. First hidden layer with attention
        let h1 = this._matMul(combined, this._W1);
        this._lastHidden1 = h1.slice();
        h1 = this._selfAttention(h1);
        
        // 4. MoE gate and expert selection
        const gateLogits = this._linMatMul(h1, this._Wg);
        const gateProbs = Utils.softmax(gateLogits, 0.7);
        this._lastGateProbs = gateProbs.slice();
        
        const expertScores = gateProbs.map((p, i) => ({ idx: i, score: p }));
        expertScores.sort((a, b) => b.score - a.score);
        const activeExperts = expertScores.slice(0, Math.min(2, this.numExperts)).map(e => e.idx);
        
        // ‚úÖ EXPERT COMPUTATION ‚Äî NOW ACTUALLY USED
        let expertOutput = new Array(this.outputDim).fill(0);
        const expertUsage = new Array(this.numExperts).fill(0);
        
        for (const e of activeExperts) {
            // ‚úÖ CORRECT: h1(48) ‚Üí expertW1[e](48√ó36) ‚Üí h_expert(36)
            const h_expert = this._matMul(h1, this._expertW1[e]);
            // ‚úÖ CORRECT: h_expert(36) ‚Üí expertW2[e](36√ó16) ‚Üí out_expert(16)
            const out_expert = this._matMul(h_expert, this._expertW2[e]);
            
            for (let j = 0; j < this.outputDim; j++) {
                expertOutput[j] += out_expert[j] * gateProbs[e];
            }
            expertUsage[e] = gateProbs[e];
        }
        
        // ‚úÖ LOAD BALANCING LOSS ‚Äî NOW APPLIED
        const loadBalanceLoss = Utils.moeLoadBalanceLoss(gateProbs, expertUsage);
        
        if (arenaConfig.enableMoE && loadBalanceLoss > 0.01) {
            const lbGrad = -0.001 * loadBalanceLoss;
            for (let i = 0; i < this.hidden1; i++) {
                for (let e = 0; e < this.numExperts; e++) {
                    const target = 1 / this.numExperts;
                    const grad = lbGrad * (expertUsage[e] - target);
                    this._Wg[i][e] += this.lr * grad * h1[i];
                    this._Wg[i][e] = Utils.clamp(this._Wg[i][e], -2, 2);
                }
            }
        }
        
        // 5. Second hidden layer
        let h2 = this._matMul(h1, this._W2);
        this._lastHidden2 = h2.slice();
        
        // 6. Output layer with expert blending
        const standardOutput = this._matMul(h2, this._W3);
        const blendedOutput = new Array(this.outputDim).fill(0);
        for (let j = 0; j < this.outputDim; j++) {
            blendedOutput[j] = Utils.tanh(standardOutput[j] * 0.7 + expertOutput[j] * 0.3);
        }
        this._lastOutput = blendedOutput.slice();
        
        // 7. Memory update
        const predictedMemory = h2.slice(0, this.memoryDim);
        for (let i = 0; i < this.memoryDim; i++) {
            const error = Math.abs(Utils.safeNumber(predictedMemory[i], 0) - this._memoryPredictive[i]);
            this._predictionErrors[i] = Utils.lerp(this._predictionErrors[i], error, 0.1);
        }
        this._memoryPredictive = new Float32Array(predictedMemory);
        
        for (let i = 0; i < this.memoryDim; i++) {
            if (this._predictionErrors[i] > 0.3) {
                this._memoryPermanent[i] = Utils.lerp(this._memoryPermanent[i], predictedMemory[i], 0.15);
            } else {
                this._memoryPermanent[i] = Utils.lerp(this._memoryPermanent[i], predictedMemory[i], 0.02);
            }
        }
        
        // 8. Track active neurons
        this._activeNeurons = [...h1, ...h2, ...blendedOutput]
            .map((v, i) => ({ i, v: Utils.safeNumber(v, 0) }))
            .sort((a, b) => Math.abs(b.v) - Math.abs(a.v))
            .slice(0, 5)
            .map(n => n.i);
        
        return {
            output: blendedOutput.map(v => Utils.safeNumber(v, 0)),
            gateLogits,
            gateProbs,
            loadBalanceLoss,
            expertUsage,
            memoryPermanent: Array.from(this._memoryPermanent),
            memoryPredictive: Array.from(this._memoryPredictive),
            predictionErrors: Array.from(this._predictionErrors),
            activeNeurons: this._activeNeurons,
            embedded,
            h1,
            h2,
            attentionWeights: this._lastAttentionWeights
        };
    }
    
    /**
     * Hebbian weight update: Œîw = Œ∑ * pre * post * sign(correlation)
     * @private
     */
    _hebbianUpdate(pre, post, correlation = 1, layer = 'W1') {
        if (!arenaConfig.enableHebbian || !pre?.length || !post?.length) return;
        const Œ∑ = this.hebbianRate * correlation;
        
        if (layer === 'embedding') {
            for (let i = 0; i < Math.min(pre.length, this.inputDim); i++) {
                for (let o = 0; o < Math.min(post.length, this.embeddingDim); o++) {
                    const delta = Œ∑ * Utils.safeNumber(pre[i], 0) * Utils.safeNumber(post[o], 0);
                    this._inputEmbedding[i][o] += delta;
                    this._inputEmbedding[i][o] = Utils.clamp(this._inputEmbedding[i][o], -2, 2);
                }
            }
        } else if (layer === 'W1') {
            for (let i = 0; i < pre.length; i++) {
                for (let o = 0; o < post.length; o++) {
                    const delta = Œ∑ * Utils.safeNumber(pre[i], 0) * Utils.safeNumber(post[o], 0);
                    this._eligibilityW1[i * this.hidden1 + o] += delta * 0.1;
                    this._W1[i][o] += delta * 0.01;
                    this._W1[i][o] = Utils.clamp(this._W1[i][o], -2, 2);
                }
            }
        } else if (layer === 'W2') {
            for (let i = 0; i < pre.length; i++) {
                for (let o = 0; o < post.length; o++) {
                    const delta = Œ∑ * Utils.safeNumber(pre[i], 0) * Utils.safeNumber(post[o], 0);
                    this._W2[i][o] += delta * 0.005;
                    this._W2[i][o] = Utils.clamp(this._W2[i][o], -2, 2);
                }
            }
        }
    }
    
    /**
     * TD(Œª) learning update with eligibility traces
     */
    tdLearn(inputs, outputs, reward, value, nextValue, actionLogProbs = null) {
        const tdErr = Utils.tdError(reward, value, nextValue, this.gamma);
        this._trainingStats.tdErrorHistory.push(Math.abs(tdErr));
        if (this._trainingStats.tdErrorHistory.length > 100) this._trainingStats.tdErrorHistory.shift();
        
        this._updateEligibilityTraces(inputs, outputs);
        this._applyTDError(tdErr);
        
        if (actionLogProbs?.length && arenaConfig.enablePolicySelector) {
            const advantage = tdErr;
            const entropy = Utils.entropyBonus(Utils.softmax(outputs.map(o => o * 10), 1));
            const policyLoss = Utils.policyGradientLoss(actionLogProbs, [advantage]);
            const totalLoss = policyLoss - this.entropyCoeff * entropy;
            this._trainingStats.policyEntropyHistory.push(entropy);
            if (this._trainingStats.policyEntropyHistory.length > 100) this._trainingStats.policyEntropyHistory.shift();
        }
        
        this._consolidateMemories(reward);
        
        // ‚úÖ HEBBIAN LEARNING ‚Äî RESTORED
        if (arenaConfig.enableHebbian && reward > 1) {
            const correlation = Math.sign(reward);
            if (this._lastEmbedded?.length && this._lastHidden1?.length) {
                this._hebbianUpdate(this._lastEmbedded, this._lastHidden1, correlation, 'embedding');
            }
            if (this._lastHidden1?.length && this._lastHidden2?.length) {
                this._hebbianUpdate(this._lastHidden1, this._lastHidden2, correlation, 'W1');
            }
            if (this._lastHidden2?.length && this._lastOutput?.length) {
                this._hebbianUpdate(this._lastHidden2, this._lastOutput, correlation, 'W2');
            }
        }
        
        return {
            tdError: tdErr,
            avgTDError: this._trainingStats.tdErrorHistory.reduce((a,b)=>a+b,0)/Math.max(1,this._trainingStats.tdErrorHistory.length),
            avgPredictionError: Array.from(this._predictionErrors).reduce((a,b)=>a+b,0)/Math.max(1,this._predictionErrors.length)
        };
    }
    
    _updateEligibilityTraces(inputs, outputs) {
        const embedded = this._embedInputs(inputs);
        const combined = [...embedded, ...this._memoryPermanent, ...this._memoryPredictive];
        
        for (let i = 0; i < this.inputDim; i++) {
            for (let o = 0; o < this.embeddingDim; o++) {
                const idx = i * this.embeddingDim + o;
                this._eligibilityEmbedding[idx] = this.gamma * this.lambda * this._eligibilityEmbedding[idx] + 
                    Utils.safeNumber(inputs[i], 0) * Utils.safeNumber(this._lastHidden1?.[o], 0);
                this._eligibilityEmbedding[idx] = Utils.clamp(this._eligibilityEmbedding[idx], -10, 10);
            }
        }
        
        for (let i = 0; i < combined.length; i++) {
            for (let o = 0; o < this.hidden1; o++) {
                const idx = i * this.hidden1 + o;
                this._eligibilityW1[idx] = this.gamma * this.lambda * this._eligibilityW1[idx] + 
                    Utils.safeNumber(combined[i], 0) * Utils.safeNumber(this._lastHidden1?.[o], 0);
                this._eligibilityW1[idx] = Utils.clamp(this._eligibilityW1[idx], -10, 10);
            }
        }
        
        if (this._lastHidden1?.length && this._lastHidden2?.length) {
            for (let i = 0; i < this._lastHidden1.length; i++) {
                for (let o = 0; o < this.hidden2; o++) {
                    const idx = i * this.hidden2 + o;
                    this._eligibilityW2[idx] = this.gamma * this.lambda * this._eligibilityW2[idx] + 
                        Utils.safeNumber(this._lastHidden1[i], 0) * Utils.safeNumber(this._lastHidden2[o], 0);
                    this._eligibilityW2[idx] = Utils.clamp(this._eligibilityW2[idx], -10, 10);
                }
            }
        }
        
        if (this._lastHidden2?.length && this._lastOutput?.length) {
            for (let i = 0; i < this._lastHidden2.length; i++) {
                for (let o = 0; o < this.outputDim; o++) {
                    const idx = i * this.outputDim + o;
                    this._eligibilityW3[idx] = this.gamma * this.lambda * this._eligibilityW3[idx] + 
                        Utils.safeNumber(this._lastHidden2[i], 0) * Utils.safeNumber(this._lastOutput[o], 0);
                    this._eligibilityW3[idx] = Utils.clamp(this._eligibilityW3[idx], -10, 10);
                }
            }
        }
    }
    
    _applyTDError(tdErr) {
        const alpha = this.lr * Math.sign(tdErr);
        for (let i = 0; i < this.inputDim * this.embeddingDim; i++) {
            const row = Math.floor(i / this.embeddingDim), col = i % this.embeddingDim;
            this._inputEmbedding[row][col] += alpha * this._eligibilityEmbedding[i];
            this._inputEmbedding[row][col] = Utils.clamp(this._inputEmbedding[row][col], -2, 2);
        }
        for (let i = 0; i < this._eligibilityW1.length; i++) {
            const row = Math.floor(i / this.hidden1), col = i % this.hidden1;
            this._W1[row][col] += alpha * this._eligibilityW1[i];
            this._W1[row][col] = Utils.clamp(this._W1[row][col], -2, 2);
        }
        for (let i = 0; i < this._eligibilityW2.length; i++) {
            const row = Math.floor(i / this.hidden2), col = i % this.hidden2;
            this._W2[row][col] += alpha * this._eligibilityW2[i];
            this._W2[row][col] = Utils.clamp(this._W2[row][col], -2, 2);
        }
        for (let i = 0; i < this._eligibilityW3.length; i++) {
            const row = Math.floor(i / this.outputDim), col = i % this.outputDim;
            this._W3[row][col] += alpha * this._eligibilityW3[i];
            this._W3[row][col] = Utils.clamp(this._W3[row][col], -2, 2);
        }
    }
    
    _consolidateMemories(reward) {
        if (!arenaConfig.enableConsolidation || reward < 2) return;
        for (let i = 0; i < this.memoryDim; i++) {
            if (this._predictionErrors[i] > 0.25) {
                this._consolidationBuffer.push({
                    index: i,
                    value: this._memoryPredictive[i],
                    error: this._predictionErrors[i],
                    reward: reward,
                    priority: this._predictionErrors[i] * reward
                });
            }
        }
        if (this._consolidationBuffer.length > 0 && this._rng.next() < 0.1) {
            const totalPriority = this._consolidationBuffer.reduce((s, item) => s + item.priority, 0);
            if (totalPriority <= 0) return;
            let rand = this._rng.next() * totalPriority;
            let selected = this._consolidationBuffer[0];
            for (const item of this._consolidationBuffer) {
                rand -= item.priority;
                if (rand <= 0) { selected = item; break; }
            }
            this._memoryPermanent[selected.index] = Utils.lerp(this._memoryPermanent[selected.index], selected.value, 0.3);
            if (this._rng.next() < 0.5) {
                const idx = this._consolidationBuffer.indexOf(selected);
                if (idx >= 0) this._consolidationBuffer.splice(idx, 1);
            }
        }
        if (this._consolidationBuffer.length > this._maxBuffer) {
            this._consolidationBuffer.sort((a, b) => b.priority - a.priority);
            this._consolidationBuffer.length = this._maxBuffer;
        }
    }
    
    updateDiagnostics(metrics = {}) {
        if (metrics.win !== undefined) this._trainingStats.winRate = Utils.lerp(this._trainingStats.winRate, metrics.win ? 1 : 0, 0.05);
        if (metrics.collected !== undefined) this._trainingStats.collectionRate = Utils.lerp(this._trainingStats.collectionRate, metrics.collected ? 1 : 0, 0.05);
        if (metrics.survival !== undefined) this._trainingStats.survivalTime = Utils.lerp(this._trainingStats.survivalTime, metrics.survival, 0.02);
        if (metrics.reward !== undefined) this._trainingStats.avgRewardPerStep = Utils.lerp(this._trainingStats.avgRewardPerStep, metrics.reward, 0.01);
        this._trainingStats.totalSteps++;
    }
    
    mutate(rate = 0.1, strength = 0.1) {
        if (!arenaConfig.enableEvolution) return 0;
        let mutations = 0;
        const mutateMat = (mat) => {
            if (!mat?.length) return;
            for (let i = 0; i < mat.length; i++) {
                if (!mat[i]?.length) continue;
                for (let j = 0; j < mat[i].length; j++) {
                    if (this._rng.next() < rate) {
                        mat[i][j] += (this._rng.next() * 2 - 1) * strength;
                        mat[i][j] = Utils.clamp(mat[i][j], -2, 2);
                        mutations++;
                    }
                }
            }
        };
        mutateMat(this._inputEmbedding);
        mutateMat(this._W1); mutateMat(this._W2); mutateMat(this._W3);
        if (this._Wq) mutateMat(this._Wq);
        if (this._Wk) mutateMat(this._Wk);
        if (this._Wv) mutateMat(this._Wv);
        if (this._Wo) mutateMat(this._Wo);
        if (this._Wg) mutateMat(this._Wg);
        for (const ew1 of this._expertW1) mutateMat(ew1);
        for (const ew2 of this._expertW2) mutateMat(ew2);
        return mutations;
    }
    
    clone() {
        const clone = new NeuralNetwork({
            inputDim: this.inputDim, embeddingDim: this.embeddingDim,
            hidden1: this.hidden1, hidden2: this.hidden2, outputDim: this.outputDim,
            memoryDim: this.memoryDim, seed: this.seed + '_clone_' + Date.now(),
            lr: this.lr, gamma: this.gamma, lambda: this.lambda,
            numHeads: this.numHeads, numExperts: this.numExperts
        });
        clone._inputEmbedding = this._inputEmbedding.map(r => r?.slice() || []);
        clone._embeddingBias = this._embeddingBias?.slice() || [];
        clone._W1 = this._W1.map(r => r?.slice() || []);
        clone._W2 = this._W2.map(r => r?.slice() || []);
        clone._W3 = this._W3.map(r => r?.slice() || []);
        if (this._Wq) clone._Wq = this._Wq.map(r => r?.slice() || []);
        if (this._Wk) clone._Wk = this._Wk.map(r => r?.slice() || []);
        if (this._Wv) clone._Wv = this._Wv.map(r => r?.slice() || []);
        if (this._Wo) clone._Wo = this._Wo.map(r => r?.slice() || []);
        if (this._Wg) clone._Wg = this._Wg.map(r => r?.slice() || []);
        clone._expertW1 = this._expertW1.map(m => m.map(r => r?.slice() || []));
        clone._expertW2 = this._expertW2.map(m => m.map(r => r?.slice() || []));
        clone._memoryPermanent = new Float32Array(this._memoryPermanent);
        clone._memoryPredictive = new Float32Array(this._memoryPredictive);
        clone._predictionErrors = new Float32Array(this._predictionErrors);
        clone._trainingStats = {
            ...this._trainingStats,
            tdErrorHistory: [...this._trainingStats.tdErrorHistory],
            predictionErrorHistory: [...this._trainingStats.predictionErrorHistory],
            policyEntropyHistory: [...this._trainingStats.policyEntropyHistory],
            loadBalanceHistory: [...this._trainingStats.loadBalanceHistory]
        };
        clone._eligibilityW1 = new Float32Array(this._eligibilityW1);
        clone._eligibilityW2 = new Float32Array(this._eligibilityW2);
        clone._eligibilityW3 = new Float32Array(this._eligibilityW3);
        clone._eligibilityEmbedding = new Float32Array(this._eligibilityEmbedding);
        return clone;
    }
    
    toJSON() {
        return {
            config: { inputDim: this.inputDim, embeddingDim: this.embeddingDim, hidden1: this.hidden1, hidden2: this.hidden2, outputDim: this.outputDim, memoryDim: this.memoryDim, seed: this.seed, lr: this.lr, gamma: this.gamma, lambda: this.lambda, numHeads: this.numHeads, numExperts: this.numExperts },
            inputEmbedding: this._inputEmbedding.map(r => r?.slice() || []),
            embeddingBias: this._embeddingBias?.slice() || [],
            W1: this._W1.map(r => r?.slice() || []), W2: this._W2.map(r => r?.slice() || []), W3: this._W3.map(r => r?.slice() || []),
            Wq: (this._Wq || []).map(r => r?.slice() || []), Wk: (this._Wk || []).map(r => r?.slice() || []),
            Wv: (this._Wv || []).map(r => r?.slice() || []), Wo: (this._Wo || []).map(r => r?.slice() || []),
            Wg: (this._Wg || []).map(r => r?.slice() || []),
            expertW1: this._expertW1.map(m => m.map(r => r?.slice() || [])),
            expertW2: this._expertW2.map(m => m.map(r => r?.slice() || [])),
            memoryPermanent: Array.from(this._memoryPermanent),
            memoryPredictive: Array.from(this._memoryPredictive),
            predictionErrors: Array.from(this._predictionErrors),
            trainingStats: this._trainingStats
        };
    }
    
    static fromJSON(data) {
        if (!data?.config) return new NeuralNetwork({});
        const nn = new NeuralNetwork(data.config);
        try {
            nn._inputEmbedding = (data.inputEmbedding || []).map(r => (r || []).slice());
            nn._embeddingBias = (data.embeddingBias || new Array(nn.embeddingDim).fill(0)).slice();
            nn._W1 = (data.W1 || []).map(r => (r || []).slice());
            nn._W2 = (data.W2 || []).map(r => (r || []).slice());
            nn._W3 = (data.W3 || []).map(r => (r || []).slice());
            if (data.Wq) nn._Wq = (data.Wq || []).map(r => (r || []).slice());
            if (data.Wk) nn._Wk = (data.Wk || []).map(r => (r || []).slice());
            if (data.Wv) nn._Wv = (data.Wv || []).map(r => (r || []).slice());
            if (data.Wo) nn._Wo = (data.Wo || []).map(r => (r || []).slice());
            if (data.Wg) nn._Wg = (data.Wg || []).map(r => (r || []).slice());
            if (data.expertW1) nn._expertW1 = data.expertW1.map(m => (m || []).map(r => (r || []).slice()));
            if (data.expertW2) nn._expertW2 = data.expertW2.map(m => (m || []).map(r => (r || []).slice()));
            nn._memoryPermanent = new Float32Array(data.memoryPermanent || new Array(nn.memoryDim).fill(0));
            nn._memoryPredictive = new Float32Array(data.memoryPredictive || new Array(nn.memoryDim).fill(0));
            nn._predictionErrors = new Float32Array(data.predictionErrors || new Array(nn.memoryDim).fill(0));
            if (data.trainingStats) nn._trainingStats = { ...data.trainingStats };
        } catch(e) { console.warn('NeuralNetwork.fromJSON: error', e); }
        return nn;
    }
    
    getActiveNeurons() { return [...this._activeNeurons]; }
    getGateProbs() { return this._lastGateProbs ? [...this._lastGateProbs] : null; }
}

// ============================================================================
// CRITIC NETWORK ‚Äî VALUE ESTIMATION FOR ACTOR-CRITIC
// ============================================================================
class CriticNetwork {
    constructor(config = {}) {
        this.inputDim = config.inputDim ?? arenaConfig.ARCH.INPUT_DIM;
        this.hidden = config.hidden ?? arenaConfig.ARCH.CRITIC_HIDDEN;
        this.seed = config.seed ?? (arenaConfig.seed + '_CRITIC');
        this._rng = new SeededRNG(this.seed);
        this._W1 = this._rng.deriveWeights(this.inputDim, this.hidden, 0.3);
        this._W2 = this._rng.deriveWeights(this.hidden, 1, 0.1);
        this._b1 = this._rng.deriveVector(this.hidden, 0.1);
        this._b2 = 0;
        this.lr = config.lr ?? arenaConfig.learningRate;
        this.gamma = config.gamma ?? arenaConfig.gamma;
    }
    
    forward(inputs) {
        if (!Array.isArray(inputs) || inputs.length !== this.inputDim) inputs = new Array(this.inputDim).fill(0);
        const hidden = [];
        for (let o = 0; o < this.hidden; o++) {
            let sum = Utils.safeNumber(this._b1[o], 0);
            for (let i = 0; i < inputs.length; i++) sum += Utils.safeNumber(inputs[i], 0) * Utils.safeNumber(this._W1[i]?.[o], 0);
            hidden.push(Utils.leakyRelu(sum));
        }
        let value = this._b2;
        for (let i = 0; i < this.hidden; i++) value += Utils.safeNumber(hidden[i], 0) * Utils.safeNumber(this._W2[i]?.[0], 0);
        return Utils.clamp(value, -10, 10);
    }
    
    update(inputs, reward, nextValue, alpha = null) {
        const currentValue = this.forward(inputs);
        const tdErr = Utils.tdError(reward, currentValue, nextValue, this.gamma);
        const lr = alpha ?? this.lr;
        const hidden = [];
        for (let o = 0; o < this.hidden; o++) {
            let sum = Utils.safeNumber(this._b1[o], 0);
            for (let i = 0; i < inputs.length; i++) sum += Utils.safeNumber(inputs[i], 0) * Utils.safeNumber(this._W1[i]?.[o], 0);
            hidden.push(Utils.leakyRelu(sum));
        }
        for (let i = 0; i < this.hidden; i++) {
            this._W2[i][0] += lr * tdErr * Utils.safeNumber(hidden[i], 0);
            this._W2[i][0] = Utils.clamp(this._W2[i][0], -2, 2);
        }
        this._b2 += lr * tdErr;
        for (let i = 0; i < this.inputDim; i++) {
            for (let o = 0; o < this.hidden; o++) {
                const grad = tdErr * Utils.safeNumber(this._W2[o]?.[0], 0) * (hidden[o] > 0 ? 1 : 0.01);
                this._W1[i][o] += lr * grad * Utils.safeNumber(inputs[i], 0);
                this._W1[i][o] = Utils.clamp(this._W1[i][o], -2, 2);
            }
        }
        return { tdError: tdErr, value: currentValue };
    }
    
    clone() {
        const clone = new CriticNetwork({ inputDim: this.inputDim, hidden: this.hidden, seed: this.seed + '_clone', lr: this.lr, gamma: this.gamma });
        clone._W1 = this._W1.map(r => r.slice());
        clone._W2 = this._W2.map(r => r.slice());
        clone._b1 = this._b1.slice();
        clone._b2 = this._b2;
        return clone;
    }
    
    toJSON() {
        return { config: { inputDim: this.inputDim, hidden: this.hidden, seed: this.seed, lr: this.lr, gamma: this.gamma }, W1: this._W1.map(r => r.slice()), W2: this._W2.map(r => r.slice()), b1: this._b1.slice(), b2: this._b2 };
    }
    
    static fromJSON(data) {
        if (!data?.config) return new CriticNetwork({});
        const critic = new CriticNetwork(data.config);
        critic._W1 = (data.W1 || []).map(r => (r || []).slice());
        critic._W2 = (data.W2 || []).map(r => (r || []).slice());
        critic._b1 = (data.b1 || []).slice();
        critic._b2 = data.b2 ?? 0;
        return critic;
    }
}

// ============================================================================
// POLICY SELECTOR ‚Äî LEARNABLE BEHAVIOR MODE SELECTION
// ============================================================================
class PolicySelector {
    constructor(config = {}) {
        this.contextDim = config.contextDim ?? arenaConfig.ARCH.POLICY_CONTEXT_DIM;
        this.skillEmbeddingDim = config.skillEmbeddingDim ?? arenaConfig.ARCH.POLICY_SKILL_DIM;
        this.hidden = config.hidden ?? arenaConfig.ARCH.POLICY_HIDDEN;
        this.numModes = config.numModes ?? arenaConfig.ARCH.POLICY_MODES;
        this.seed = config.seed ?? (arenaConfig.seed + '_POLICY');
        this._rng = new SeededRNG(this.seed);
        this._W1 = this._rng.deriveWeights(this.contextDim + this.skillEmbeddingDim, this.hidden, 0.2);
        this._W2 = this._rng.deriveWeights(this.hidden, this.numModes, 0.15);
        this._b1 = this._rng.deriveVector(this.hidden, 0.1);
        this.lr = config.lr ?? arenaConfig.learningRate * 0.6;
        this.entropyCoeff = config.entropyCoeff ?? arenaConfig.entropyCoeff;
    }
    
    forward(context, skillEmbedding) {
        const combined = [...(context || []), ...(skillEmbedding || [])];
        const hidden = [];
        for (let o = 0; o < this.hidden; o++) {
            let sum = Utils.safeNumber(this._b1[o], 0);
            for (let i = 0; i < combined.length; i++) sum += Utils.safeNumber(combined[i], 0) * Utils.safeNumber(this._W1[i]?.[o], 0);
            hidden.push(Utils.leakyRelu(sum));
        }
        const logits = [];
        for (let m = 0; m < this.numModes; m++) {
            let sum = 0;
            for (let i = 0; i < this.hidden; i++) sum += Utils.safeNumber(hidden[i], 0) * Utils.safeNumber(this._W2[i]?.[m], 0);
            logits.push(sum);
        }
        const probs = Utils.softmax(logits, 0.8);
        return { logits, probs, hidden };
    }
    
    update(context, skillEmbedding, selectedMode, advantage, applyEntropy = true) {
        const { probs, hidden } = this.forward(context, skillEmbedding);
        const safeProb = Math.max(Utils.safeNumber(probs[selectedMode], 0), 1e-10);
        const logProb = Math.log(safeProb);
        const policyLoss = -logProb * advantage;
        
        let entropy = 0, entropyGrad = 0;
        if (applyEntropy && arenaConfig.entropyCoeff > 0) {
            entropy = Utils.entropyBonus(probs);
            entropyGrad = -probs.reduce((sum, p, i) => {
                const safeP = Math.max(p, 1e-10);
                return sum + (i === selectedMode ? 1 : 0) * (1 + Math.log(safeP));
            }, 0);
        }
        
        const totalGrad = advantage - (applyEntropy ? arenaConfig.entropyCoeff * entropyGrad : 0);
        const lr = this.lr * Math.sign(totalGrad);
        
        for (let i = 0; i < this.hidden; i++) {
            for (let m = 0; m < this.numModes; m++) {
                const targetGrad = (m === selectedMode ? 1 : 0) - Utils.safeNumber(probs[m], 0);
                this._W2[i][m] += lr * totalGrad * targetGrad * Utils.safeNumber(hidden[i], 0);
                this._W2[i][m] = Utils.clamp(this._W2[i][m], -2, 2);
            }
        }
        return { loss: policyLoss - (applyEntropy ? arenaConfig.entropyCoeff * entropy : 0), entropy, selectedProb: Utils.safeNumber(probs[selectedMode], 0) };
    }
    
    clone() {
        const clone = new PolicySelector({ contextDim: this.contextDim, skillEmbeddingDim: this.skillEmbeddingDim, hidden: this.hidden, numModes: this.numModes, seed: this.seed + '_clone', lr: this.lr });
        clone._W1 = this._W1.map(r => r.slice());
        clone._W2 = this._W2.map(r => r.slice());
        clone._b1 = this._b1.slice();
        return clone;
    }
    
    toJSON() {
        return { config: { contextDim: this.contextDim, skillEmbeddingDim: this.skillEmbeddingDim, hidden: this.hidden, numModes: this.numModes, seed: this.seed, lr: this.lr }, W1: this._W1.map(r => r.slice()), W2: this._W2.map(r => r.slice()), b1: this._b1.slice() };
    }
    
    static fromJSON(data) {
        if (!data?.config) return new PolicySelector({});
        const ps = new PolicySelector(data.config);
        ps._W1 = (data.W1 || []).map(r => (r || []).slice());
        ps._W2 = (data.W2 || []).map(r => (r || []).slice());
        ps._b1 = (data.b1 || []).slice();
        return ps;
    }
}

// ============================================================================
// BEHAVIOR ARBITER ‚Äî MODE SELECTION & TARGET CALCULATION
// ============================================================================
class BehaviorArbiter {
    constructor() { this.modes = ['hunt', 'flee', 'explore', 'combat', 'avoid']; }
    
    decode(outputs) {
        return {
            hunt: Utils.clamp(Utils.safeNumber(outputs?.[0], 0), 0, 1),
            flee: Utils.clamp(Utils.safeNumber(outputs?.[1], 0), 0, 1),
            explore: Utils.clamp(Utils.safeNumber(outputs?.[2], 0), 0, 1),
            combat: Utils.clamp(Utils.safeNumber(outputs?.[3], 0), 0, 1),
            avoid: Utils.clamp(Utils.safeNumber(outputs?.[4], 0), 0, 1),
            speed: Utils.clamp(Utils.safeNumber(outputs?.[5], 0), 0, 1),
            curiosity: Utils.clamp(Utils.safeNumber(outputs?.[6], 0), 0, 1),
            aggression: Utils.clamp(Utils.safeNumber(outputs?.[7], 0), 0, 1),
            memoryWeight: Utils.clamp(Utils.safeNumber(outputs?.[8], 0), 0, 1)
        };
    }
    
    select(behaviors, context, skills = null, myStats = null, enemyStats = null) {
        const myPower = Utils.safeNumber(myStats?.damage, 3) * Utils.safeNumber(myStats?.maxHealth, 100);
        const enemyPower = Utils.safeNumber(enemyStats?.damage, 3) * Utils.safeNumber(enemyStats?.maxHealth, 100);
        
        if (enemyPower > myPower * 1.5 && Utils.safeNumber(context?.enemyDistance, 999) < 150) { behaviors.flee *= 3.0; behaviors.combat *= 0.1; }
        else if (myPower > enemyPower * 1.2 && Utils.safeNumber(context?.enemyDistance, 999) < 150) { behaviors.combat *= 2.5; behaviors.hunt *= 0.5; }
        else if (Utils.safeNumber(context?.health, 1) < 0.3) { behaviors.flee *= 3.0; behaviors.combat *= 0.1; }
        else if (Utils.safeNumber(context?.enemyDistance, 999) < 100 && Utils.safeNumber(context?.health, 1) > 0.3) { behaviors.combat *= 2.0; }
        else { behaviors.combat *= 0.1; }
        
        if (Utils.safeNumber(context?.wallDistance, 999) < 2.5) { behaviors.avoid *= 2.0; } else { behaviors.avoid *= 0.3; }
        
        if (skills) {
            const skillMap = { 'hunt': Utils.safeNumber(skills.hunting, 0.5), 'flee': Utils.safeNumber(skills.fleeing, 0.5), 'explore': Utils.safeNumber(skills.exploring, 0.5), 'combat': Utils.safeNumber(skills.combat, 0.5), 'avoid': Utils.safeNumber(skills.avoiding, 0.5) };
            for (const mode of this.modes) { const skill = skillMap[mode]; behaviors[mode] *= (0.6 + skill * 0.8); }
        }
        
        const scores = this.modes.map(m => Utils.safeNumber(behaviors[m], 0));
        const mode = this.modes[Utils.argmax(scores)];
        return { mode, behaviors };
    }
    
    calculateTarget(mode, behaviors, agent, world, networkOutputs = null) {
        const { points, enemies, walls } = world || {};
        switch (mode) {
            case 'hunt': {
                let targets = (points || []).filter(p => p && !p.collected);
                if (agent?.permanent?.memory?.lastFoodPos && Utils.safeNumber(behaviors?.memoryWeight, 0) > 0.5) {
                    const memAge = (world?.step || 0) - (agent.permanent.memory.lastFoodStep || 0);
                    if (memAge < 100) targets = [...targets, { x: agent.permanent.memory.lastFoodPos.x, y: agent.permanent.memory.lastFoodPos.y, value: 1, type: 'remembered' }];
                }
                if (networkOutputs?.length >= 12) {
                    const dirBiasX = Utils.tanh(networkOutputs[9] || 0) * 30, dirBiasY = Utils.tanh(networkOutputs[10] || 0) * 30, priorityMod = Utils.safeNumber(networkOutputs[11] || 0.5, 0.5) * 2;
                    targets.forEach(t => { t.x += dirBiasX * priorityMod * 0.15; t.y += dirBiasY * priorityMod * 0.15; });
                    targets.sort((a, b) => { const distA = Math.max(0, Utils.dist(agent, a) - priorityMod * 10), distB = Math.max(0, Utils.dist(agent, b) - priorityMod * 10); return distA - distB; });
                } else { targets.sort((a, b) => Utils.dist(agent, a) - Utils.dist(agent, b)); }
                return targets[0] || { x: Utils.clamp((agent?.x || 400) + Utils.rand(-100, 100), 25, 795), y: Utils.clamp((agent?.y || 300) + Utils.rand(-75, 75), 25, 575) };
            }
            case 'flee': {
                const threats = (enemies || []).filter(e => e && e.id !== agent?.id && e.alive);
                if (!threats.length) return { x: Utils.clamp((agent?.x || 400) + Utils.rand(-80, 80), 25, 795), y: Utils.clamp((agent?.y || 300) + Utils.rand(-60, 60), 25, 575) };
                let threat = threats.reduce((n, e) => Utils.dist(agent, e) < Utils.dist(agent, n) ? e : n);
                if (agent?.predictive?.predictedEnemy && Utils.safeNumber(agent.predictive?.confidence, 0) > 0.7) threat = { ...threat, ...agent.predictive.predictedEnemy };
                const away = Utils.normalize((agent?.x || 0) - threat.x, (agent?.y || 0) - threat.y);
                if (networkOutputs?.length >= 12) return { x: (agent?.x || 0) + (away.x + Utils.tanh(networkOutputs[9] || 0) * 0.3) * 40, y: (agent?.y || 0) + (away.y + Utils.safeNumber(networkOutputs[10] || 0, 0) * 0.3) * 40 };
                return { x: (agent?.x || 0) + away.x * 40, y: (agent?.y || 0) + away.y * 40 };
            }
            case 'explore': {
                if (Utils.safeNumber(behaviors?.curiosity, 0) > 0.7 && agent?.permanent?.memory?.unvisited?.length) return agent.permanent.memory.unvisited[Utils.randInt(0, agent.permanent.memory.unvisited.length - 1)];
                if (networkOutputs?.length >= 12) return { x: Utils.clamp((agent?.x || 0) + Utils.tanh(networkOutputs[9] || 0) * 120, 25, 795), y: Utils.clamp((agent?.y || 0) + Utils.tanh(networkOutputs[10] || 0) * 90, 25, 575) };
                return { x: Utils.clamp((agent?.x || 0) + Utils.rand(-120, 120), 25, 795), y: Utils.clamp((agent?.y || 0) + Utils.rand(-90, 90), 25, 575) };
            }
            case 'combat': {
                const targets = (enemies || []).filter(e => e && e.id !== agent?.id && e.alive);
                if (!targets.length) return { x: agent?.x || 0, y: agent?.y || 0 };
                let target = targets.reduce((n, e) => Utils.dist(agent, e) < Utils.dist(agent, n) ? e : n);
                if (agent?.predictive?.predictedEnemy && Utils.safeNumber(agent.predictive?.confidence, 0) > 0.65) target = { ...target, ...agent.predictive.predictedEnemy };
                return target;
            }
            case 'avoid': {
                const nearWalls = (walls || []).filter(w => w && Utils.dist(agent, w) < 30);
                if (!nearWalls.length) return { x: agent?.x || 0, y: agent?.y || 0 };
                const wall = nearWalls.reduce((n, w) => Utils.dist(agent, w) < Utils.dist(agent, n) ? w : n);
                const toWall = Utils.normalize(wall.x - (agent?.x || 0), wall.y - (agent?.y || 0));
                const tangent = { x: -toWall.y, y: toWall.x };
                if (networkOutputs?.length >= 12 && Utils.safeNumber(networkOutputs[9], 0) < 0) return { x: (agent?.x || 0) - tangent.x * 25, y: (agent?.y || 0) - tangent.y * 25 };
                return { x: (agent?.x || 0) + tangent.x * 25, y: (agent?.y || 0) + tangent.y * 25 };
            }
            default: return { x: agent?.x || 0, y: agent?.y || 0 };
        }
    }
}

// ============================================================================
// SMART POINT ‚Äî DYNAMIC COLLECTIBLES
// ============================================================================
class SmartPoint {
    constructor(x, y, type = 'normal') {
        this.x = x; this.y = y; this.type = type; this.collected = false;
        this.value = type === 'rare' ? 20 : (type === 'scared' ? 8 : 5);
        this.fleeRadius = type === 'scared' ? 7 : 0;
        this.color = type === 'rare' ? '#ffaa00' : (type === 'scared' ? '#ff66cc' : '#00ff9d');
        this.radius = type === 'rare' ? 6 : 4; this.vx = 0; this.vy = 0;
    }
    update(nearestAgent, dt) {
        if (this.collected) return;
        if (this.type === 'scared' && nearestAgent && Utils.dist(this, nearestAgent) < this.fleeRadius) {
            const away = Utils.normalize(this.x - nearestAgent.x, this.y - nearestAgent.y);
            this.vx = Utils.lerp(this.vx, away.x * 1.5, 0.1); this.vy = Utils.lerp(this.vy, away.y * 1.5, 0.1);
        } else { this.vx = Utils.lerp(this.vx, Utils.rand(-0.3, 0.3), 0.02); this.vy = Utils.lerp(this.vy, Utils.rand(-0.3, 0.3), 0.02); }
        this.x += this.vx * dt; this.y += this.vy * dt;
        this.x = Utils.clamp(this.x, 20, 800); this.y = Utils.clamp(this.y, 20, 580);
    }
    draw(ctx) {
        if (this.collected) return;
        ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
        if (this.type === 'rare') { ctx.strokeStyle = '#ffdd44'; ctx.lineWidth = 2; ctx.stroke(); }
    }
}

// ============================================================================
// PROJECTILE ‚Äî RANGED COMBAT
// ============================================================================
class Projectile {
    constructor(x, y, vx, vy, owner, damage = 3, life = 80) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.owner = owner;
        this.damage = damage; this.life = life; this.alive = true; this.radius = 3;
    }
    update(dt) { this.x += this.vx * dt * 8; this.y += this.vy * dt * 8; this.life -= dt; if (this.life <= 0) this.alive = false; }
    draw(ctx) { if (!this.alive) return; ctx.fillStyle = '#ffdd44'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); }
}

// ============================================================================
// ENEMY PREDICTOR ‚Äî ADVERSARY BEHAVIOR MODELING
// ============================================================================
class EnemyPredictor {
    constructor() { this.history = []; this.maxHistory = 50; this.patterns = { movingRight: 0, movingLeft: 0, movingDown: 0, movingUp: 0, fleeing: 0, aggressive: 0, unpredictable: 0 }; }
    recordMove(action, distance, health, aggression) {
        this.history.push({ action: { ...action }, distance, health, aggression, time: Date.now() });
        if (this.history.length > this.maxHistory) this.history.shift();
    }
    predictNextAction() {
        if (this.history.length < 5) return 'unpredictable';
        const recent = this.history.slice(-5);
        const avgX = recent.reduce((s, m) => s + Utils.safeNumber(m.action?.fx, 0), 0) / recent.length;
        const avgY = recent.reduce((s, m) => s + Utils.safeNumber(m.action?.fy, 0), 0) / recent.length;
        const avgAgg = recent.reduce((s, m) => s + Utils.safeNumber(m.action?.aggression, 0.5), 0) / recent.length;
        if (Math.abs(avgAgg) > 0.7) return avgAgg > 0 ? 'aggressive' : 'fleeing';
        if (Math.abs(avgX) > 0.6) return avgX > 0 ? 'movingRight' : 'movingLeft';
        if (Math.abs(avgY) > 0.6) return avgY > 0 ? 'movingDown' : 'movingUp';
        return 'unpredictable';
    }
    getWeakpoints() { if (this.history.length < 5) return []; return this.history.slice(-10).filter(m => Utils.safeNumber(m.health, 1) < 0.5).map(m => ({ direction: m.action, health: m.health })); }
}

// ============================================================================
// STRATEGY MEMORY ‚Äî WINNING TACTICS STORAGE
// ============================================================================
class StrategyMemory {
    constructor() { this.winningStrategies = []; this.fightHistory = {}; this.maxStrategies = 20; }
    recordFight(opponentId, won, weights, tactics, accuracy) {
        if (!this.fightHistory[opponentId]) this.fightHistory[opponentId] = { wins: 0, losses: 0, lastTactics: null, bestAccuracy: 0 };
        const hist = this.fightHistory[opponentId];
        if (won) { hist.wins++; hist.lastTactics = tactics; hist.bestAccuracy = Math.max(hist.bestAccuracy, accuracy || 0); } else { hist.losses++; }
    }
    saveWinningStrategy(weights, opponentId, tactics, accuracy) {
        if (accuracy <= 0.65) return;
        this.winningStrategies.push({ weights: Utils.deepClone(weights), against: opponentId, tactics, winRate: accuracy, timestamp: Date.now() });
        if (this.winningStrategies.length > this.maxStrategies) { this.winningStrategies.sort((a, b) => a.winRate - b.winRate); this.winningStrategies.shift(); }
    }
    loadSimilarStrategy(opponentId) { const strategies = this.winningStrategies.filter(s => s.against === opponentId); return strategies.length > 0 ? strategies[strategies.length - 1] : null; }
}

// ============================================================================
// AGENT ‚Äî COMPLETE NEURAL ENTITY
// ============================================================================
class Agent {
    constructor(id, x, y, color, seed) {
        this.id = id; this.x = x; this.y = y; this.color = color; this.vx = 0; this.vy = 0;
        this.stats = { maxHealth: 100, damage: 3, fireRate: 15, dodgeChance: 0.0 };
        this.health = this.stats.maxHealth; this.lastMutationType = null; this.seed = seed;
        this.numExperts = arenaConfig.ARCH.NUM_EXPERTS;
        
        this.net = new NeuralNetwork({ inputDim: arenaConfig.ARCH.INPUT_DIM, embeddingDim: arenaConfig.ARCH.EMBEDDING_DIM, hidden1: arenaConfig.ARCH.HIDDEN1, hidden2: arenaConfig.ARCH.HIDDEN2, outputDim: arenaConfig.ARCH.OUTPUT_DIM, memoryDim: arenaConfig.ARCH.MEMORY_DIM, seed: seed + '_NET', lr: arenaConfig.learningRate, gamma: arenaConfig.gamma, lambda: arenaConfig.lambda, numHeads: arenaConfig.ARCH.NUM_HEADS, numExperts: this.numExperts });
        this.critic = new CriticNetwork({ inputDim: arenaConfig.ARCH.INPUT_DIM, embeddingDim: arenaConfig.ARCH.EMBEDDING_DIM, hidden: arenaConfig.ARCH.CRITIC_HIDDEN, seed: seed + '_CRITIC', lr: arenaConfig.learningRate, gamma: arenaConfig.gamma });
        this.policySelector = new PolicySelector({ contextDim: arenaConfig.ARCH.POLICY_CONTEXT_DIM, skillEmbeddingDim: arenaConfig.ARCH.POLICY_SKILL_DIM, hidden: arenaConfig.ARCH.POLICY_HIDDEN, numModes: arenaConfig.ARCH.POLICY_MODES, seed: seed + '_POLICY', lr: arenaConfig.learningRate * 0.6 });
        
        this.experts = [];
        for (let i = 0; i < this.numExperts; i++) {
            this.experts.push(new NeuralNetwork({ inputDim: arenaConfig.ARCH.INPUT_DIM, embeddingDim: arenaConfig.ARCH.EMBEDDING_DIM, hidden1: arenaConfig.ARCH.HIDDEN1, hidden2: arenaConfig.ARCH.HIDDEN2, outputDim: arenaConfig.ARCH.OUTPUT_DIM, memoryDim: arenaConfig.ARCH.MEMORY_DIM, seed: seed + '_EXP_' + i, lr: arenaConfig.learningRate, gamma: arenaConfig.gamma, lambda: arenaConfig.lambda, numHeads: arenaConfig.ARCH.NUM_HEADS }));
        }
        
        this.arbiter = new BehaviorArbiter(); this.mode = 'explore'; this.target = { x, y }; this.speed = 1;
        this.stuckCounter = 0; this.lastPos = { x, y }; this.cumulativeReward = 0; this.alive = true;
        this.skillEmbedding = [0.3, 0.4, 0.2, 0.5, 0.6];
        
        this.permanent = {
            skills: { hunting: 0.3 + Math.random() * 0.2, fleeing: 0.4 + Math.random() * 0.2, combat: 0.2 + Math.random() * 0.2, exploring: 0.5, avoiding: 0.6 },
            strategies: { huntPattern: 'direct', fleeDirection: 'away', combatStyle: 'direct' },
            preferences: { foodType: 'any', enemyType: 'any', territory: 'any' },
            muscleMemory: new Float32Array(16).fill(0),
            memory: { lastFoodPos: null, lastFoodStep: 0, visited: new Set(), unvisited: [] }
        };
        
        this.predictive = {
            shortTerm: { positions: [], actions: [], results: [], enemyHistory: [], foodHistory: [] },
            patterns: { enemyMovement: null, foodSpawn: null, dangerZones: new Map() },
            predictions: { enemyPos: { x: 0, y: 0 }, foodPos: { x: 0, y: 0 }, collision: false, success: 0.5 },
            confidence: 0.5, predictionError: 0
        };
        
        this.enemyPredictor = new EnemyPredictor(); this.strategyMemory = new StrategyMemory();
        this.currentTactic = 'aggressive'; this.fightStartTime = 0; this.fightOpponent = null;
        this.attackCooldown = 0; this.attackRange = 35; this.wins = 0; this.mutations = 0; this.generation = 1;
        this.trail = []; this.lastDecision = null; this._lastWorld = null;
        
        this.learningBuffer = { states: [], actions: [], rewards: [], nextStates: [], dones: [], values: [], maxBuffer: 32 };
    }
    
    getInputs(world) {
        const inputs = [], maxDist = Math.sqrt(820 ** 2 + 600 ** 2);
        const points = (world?.points || []).filter(p => p && !p.collected).map(p => ({ ...p, d: Utils.dist(this, p) })).sort((a, b) => a.d - b.d).slice(0, 5);
        for (let i = 0; i < 5; i++) {
            const p = points[i];
            if (p) { const los = Utils.hasLineOfSight(this, p, world?.walls || []) ? 1 : 0; inputs.push(Utils.clamp((p.x - this.x) / maxDist, -1, 1), Utils.clamp((p.y - this.y) / maxDist, -1, 1), Utils.clamp((100 - p.d) / 100, 0, 1), los); }
            else { inputs.push(0, 0, 0, 0); }
        }
        const enemies = (world?.enemies || []).filter(e => e && e.id !== this.id && e.alive).map(e => ({ ...e, d: Utils.dist(this, e) })).sort((a, b) => a.d - b.d).slice(0, 5);
        for (let i = 0; i < 5; i++) {
            const e = enemies[i];
            if (e) { const los = Utils.hasLineOfSight(this, e, world?.walls || []) ? 1 : 0; inputs.push(Utils.clamp((e.x - this.x) / maxDist, -1, 1), Utils.clamp((e.y - this.y) / maxDist, -1, 1), Utils.clamp((120 - e.d) / 120, 0, 1), los); }
            else { inputs.push(0, 0, 0, 0); }
        }
        const walls = (world?.walls || []).map(w => ({ ...w, d: Utils.dist(this, w) })).sort((a, b) => a.d - b.d).slice(0, 3);
        for (let i = 0; i < 3; i++) {
            const w = walls[i];
            if (w) { inputs.push(Utils.clamp((w.x - this.x) / maxDist, -1, 1), Utils.clamp((w.y - this.y) / maxDist, -1, 1), Utils.clamp((60 - w.d) / 60, 0, 1)); }
            else { inputs.push(0, 0, 0); }
        }
        inputs.push(Utils.clamp((400 - this.x) / 400, -1, 1), Utils.clamp((300 - this.y) / 300, -1, 1), this.health / this.stats.maxHealth, Utils.clamp((world?.step || 0) / 2000, 0, 1));
        inputs.push(Utils.clamp((world?.points || []).filter(p => p && !p.collected && Utils.dist(this, p) < 120).length / 15, 0, 1));
        inputs.push(Utils.clamp((world?.enemies || []).filter(e => e && e.id !== this.id && e.alive && Utils.dist(this, e) < 160).length / 10, 0, 1));
        inputs.push(Utils.clamp(Math.min(this.x, 820 - this.x, this.y, 600 - this.y) / 100, 0, 1), Utils.clamp(this.cumulativeReward / 20, -1, 1));
        while (inputs.length < arenaConfig.ARCH.INPUT_DIM) inputs.push(0);
        if (inputs.length > arenaConfig.ARCH.INPUT_DIM) inputs.length = arenaConfig.ARCH.INPUT_DIM;
        return inputs.map(v => Utils.safeNumber(v, 0));
    }
    
    selectBehavior(world, networkOutput) {
        const enemies = (world?.enemies || []).filter(e => e && e.id !== this.id && e.alive);
        const context = [
            enemies.length > 0 ? Utils.clamp(Utils.dist(this, enemies[0]) / 200, 0, 1) : 1,
            (world?.walls || []).length ? Utils.clamp(Math.min(...(world.walls.map(w => Utils.dist(this, w)))) / 60, 0, 1) : 0,
            this.health / this.stats.maxHealth,
            Utils.clamp(Utils.safeNumber(networkOutput?.[5], 0.5), 0, 1),
            Utils.clamp(Utils.safeNumber(networkOutput?.[6], 0.5), 0, 1),
            Utils.clamp(Utils.safeNumber(networkOutput?.[7], 0.5), 0, 1),
            this.permanent.skills.hunting, this.permanent.skills.fleeing
        ];
        const skillEmbedding = [this.permanent.skills.hunting, this.permanent.skills.fleeing, this.permanent.skills.combat, this.permanent.skills.exploring, this.permanent.skills.avoiding];
        const { probs } = this.policySelector.forward(context, skillEmbedding);
        const modeIdx = Utils.argmax(probs);
        const modes = ['hunt', 'flee', 'explore', 'combat', 'avoid'];
        const selectedMode = modes[modeIdx];
        if (this.lastDecision?.advantage !== undefined && arenaConfig.enablePolicySelector) {
            this.policySelector.update(context, skillEmbedding, modeIdx, this.lastDecision.advantage);
        }
        return { mode: selectedMode, modeProbs: probs };
    }
    
    decide(world) {
        this._lastWorld = { enemies: (world?.enemies || []).map(e => e ? { id: e.id, x: e.x, y: e.y, alive: e.alive, health: e.health, stats: { ...e.stats } } : null).filter(e => e), walls: (world?.walls || []).map(w => w ? { x: w.x, y: w.y } : null).filter(w => w), step: world?.step || 0 };
        this.updatePredictiveMemory(world);
        const inputs = this.getInputs(world);
        const gateRes = this.net.forward(inputs);
        const output = gateRes.output;
        const { mode, modeProbs } = this.selectBehavior(world, output);
        this.mode = mode;
        const behaviors = { speed: Utils.clamp(Utils.safeNumber(output?.[5], 0), 0, 1), curiosity: Utils.clamp(Utils.safeNumber(output?.[6], 0), 0, 1), aggression: Utils.clamp(Utils.safeNumber(output?.[7], 0), 0, 1), memoryWeight: Utils.clamp(Utils.safeNumber(output?.[8], 0), 0, 1) };
        const enemies = (world?.enemies || []).filter(e => e && e.id !== this.id && e.alive);
        const enemy = enemies.length > 0 ? enemies[0] : null;
        const context = { enemyDistance: enemy ? Utils.dist(this, enemy) : 999, wallDistance: (world?.walls || []).length ? Math.min(...world.walls.map(w => Utils.dist(this, w))) : 999, health: this.health / this.stats.maxHealth };
        let target = this.arbiter.calculateTarget(mode, behaviors, this, { points: world?.points || [], enemies: world?.enemies || [], walls: world?.walls || [] }, output);
        if (!target || typeof target.x !== 'number' || !isFinite(target.x) || typeof target.y !== 'number' || !isFinite(target.y)) { target = { x: Utils.clamp(this.x + Utils.rand(-50, 50), 30, 790), y: Utils.clamp(this.y + Utils.rand(-50, 50), 30, 570) }; }
        this.target = target;
        const confidenceMod = this.predictive.confidence > 0.7 ? 1.1 : (this.predictive.confidence < 0.4 ? 0.9 : 1);
        this.speed = Utils.lerp(this.speed, behaviors.speed * 2.5 * confidenceMod + 0.5, 0.08);
        if (mode === 'hunt' && behaviors.memoryWeight > 0.5) {
            const nearby = (world?.points || []).filter(p => p && !p.collected && Utils.dist(this, p) < 20);
            if (nearby.length && !this.permanent.memory.lastFoodPos) { this.permanent.memory.lastFoodPos = { ...nearby[0] }; this.permanent.memory.lastFoodStep = world?.step || 0; }
        }
        const cell = `${Math.floor(this.x / 25)},${Math.floor(this.y / 25)}`;
        if (!this.permanent.memory.visited.has(cell)) {
            this.permanent.memory.visited.add(cell);
            if (this.permanent.memory.unvisited.length > 60) this.permanent.memory.unvisited.shift();
            this.permanent.memory.unvisited.push({ x: this.x + Utils.rand(-40, 40), y: this.y + Utils.rand(-30, 30) });
        }
        this.lastDecision = { mode, behaviors, inputs, output, modeProbs, value: this.critic.forward(inputs), nextValue: null };
        return { target: this.target, speed: this.speed, mode, behaviors, inputs, output };
    }
    
    move(target, speed, walls, dt, networkOutputs = null) {
        const desired = Utils.normalize(target.x - this.x, target.y - this.y);
        const wallRep = this.getWallRepulsion(walls);
        let finalDir;
        if (wallRep.strength > 0.8) { const tangent = { x: -wallRep.y, y: wallRep.x }; const noise = Utils.rand(-0.3, 0.3); finalDir = { x: tangent.x + noise, y: tangent.y + noise }; const mag = Math.hypot(finalDir.x, finalDir.y) || 1; finalDir.x /= mag; finalDir.y /= mag; }
        else { finalDir = { x: Utils.lerp(desired.x, wallRep.x, wallRep.strength * 0.6), y: Utils.lerp(desired.y, wallRep.y, wallRep.strength * 0.6) }; const mag = Math.hypot(finalDir.x, finalDir.y); if (mag < 0.1) finalDir = desired; else { finalDir.x /= mag; finalDir.y /= mag; } }
        if (this.currentTactic && this.currentTactic !== 'adaptive') finalDir = this.executeTactic(finalDir, target, walls);
        if (networkOutputs?.length >= 14) { const neuralModX = Utils.tanh(networkOutputs[12] || 0) * 0.2, neuralModY = Utils.tanh(networkOutputs[13] || 0) * 0.2; finalDir.x = Utils.clamp(finalDir.x + neuralModX, -1, 1); finalDir.y = Utils.clamp(finalDir.y + neuralModY, -1, 1); const mag = Math.hypot(finalDir.x, finalDir.y) || 1; finalDir.x /= mag; finalDir.y /= mag; }
        const minSpeed = 0.3, actualSpeed = Math.max(speed, minSpeed);
        this.vx = Utils.lerp(this.vx, finalDir.x * actualSpeed, 0.15); this.vy = Utils.lerp(this.vy, finalDir.y * actualSpeed, 0.15);
        if (Math.abs(this.vx) < 0.02) this.vx = finalDir.x * minSpeed; if (Math.abs(this.vy) < 0.02) this.vy = finalDir.y * minSpeed;
        this.x += this.vx * dt; this.y += this.vy * dt;
        if (this.x < 20) { this.x = 20; this.vx *= -0.4; } if (this.x > 800) { this.x = 800; this.vx *= -0.4; }
        if (this.y < 20) { this.y = 20; this.vy *= -0.4; } if (this.y > 580) { this.y = 580; this.vy *= -0.4; }
        for (const w of walls) { if (Utils.dist(this, w) < 15) { const push = Utils.normalize(this.x - w.x, this.y - w.y); this.x += push.x * 0.6; this.y += push.y * 0.6; this.vx *= -0.25; this.vy *= -0.25; } }
    }
    
    executeTactic(direction, target, walls) {
        const tactic = this.currentTactic; let tacticDir = { ...direction };
        const enemies = (typeof window !== 'undefined' && window.arenaGame?.world?.enemies) ? window.arenaGame.world.enemies.filter(e => e && e.id !== this.id && e.alive) : [];
        if (enemies.length > 0) {
            const enemy = enemies[0], dist = Utils.dist(this, enemy);
            if (tactic === 'kite' && dist < 50) { const angle = Math.atan2(direction.y, direction.x) + Math.PI / 2; tacticDir = { x: Math.cos(angle) * 0.8, y: Math.sin(angle) * 0.8 }; }
            else if (tactic === 'dodge' && dist < 40) { const angle = Math.atan2(direction.y, direction.x) + (Math.random() > 0.5 ? 1 : -1) * Math.PI / 3; tacticDir = { x: Math.cos(angle), y: Math.sin(angle) }; }
            else if (tactic === 'defensive' && dist < 30) { const away = Utils.normalize(this.x - enemy.x, this.y - enemy.y); tacticDir = { x: away.x * 0.8, y: away.y * 0.8 }; }
            else if (dist < 25) { const away = Utils.normalize(this.x - enemy.x, this.y - enemy.y); tacticDir = { x: away.x, y: away.y }; }
        }
        const mag = Math.hypot(tacticDir.x, tacticDir.y) || 1; tacticDir.x /= mag; tacticDir.y /= mag;
        return tacticDir;
    }
    
    getWallRepulsion(walls) {
        let repulsion = { x: 0, y: 0 };
        for (const w of walls) { const d = Utils.dist(this, w); if (d < 40) { const force = (40 - d) / 40; const away = Utils.normalize(this.x - w.x, this.y - w.y); repulsion.x += away.x * force; repulsion.y += away.y * force; } }
        const mag = Math.hypot(repulsion.x, repulsion.y);
        return mag > 0 ? { x: repulsion.x / mag, y: repulsion.y / mag, strength: Utils.clamp(mag, 0, 1) } : { x: 0, y: 0, strength: 0 };
    }
    
    calculateReward(world, decision) {
        let reward = 0;
        for (const p of (world?.points || [])) { if (p && !p.collected) { const d = Utils.dist(this, p); if (d < 18) { p.collected = true; reward += p.value; } } }
        const veryNear = (world?.points || []).find(p => p && !p.collected && Utils.dist(this, p) < 10);
        if (veryNear) { veryNear.collected = true; reward += veryNear.value; }
        const newCell = `${Math.floor(this.x / 25)},${Math.floor(this.y / 25)}`;
        if (!this.permanent.memory.visited.has(newCell)) reward += 0.06;
        if (decision?.target) { const prevDist = Utils.dist(this.lastPos, decision.target), currDist = Utils.dist({ x: this.x, y: this.y }, decision.target); if (currDist < prevDist - 0.5) reward += 0.02; }
        const moved = Math.hypot(this.x - this.lastPos.x, this.y - this.lastPos.y);
        if (moved < 0.6) { this.stuckCounter++; if (this.stuckCounter > 15) reward -= 0.1; } else { this.stuckCounter = 0; }
        if (Math.min(this.x, 820 - this.x, this.y, 600 - this.y) < 12) reward -= 0.03;
        reward -= (1 - this.health / this.stats.maxHealth) * 0.12;
        this.lastPos = { x: this.x, y: this.y }; this.cumulativeReward += reward;
        return reward;
    }
    
    learn(reward, decision, nextInputs = null) {
        if (!decision || !arenaConfig.enableTraining) return;
        const currentValue = decision.value, nextValue = nextInputs ? this.critic.forward(nextInputs) : 0;
        const criticResult = this.critic.update(decision.inputs, reward, nextValue);
        const tdResult = this.net.tdLearn(decision.inputs, decision.output, reward, currentValue, nextValue, decision.modeProbs ? Utils.logSoftmax(decision.modeProbs.map(p => Math.log(Math.max(p, 1e-10)) * 10), 1) : null);
        this.net.updateDiagnostics({ win: null, collected: reward >= 5, survival: this.health / this.stats.maxHealth, reward });
        if (reward > 3 && arenaConfig.enableSkillEvolution) this.updatePermanentSkills(reward, decision.mode, arenaConfig.skillGrowthRate);
        if (reward > 4) this.updateMuscleMemory(decision.output, reward);
        this.learningBuffer.states.push(decision.inputs); this.learningBuffer.actions.push(decision.output);
        this.learningBuffer.rewards.push(reward); this.learningBuffer.values.push(currentValue);
        if (this.learningBuffer.states.length >= this.learningBuffer.maxBuffer) this._batchLearn();
    }
    
    _batchLearn() {
        if (!arenaConfig.enableTraining) { this._clearLearningBuffer(); return; }
        const advantages = Utils.computeGAE(this.learningBuffer.rewards, this.learningBuffer.values, 0, this.net.gamma, this.net.lambda);
        for (let t = 0; t < advantages.length; t++) {
            if (this.lastDecision?.modeProbs && arenaConfig.enablePolicySelector) {
                const modeIdx = ['hunt', 'flee', 'explore', 'combat', 'avoid'].indexOf(this.mode);
                if (modeIdx >= 0) {
                    const enemies = (this._lastWorld?.enemies || []).filter(e => e && e.id !== this.id && e.alive);
                    const context = [
                        enemies.length > 0 ? Utils.clamp(Utils.dist(this, enemies[0]) / 200, 0, 1) : 1,
                        (this._lastWorld?.walls || []).length ? Utils.clamp(Math.min(...this._lastWorld.walls.map(w => Utils.dist(this, w))) / 60, 0, 1) : 0,
                        this.health / this.stats.maxHealth,
                        Utils.clamp(Utils.safeNumber(this.lastDecision.output?.[5], 0.5), 0, 1),
                        Utils.clamp(Utils.safeNumber(this.lastDecision.output?.[6], 0.5), 0, 1),
                        Utils.clamp(Utils.safeNumber(this.lastDecision.output?.[7], 0.5), 0, 1),
                        this.permanent.skills.hunting, this.permanent.skills.fleeing
                    ];
                    this.policySelector.update(context, this.skillEmbedding, modeIdx, advantages[t]);
                }
            }
        }
        this._clearLearningBuffer();
    }
    
    _clearLearningBuffer() { this.learningBuffer = { states: [], actions: [], rewards: [], nextStates: [], dones: [], values: [], maxBuffer: 32 }; this._lastWorld = null; }
    
    updatePermanentSkills(reward, mode, skillGrowthRate) {
        if (reward <= 3 || !arenaConfig.enableSkillEvolution) return;
        const skillMap = { 'hunt': 'hunting', 'flee': 'fleeing', 'combat': 'combat', 'explore': 'exploring', 'avoid': 'avoiding' };
        const skillKey = skillMap[mode];
        if (skillKey && this.permanent.skills[skillKey] !== undefined) {
            const correlations = { hunting: { combat: 0.4, exploring: 0.2 }, combat: { hunting: 0.4, fleeing: -0.3 }, fleeing: { avoiding: 0.3, exploring: 0.1 }, exploring: { hunting: 0.2, avoiding: 0.1 }, avoiding: { fleeing: 0.3, exploring: 0.1 } };
            const growth = skillGrowthRate * reward * 0.1;
            this.permanent.skills[skillKey] = Utils.clamp(this.permanent.skills[skillKey] + growth, 0, 1);
            if (correlations[skillKey]) { for (const [related, corr] of Object.entries(correlations[skillKey])) { if (this.permanent.skills[related] !== undefined) { const relatedGrowth = growth * corr * 0.5; this.permanent.skills[related] = Utils.clamp(this.permanent.skills[related] + relatedGrowth, 0, 1); } } }
            this.skillEmbedding = [this.permanent.skills.hunting, this.permanent.skills.fleeing, this.permanent.skills.combat, this.permanent.skills.exploring, this.permanent.skills.avoiding];
        }
    }
    
    updateMuscleMemory(outputs, reward) {
        if (reward < 4) return;
        for (let i = 0; i < Math.min(16, outputs.length); i++) { const diff = Math.abs(outputs[i] - this.permanent.muscleMemory[i]); if (diff > 0.12 && Math.abs(outputs[i]) > 0.4) { this.permanent.muscleMemory[i] = Utils.lerp(this.permanent.muscleMemory[i], outputs[i], 0.06); } }
    }
    
    updatePredictiveMemory(world) {
        this.predictive.shortTerm.positions.push({ x: this.x, y: this.y });
        if (this.predictive.shortTerm.positions.length > 20) this.predictive.shortTerm.positions.shift();
        const enemies = (world?.enemies || []).filter(e => e && e.id !== this.id && e.alive);
        if (enemies.length > 0) {
            const enemy = enemies[0];
            this.predictive.shortTerm.enemyHistory.push({ x: enemy.x, y: enemy.y });
            if (this.predictive.shortTerm.enemyHistory.length > 5) this.predictive.shortTerm.enemyHistory.shift();
            const hist = this.predictive.shortTerm.enemyHistory;
            if (hist.length >= 2) { const [prev, last] = [hist[hist.length - 2], hist[hist.length - 1]]; const dx = last.x - prev.x, dy = last.y - prev.y; this.predictive.predictions.enemyPos = { x: last.x + dx * 0.75, y: last.y + dy * 0.75 }; const error = Utils.dist(enemy, this.predictive.predictions.enemyPos); this.predictive.predictionError = Utils.lerp(this.predictive.predictionError, error / 50, 0.1); const accuracy = Math.max(0, 1 - error / 100); this.predictive.confidence = Utils.lerp(this.predictive.confidence, accuracy, 0.05); }
        } else { this.predictive.confidence = Utils.lerp(this.predictive.confidence, 0.5, 0.02); }
        const nearbyFood = (world?.points || []).filter(p => p && !p.collected && Utils.dist(this, p) < 80);
        if (nearbyFood.length > 0) {
            const food = nearbyFood[0];
            this.predictive.shortTerm.foodHistory.push({ x: food.x, y: food.y });
            if (this.predictive.shortTerm.foodHistory.length > 3) this.predictive.shortTerm.foodHistory.shift();
            if (this.predictive.shortTerm.foodHistory.length >= 2) { const avgX = this.predictive.shortTerm.foodHistory.reduce((s, f) => s + f.x, 0) / this.predictive.shortTerm.foodHistory.length, avgY = this.predictive.shortTerm.foodHistory.reduce((s, f) => s + f.y, 0) / this.predictive.shortTerm.foodHistory.length; this.predictive.predictions.foodPos = { x: avgX, y: avgY }; }
        }
    }
    
    selectCombatTactic(enemyDistance, enemyHealth, myHealth, enemyPrediction) {
        if (enemyPrediction === 'fleeing') return 'aggressive';
        if (enemyPrediction === 'aggressive') return myHealth < 0.4 ? 'dodge' : 'kite';
        if (enemyHealth < 0.3) return 'aggressive';
        if (myHealth < 0.3) return 'defensive';
        if (enemyDistance < 20) return 'bait';
        return 'adaptive';
    }
    
    decideCombatAction(enemy, world) {
        const distance = Utils.dist(this, enemy);
        const prediction = this.enemyPredictor.predictNextAction();
        this.currentTactic = this.selectCombatTactic(distance, enemy.health / enemy.stats.maxHealth, this.health / this.stats.maxHealth, prediction);
        this.fightOpponent = enemy.id; this.fightStartTime = Date.now();
        return this.currentTactic;
    }
    
    getLearningMetrics() {
        return {
            avgTDError: this.net._trainingStats.tdErrorHistory.reduce((a,b)=>a+b,0)/Math.max(1,this.net._trainingStats.tdErrorHistory.length),
            avgPredictionError: Array.from(this.net._predictionErrors).reduce((a,b)=>a+b,0)/Math.max(1,this.net._predictionErrors.length),
            avgPolicyEntropy: this.net._trainingStats.policyEntropyHistory.reduce((a,b)=>a+b,0)/Math.max(1,this.net._trainingStats.policyEntropyHistory.length),
            winRate: this.net._trainingStats.winRate, collectionRate: this.net._trainingStats.collectionRate, survivalTime: this.net._trainingStats.survivalTime, totalSteps: this.net._trainingStats.totalSteps
        };
    }
    
    evolve(mutationRate = 0.1) {
        if (!arenaConfig.enableEvolution) return 0;
        const mutations = this.net.mutate(mutationRate, 0.15);
        if (this.critic?._W1) { this.critic._W1.forEach(row => { if (!row) return; row.forEach((v, i) => { if (this.net._rng.next() < mutationRate) { row[i] += (this.net._rng.next() * 2 - 1) * 0.15; row[i] = Utils.clamp(row[i], -2, 2); } }); }); }
        this.mutations += mutations; return mutations;
    }
    
    reset(x, y) {
        this.x = x; this.y = y; this.vx = 0; this.vy = 0; this.health = this.stats.maxHealth; this.stuckCounter = 0;
        this.lastPos = { x, y }; this.cumulativeReward = 0; this.mode = 'explore'; this.target = { x, y }; this.trail = [];
        this.predictive.confidence = 0.5; this.predictive.predictionError = 0; this.attackCooldown = 0;
        this._clearLearningBuffer();
        this.predictive.shortTerm = { positions: [], actions: [], results: [], enemyHistory: [], foodHistory: [] };
    }
    
    draw(ctx, showVision = false, showTrail = true) {
        if (showTrail && this.trail.length > 1) { ctx.beginPath(); ctx.moveTo(this.trail[0].x, this.trail[0].y); for (let i = 1; i < this.trail.length; i++) { const t = this.trail[i], alpha = 1 - t.age / 80; ctx.strokeStyle = this.color + Math.floor(alpha * 40).toString(16).padStart(2, '0'); ctx.lineTo(t.x, t.y); } ctx.stroke(); }
        let drawColor = this.color;
        if (this.lastMutationType === 'dmg') drawColor = '#ff4444';
        else if (this.lastMutationType === 'spd') drawColor = '#4444ff';
        else if (this.lastMutationType === 'hp') drawColor = '#44ff44';
        else if (this.lastMutationType === 'dod') drawColor = '#aa88ff';
        ctx.fillStyle = drawColor; ctx.beginPath(); ctx.arc(this.x, this.y, 11, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x + this.vx * 7, this.y + this.vy * 7); ctx.stroke();
        const modeColors = { hunt: '#00ff9d', flee: '#ff5577', explore: '#00d4ff', combat: '#ffaa00', avoid: '#aa88ff' };
        ctx.strokeStyle = modeColors[this.mode] || '#888'; ctx.lineWidth = 2.5; ctx.beginPath(); ctx.arc(this.x, this.y, 15, 0, Math.PI * 2); ctx.stroke();
        ctx.fillStyle = this.predictive.confidence > 0.7 ? '#00ff9d' : (this.predictive.confidence < 0.4 ? '#ff5577' : '#ffaa00'); ctx.beginPath(); ctx.arc(this.x + 14, this.y - 14, 3, 0, Math.PI * 2); ctx.fill();
        if (this.health < this.stats.maxHealth) { ctx.fillStyle = '#222'; ctx.fillRect(this.x - 14, this.y - 20, 28, 4); ctx.fillStyle = this.health > this.stats.maxHealth / 2 ? '#00ff9d' : '#ff5577'; ctx.fillRect(this.x - 14, this.y - 20, 28 * (this.health / this.stats.maxHealth), 4); }
        ctx.fillStyle = '#fff'; ctx.font = '9px monospace'; ctx.textAlign = 'center';
        ctx.fillText(`HP:${Math.round(this.stats.maxHealth)} DMG:${this.stats.damage}`, this.x, this.y - 25);
        ctx.fillText(`SPD:${this.stats.fireRate} DOD:${Math.round(this.stats.dodgeChance * 100)}%`, this.x, this.y - 16);
        ctx.textAlign = 'left';
        if (showVision && this.mode === 'hunt') { ctx.strokeStyle = 'rgba(0,255,157,0.25)'; ctx.fillStyle = 'rgba(0,255,157,0.08)'; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.arc(this.x, this.y, 70, Math.atan2(this.vy, this.vx) - 0.5, Math.atan2(this.vy, this.vx) + 0.5); ctx.closePath(); ctx.fill(); ctx.stroke(); }
        ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.setLineDash([4, 3]); ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.target.x, this.target.y); ctx.stroke(); ctx.setLineDash([]);
        if (this.trail.length === 0 || this.trail[this.trail.length - 1].age > 4) { this.trail.push({ x: this.x, y: this.y, age: 0 }); if (this.trail.length > 35) this.trail.shift(); }
        this.trail.forEach(t => t.age++);
    }
    
    getDebugInfo() {
        const metrics = this.getLearningMetrics();
        return {
            mode: this.mode, target: `${Math.round(this.target.x)},${Math.round(this.target.y)}`, speed: this.speed.toFixed(2),
            aggro: this.lastDecision?.behaviors?.aggression?.toFixed(2) || '‚Äî', memory: (this.permanent.memory.visited.size / 100).toFixed(2),
            neurons: this.net.getActiveNeurons().slice(0, 3).join(','), reward: this.cumulativeReward.toFixed(2), stuck: this.stuckCounter,
            confidence: this.predictive.confidence.toFixed(2), predError: metrics.avgPredictionError.toFixed(3),
            health: `${Math.round(this.health)}/${this.stats.maxHealth}`, mutations: this.mutations, generation: this.generation,
            tdError: metrics.avgTDError.toFixed(4), policyEntropy: metrics.avgPolicyEntropy.toFixed(3),
            winRate: metrics.winRate.toFixed(2), collectionRate: metrics.collectionRate.toFixed(2),
            gate0: this.net.getGateProbs()?.[0]?.toFixed(3) || '‚Äî', gate1: this.net.getGateProbs()?.[1]?.toFixed(3) || '‚Äî',
            expert0: this.net._lastGateProbs?.[0]?.toFixed(3) || '‚Äî', expert1: this.net._lastGateProbs?.[1]?.toFixed(3) || '‚Äî',
            loadBal: Utils.computeLoadBalance(this.net._lastGateProbs || []).toFixed(3),
            hebbian: arenaConfig.enableHebbian ? 'ON' : 'OFF'
        };
    }
    
    clone() {
        const agent = new Agent(this.id, this.x, this.y, this.color, this.seed + '_clone_' + Date.now());
        agent.net = this.net.clone(); agent.critic = this.critic.clone(); agent.policySelector = this.policySelector.clone();
        agent.experts = this.experts.map(e => e.clone());
        agent.health = this.health; agent.stats = { ...this.stats }; agent.lastMutationType = this.lastMutationType;
        agent.cumulativeReward = this.cumulativeReward; agent.wins = this.wins; agent.mutations = this.mutations; agent.generation = this.generation + 1;
        agent.permanent = { skills: { ...this.permanent.skills }, strategies: { ...this.permanent.strategies }, preferences: { ...this.permanent.preferences }, muscleMemory: new Float32Array(this.permanent.muscleMemory), memory: { lastFoodPos: this.permanent.memory.lastFoodPos ? { ...this.permanent.memory.lastFoodPos } : null, lastFoodStep: this.permanent.memory.lastFoodStep || 0, visited: new Set(this.permanent.memory.visited), unvisited: this.permanent.memory.unvisited.map(p => ({ ...p })) } };
        agent.predictive = { shortTerm: { positions: [], actions: [], results: [], enemyHistory: [], foodHistory: [] }, patterns: { enemyMovement: null, foodSpawn: null, dangerZones: new Map() }, predictions: { enemyPos: { x: 0, y: 0 }, foodPos: { x: 0, y: 0 }, collision: false, success: 0.5 }, confidence: this.predictive.confidence, predictionError: this.predictive.predictionError };
        agent.skillEmbedding = this.skillEmbedding.slice(); agent.attackCooldown = this.attackCooldown || 0;
        return agent;
    }
    
    toJSON() {
        return {
            id: this.id, seed: this.seed, x: this.x, y: this.y, health: this.health, stats: this.stats, lastMutationType: this.lastMutationType,
            cumulativeReward: this.cumulativeReward, wins: this.wins, mutations: this.mutations, generation: this.generation,
            net: this.net.toJSON(), critic: this.critic.toJSON(), policySelector: this.policySelector.toJSON(),
            experts: this.experts ? this.experts.map(e => e.toJSON()) : [],
            permanent: { skills: this.permanent.skills, strategies: this.permanent.strategies, preferences: this.permanent.preferences, muscleMemory: Array.from(this.permanent.muscleMemory), memory: { lastFoodPos: this.permanent.memory.lastFoodPos, lastFoodStep: this.permanent.memory.lastFoodStep, visited: Array.from(this.permanent.memory.visited).slice(0, 100), unvisited: this.permanent.memory.unvisited.slice(0, 30) } },
            predictive: { confidence: this.predictive.confidence, predictionError: this.predictive.predictionError },
            skillEmbedding: this.skillEmbedding.slice(),
            strategyMemory: { winningStrategies: this.strategyMemory.winningStrategies.slice(0, 5), fightHistory: this.strategyMemory.fightHistory },
            trainingStats: this.net._trainingStats
        };
    }
    
    static fromJSON(data, color) {
        const agent = new Agent(data.id, data.x, data.y, color, data.seed);
        agent.net = NeuralNetwork.fromJSON(data.net);
        if (data.critic) agent.critic = CriticNetwork.fromJSON(data.critic);
        if (data.policySelector) agent.policySelector = PolicySelector.fromJSON(data.policySelector);
        if (data.experts?.length) agent.experts = data.experts.map(e => NeuralNetwork.fromJSON(e));
        agent.health = data.health ?? 100; agent.stats = data.stats || { maxHealth: 100, damage: 3, fireRate: 15, dodgeChance: 0.0 };
        agent.lastMutationType = data.lastMutationType || null; agent.cumulativeReward = data.cumulativeReward ?? 0;
        agent.wins = data.wins ?? 0; agent.mutations = data.mutations ?? 0; agent.generation = data.generation ?? 1;
        if (data.permanent) {
            agent.permanent.skills = { ...(data.permanent.skills || agent.permanent.skills) };
            agent.permanent.strategies = { ...(data.permanent.strategies || agent.permanent.strategies) };
            agent.permanent.preferences = { ...(data.permanent.preferences || agent.permanent.preferences) };
            if (data.permanent.muscleMemory) agent.permanent.muscleMemory = new Float32Array(data.permanent.muscleMemory);
            if (data.permanent.memory) { agent.permanent.memory.lastFoodPos = data.permanent.memory.lastFoodPos; agent.permanent.memory.lastFoodStep = data.permanent.memory.lastFoodStep || 0; agent.permanent.memory.visited = new Set(data.permanent.memory.visited || []); agent.permanent.memory.unvisited = data.permanent.memory.unvisited || []; }
        }
        if (data.strategyMemory) { agent.strategyMemory.winningStrategies = data.strategyMemory.winningStrategies || []; agent.strategyMemory.fightHistory = data.strategyMemory.fightHistory || {}; }
        if (data.predictive) { agent.predictive.confidence = data.predictive.confidence ?? 0.5; agent.predictive.predictionError = data.predictive.predictionError ?? 0; }
        if (data.skillEmbedding) agent.skillEmbedding = data.skillEmbedding.slice();
        if (data.trainingStats) agent.net._trainingStats = { ...data.trainingStats };
        return agent;
    }
}

// ============================================================================
// WORLD ‚Äî SIMULATION ENVIRONMENT
// ============================================================================
class World {
    constructor(width, height) {
        this.logicalWidth = width; this.logicalHeight = height; this.step = 0; this.episode = 0;
        this.points = []; this.walls = []; this.enemies = []; this.projectiles = [];
    }
    
    reset() {
        this.step = 0; this.points = []; this.walls = [];
        for (let i = 0; i < 40; i++) this.points.push(new SmartPoint(35 + Utils.rand(0, 750), 35 + Utils.rand(0, 530), 'normal'));
        for (let i = 0; i < 8; i++) this.points.push(new SmartPoint(35 + Utils.rand(0, 750), 35 + Utils.rand(0, 530), 'scared'));
        for (let i = 0; i < 2; i++) this.points.push(new SmartPoint(35 + Utils.rand(0, 750), 35 + Utils.rand(0, 530), 'rare'));
        for (let i = 0; i < 12; i++) this.walls.push({ x: 60 + Utils.rand(0, 700), y: 60 + Utils.rand(0, 460) });
        this.projectiles = [];
    }
    
    spawnAgents() {
        try { this.enemies = [new Agent('blue', 120, 300, '#00d4ff', arenaConfig.seed + '_BLUE'), new Agent('red', 700, 300, '#ff5577', arenaConfig.seed + '_RED')]; }
        catch (e) { console.error('Failed to spawn agents:', e); this.enemies = []; }
    }
    
    update(dt) {
        this.step++;
        if (!this.enemies?.length || this.enemies.length < 2 || !this.enemies[0] || !this.enemies[1]) { console.error('World.update: Invalid agents array'); return { blue: null, red: null, pointsLeft: 0, episode: this.episode }; }
        
        const validEnemies = this.enemies.filter(e => e?.alive), nearestBlue = validEnemies.find(e => e?.id === 'blue') || validEnemies[0] || null, nearestRed = validEnemies.find(e => e?.id === 'red') || validEnemies[1] || null;
        for (const p of this.points) { if (!p) continue; const nearest = (!nearestBlue || !nearestRed) ? null : Utils.dist(p, nearestBlue) < Utils.dist(p, nearestRed) ? nearestBlue : nearestRed; p.update(nearest?.alive ? nearest : null, dt); }
        
        for (const agent of this.enemies) {
            if (!agent || !agent.alive) continue;
            const enemies = this.enemies.filter(e => e && e.id !== agent.id && e.alive);
            if (enemies.length > 0) { const enemy = enemies[0], distance = Utils.dist(agent, enemy); if (distance < 150) { agent.enemyPredictor.recordMove(agent.lastDecision?.behaviors || {}, distance, enemy.health / enemy.stats.maxHealth, agent.lastDecision?.behaviors?.aggression || 0.5); if (distance < 100) agent.decideCombatAction(enemy, this); } }
            const decision = agent.decide(this); agent.move(decision.target, decision.speed, this.walls, dt, decision.output);
            agent.attackCooldown = Math.max(0, (agent.attackCooldown || 0) - 1);
            if (arenaConfig.enableFighting) {
                const opponents = this.enemies.filter(e => e && e.id !== agent.id && e.alive);
                if (opponents.length > 0) {
                    const enemy = opponents[0], dist = Utils.dist(agent, enemy), range = agent.attackRange || 35;
                    if (dist <= range) {
                        if ((agent.attackCooldown || 0) <= 0) {
                            const aggression = agent.lastDecision?.behaviors?.aggression || 0.5, skill = agent.permanent?.skills?.combat || 0.3, baseDmg = agent.stats.damage, damage = Math.floor(Utils.clamp(baseDmg * (0.8 + aggression * 0.4) * (0.7 + skill * 0.6), 1, 10)), dodgeRoll = Math.random();
                            if (dodgeRoll < enemy.stats.dodgeChance) Logger.log(`üõ°Ô∏è ${enemy.id.toUpperCase()} —É–∫–ª–æ–Ω–∏–ª—Å—è!`, 'warn'); else { enemy.health -= damage; Logger.log(`${agent.id.toUpperCase()} ‚Üí ${enemy.id.toUpperCase()} -${damage} HP`, 'info'); }
                            agent.attackCooldown = agent.stats.fireRate;
                            if (enemy.health <= 0) { enemy.health = 0; enemy.alive = false; Logger.log(`üè≥Ô∏è ${enemy.id.toUpperCase()} –ø–æ–≤–µ—Ä–∂–µ–Ω ${agent.id.toUpperCase()}`, 'success'); }
                        }
                    } else if (arenaConfig.enableRanged && (agent.attackCooldown || 0) <= 0) {
                        const aggr = agent.lastDecision?.behaviors?.aggression || 0.4;
                        if (aggr > 0.3 && dist > 50 && dist < 200) {
                            const dir = Utils.normalize(enemy.x - agent.x, enemy.y - agent.y), speed = 10 + Math.random() * 4, dmg = Math.floor(Utils.clamp(agent.stats.damage * 0.5 * (0.8 + aggr * 0.8), 1, 5)), p = new Projectile(agent.x + dir.x * 12, agent.y + dir.y * 12, dir.x * speed, dir.y * speed, agent.id, dmg, 80);
                            this.projectiles.push(p); agent.attackCooldown = agent.stats.fireRate + 5; Logger.log(`${agent.id.toUpperCase()} —Å—Ç—Ä–µ–ª—è–µ—Ç –ø–æ ${enemy.id.toUpperCase()} (-${dmg} HP)`, 'info');
                        }
                    }
                }
            }
            const reward = agent.calculateReward(this, decision), nextInputs = agent.getInputs(this); agent.learn(reward, decision, nextInputs);
        }
        
        for (const p of this.projectiles) {
            if (!p?.alive) continue; p.update(dt);
            for (const w of this.walls) { if (Utils.dist(p, w) < 14 + p.radius) { p.alive = false; break; } }
            if (!p.alive) continue;
            for (const e of this.enemies) { if (!e || !e.alive || e.id === p.owner) continue; if (Utils.dist(p, e) < 15) { const dodgeRoll = Math.random(); if (dodgeRoll < e.stats.dodgeChance) Logger.log(`üõ°Ô∏è ${e.id.toUpperCase()} —É–∫–ª–æ–Ω–∏–ª—Å—è –æ—Ç –ø—É–ª–∏!`, 'warn'); else { e.health -= p.damage; Logger.log(`üéØ ${p.owner.toUpperCase()} ‚Üí ${e.id.toUpperCase()} -${p.damage} HP`, 'info'); } p.alive = false; if (e.health <= 0) { e.health = 0; e.alive = false; Logger.log(`üè≥Ô∏è ${e.id.toUpperCase()} —É–±–∏—Ç ${p.owner.toUpperCase()}`, 'success'); } break; } }
        }
        this.projectiles = this.projectiles.filter(p => p?.alive);
        
        const deadAgents = this.enemies.filter(a => a && !a.alive);
        if (deadAgents.length > 0) {
            this.episode++; Logger.log(`üìä –≠–ø–∏–∑–æ–¥ ${this.episode} –∑–∞–≤–µ—Ä—à–µ–Ω`, 'info');
            for (const agent of deadAgents) {
                const winner = this.enemies.find(e => e && e.id !== agent.id && e.alive);
                if (winner && arenaConfig.enableEvolution) {
                    if (!winner.net || !winner.experts?.length) { Logger.log(`‚ö†Ô∏è Winner ${winner.id} has invalid neural components`, 'warn'); continue; }
                    const accuracy = winner.wins / (winner.wins + 1);
                    if (winner.net._W1 && winner.strategyMemory) winner.strategyMemory.saveWinningStrategy(winner.net._W1, agent.id, winner.currentTactic || 'aggressive', accuracy);
                    winner.wins++; winner.net.updateDiagnostics({ win: true }); Logger.log(`üèÜ ${winner.id.toUpperCase()} –ø–æ–±–µ–¥–∏–ª! –¢–∞–∫—Ç–∏–∫–∞: ${winner.currentTactic || 'aggressive'}`, 'success');
                    try {
                        const idx = this.enemies.findIndex(e => e?.id === agent.id);
                        if (idx >= 0) {
                            if (!winner.net || !winner.experts?.length) { Logger.log(`‚ùå Cannot clone ${winner.id}: invalid components`, 'error'); continue; }
                            const child = winner.clone(); child.id = agent.id; child.seed = winner.seed + '_child_' + Date.now();
                            if (typeof child.net?.mutate === 'function') { const muts = child.net.mutate(arenaConfig.mutationRate || 0.08, 0.12); child.mutations += muts; }
                            const statKeys = ['maxHealth', 'damage', 'fireRate', 'dodgeChance'], randomStatIdx = Math.floor(Math.random() * 4), statToMutate = statKeys[randomStatIdx], mutationValue = Utils.randInt(1, 4);
                            if (statToMutate === 'maxHealth') child.stats.maxHealth += mutationValue * 10; else if (statToMutate === 'damage') child.stats.damage += mutationValue; else if (statToMutate === 'fireRate') child.stats.fireRate = Math.max(5, child.stats.fireRate - mutationValue); else if (statToMutate === 'dodgeChance') child.stats.dodgeChance = Math.min(0.5, child.stats.dodgeChance + mutationValue * 0.05);
                            child.lastMutationType = statToMutate; Logger.log(`üß¨ –ú–£–¢–ê–¶–ò–Ø: ${statToMutate} +${mutationValue} (Gen ${child.generation})`, 'success');
                            child.reset(agent.id === 'blue' ? 120 : 700, 300); child.alive = true; this.enemies[idx] = child;
                        }
                    } catch (e) { Logger.log('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–º–µ–Ω–µ –∞–≥–µ–Ω—Ç–∞: ' + e.message, 'error'); console.error('Full error:', e); }
                }
            }
        }
        
        const active = (this.points || []).filter(p => p && !p.collected).length;
        if (active < 22 && this.step % 40 === 0) { const types = ['normal', 'normal', 'normal', 'scared', 'rare']; this.points.push(new SmartPoint(35 + Utils.rand(0, 750), 35 + Utils.rand(0, 530), types[Utils.randInt(0, types.length - 1)])); }
        return { blue: this.enemies[0] || null, red: this.enemies[1] || null, pointsLeft: (this.points || []).filter(p => p && !p.collected).length, episode: this.episode };
    }
    
    resetEpisode() { this.points.forEach(p => { if (p) p.collected = false; }); this.enemies.forEach(a => { if (a) { a.reset(a.id === 'blue' ? 120 : 700, 300); a.alive = true; } }); Logger.log(`üîÑ –ù–æ–≤—ã–π —ç–ø–∏–∑–æ–¥ ${this.episode} –Ω–∞—á–∞–ª—Å—è`, 'info'); }
    
    draw(ctx, vision = false, trail = true) {
        if (!ctx) return; ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        const grad = ctx.createLinearGradient(0, 0, this.logicalWidth, this.logicalHeight); grad.addColorStop(0, '#0a0a15'); grad.addColorStop(1, '#1a1a2e'); ctx.fillStyle = grad; ctx.fillRect(0, 0, this.logicalWidth, this.logicalHeight);
        ctx.strokeStyle = 'rgba(50,50,90,0.25)'; ctx.lineWidth = 1;
        for (let x = 0; x < this.logicalWidth; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, this.logicalHeight); ctx.stroke(); }
        for (let y = 0; y < this.logicalHeight; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(this.logicalWidth, y); ctx.stroke(); }
        ctx.fillStyle = '#4a4a7a'; for (const w of this.walls) { ctx.beginPath(); ctx.arc(w.x, w.y, 14, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = '#6a6a9a'; ctx.lineWidth = 2; ctx.stroke(); }
        for (const p of this.points) { if (p) p.draw(ctx); }
        for (const pr of this.projectiles || []) { if (pr) pr.draw(ctx); }
        for (const a of this.enemies) { if (a) a.draw(ctx, vision, trail); }
        ctx.fillStyle = 'rgba(100,100,140,0.5)'; ctx.font = '10px monospace'; ctx.fillText(`Step: ${this.step} | Ep: ${this.episode}`, 12, this.logicalHeight - 12);
    }
}

// ============================================================================
// LOGGER ‚Äî SAFE CONSOLE OUTPUT
// ============================================================================
const Logger = Object.freeze({
    _escape: (str) => String(str).replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' }[m])),
    _truncate: (str, max = 180) => str.length > max ? str.slice(0, max) + '‚Ä¶' : str,
    log: (msg, type = 'info') => {
        const safeMsg = Logger._escape(Logger._truncate(msg)), safeType = ['info', 'success', 'warn', 'error', 'learning'].includes(type) ? type : 'info';
        const logEl = document.getElementById('eventLog');
        if (!logEl) { console.log(`[${safeType}] ${safeMsg}`); return; }
        const entry = document.createElement('div'); entry.className = `log-entry ${safeType}`; entry.textContent = `[${new Date().toLocaleTimeString()}] ${safeMsg}`;
        logEl.insertBefore(entry, logEl.firstChild); while (logEl.children.length > 60) logEl.removeChild(logEl.lastChild); logEl.scrollTop = 0;
    }
});

// ============================================================================
// GAME ENGINE ‚Äî MAIN CONTROLLER
// ============================================================================
class GameEngine {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        if (!this.canvas) { console.error('Canvas element not found'); alert('–û—à–∏–±–∫–∞: Canvas —ç–ª–µ–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω!'); return; }
        this.ctx = this.canvas.getContext('2d');
        if (!this.ctx) { console.error('Failed to get canvas context'); alert('–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç canvas!'); return; }
        this.settings = { ...arenaConfig };
        this.logicalWidth = arenaConfig.ARCH.LOGICAL_WIDTH; this.logicalHeight = arenaConfig.ARCH.LOGICAL_HEIGHT;
        this.resize(); this.scaleX = this.canvas.width / this.logicalWidth; this.scaleY = this.canvas.height / this.logicalHeight;
        this.world = new World(this.logicalWidth, this.logicalHeight);
        this.running = false; this.lastTime = 0; this.fps = 60; this.vision = false; this.debug = false; this.showMetrics = true;
        this.selectedAgent = null; this.rafId = null;
        this._onResize = this._onResize.bind(this); this._onClick = this._onClick.bind(this); this._onKey = this._onKey.bind(this);
        this.setupEvents(); this.init();
    }
    
    resize() { const parent = this.canvas?.parentElement; if (!parent) return; this.canvas.width = parent.clientWidth; this.canvas.height = parent.clientHeight; this.scaleX = this.canvas.width / this.logicalWidth; this.scaleY = this.canvas.height / this.logicalHeight; }
    _onResize() { this.resize(); }
    
    setupEvents() {
        window.addEventListener('resize', this._onResize);
        const handlePointer = (e) => { const rect = this.canvas.getBoundingClientRect(), scaleX = this.canvas.width / rect.width, scaleY = this.canvas.height / rect.height, clientX = e.touches?.[0]?.clientX ?? e.clientX, clientY = e.touches?.[0]?.clientY ?? e.clientY, x = (clientX - rect.left) * scaleX, y = (clientY - rect.top) * scaleY; this._onClick({ x, y }); };
        this.canvas.addEventListener('click', handlePointer); this.canvas.addEventListener('touchend', handlePointer); this.canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
        document.addEventListener('keydown', this._onKey); this.canvas.setAttribute('tabindex', '0'); this.canvas.setAttribute('role', 'application'); this.canvas.setAttribute('aria-label', 'AI Arena simulation canvas');
        const bindClick = (id, handler) => { const btn = document.getElementById(id); if (btn) btn.onclick = handler; };
        bindClick('btnStart', () => this.toggle()); bindClick('btnReset', () => this.reset()); bindClick('btnSave', () => this.save()); bindClick('btnLoad', () => this.load()); bindClick('btnExport', () => this.exportWeights());
        bindClick('btnImport', () => document.getElementById('fileImport')?.click()); bindClick('btnPretrain', () => document.getElementById('filePretrain')?.click());
        bindClick('btnDebug', () => this.toggleDebug()); bindClick('btnVision', () => { this.vision = !this.vision; this.updateBtns(); }); bindClick('btnMetrics', () => { this.showMetrics = !this.showMetrics; this.updateBtns(); });
        const fileImport = document.getElementById('fileImport'), filePretrain = document.getElementById('filePretrain');
        if (fileImport) fileImport.onchange = (e) => this.importWeights(e); if (filePretrain) filePretrain.onchange = (e) => this.importPretrained(e);
        const bindSlider = (id, key, displayId) => { const slider = document.getElementById(id), display = document.getElementById(displayId); if (!slider || !display) return; slider.oninput = (e) => { const value = parseFloat(e.target.value); this.settings[key] = value; display.textContent = value; if (this.world?.enemies) { this.world.enemies.forEach(a => { if (a?.net) { a.net.lr = this.settings.learningRate; a.net.lambda = this.settings.lambda; a.net.gamma = this.settings.gamma; a.net.entropyCoeff = this.settings.entropyCoeff; } if (a?.critic) a.critic.lr = this.settings.learningRate; if (a?.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6; }); } }; };
        bindSlider('learningRate', 'learningRate', 'learningRateValue'); bindSlider('lambda', 'lambda', 'lambdaValue'); bindSlider('gamma', 'gamma', 'gammaValue');
        bindSlider('entropyCoeff', 'entropyCoeff', 'entropyValue'); bindSlider('mutationRate', 'mutationRate', 'mutationRateValue'); bindSlider('skillGrowth', 'skillGrowthRate', 'skillGrowthValue');
        const bindToggle = (id, key) => { const toggle = document.getElementById(id); if (toggle) toggle.onchange = (e) => { this.settings[key] = e.target.checked; }; };
        bindToggle('enableTraining', 'enableTraining'); bindToggle('enableCritic', 'enableCritic'); bindToggle('enablePolicySelector', 'enablePolicySelector');
        bindToggle('enableEvolution', 'enableEvolution'); bindToggle('enableSkillEvolution', 'enableSkillEvolution'); bindToggle('enableMoE', 'enableMoE');
        bindToggle('enableConsolidation', 'enableConsolidation'); bindToggle('enableFighting', 'enableFighting'); bindToggle('enableRanged', 'enableRanged');
        bindToggle('enableVisualization', 'enableVisualization'); bindToggle('enableHebbian', 'enableHebbian');
    }
    
    _onKey(e) { if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault(); switch (e.key) { case ' ': e.preventDefault(); this.toggle(); break; case '1': this.selectedAgent = this.world?.enemies?.[0]; this.updateDebugPanel(); break; case '2': this.selectedAgent = this.world?.enemies?.[1]; this.updateDebugPanel(); break; case 'Tab': e.preventDefault(); const focusable = document.querySelectorAll('button, input, [tabindex="0"]'), idx = Array.from(focusable).indexOf(document.activeElement); focusable[(idx + 1) % focusable.length]?.focus(); break; case 'Escape': if (this.debug) { this.debug = false; this.updateDebugPanel(); } break; } }
    
    _onClick({ x, y }) { if (!this.debug) return; const lx = x / this.scaleX, ly = y / this.scaleY; let nearest = null, minD = 25; for (const a of this.world?.enemies || []) { if (!a) continue; const d = Math.hypot(a.x - lx, a.y - ly); if (d < minD) { minD = d; nearest = a; } } this.selectedAgent = nearest; if (nearest) Logger.log(`üîç –í—ã–±—Ä–∞–Ω –∞–≥–µ–Ω—Ç ${nearest.id}`, 'info'); this.updateDebugPanel(); }
    
    init() { this.world.reset(); this.world.spawnAgents(); if (!this.world.enemies?.length || this.world.enemies.length < 2) { console.error('Failed to initialize agents'); alert('–û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∞–≥–µ–Ω—Ç–æ–≤!'); return; } this.world.enemies.forEach(a => { if (!a) return; a.net.lr = this.settings.learningRate; a.net.lambda = this.settings.lambda; a.net.gamma = this.settings.gamma; if (a.critic) a.critic.lr = this.settings.learningRate; if (a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6; }); this.updateStats(); this.updateMetrics(); if (this.world.enemies[0] && this.world.enemies[1]) this.world.draw(this.ctx, false, true); Logger.log('üöÄ AI ARENA v4.0.1 PROFESSIONAL –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞', 'success'); Logger.log('üîß –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞: 57‚Üí24‚Üí48‚Üí36‚Üí16 + RNN(16) –ø–∞–º—è—Ç—å', 'success'); Logger.log('üß† –û–±—É—á–µ–Ω–∏–µ: TD(Œª)+Actor-Critic+LearnablePolicy+MoE+Hebbian', 'success'); Logger.log('üîë –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ—Ç –∫–ª—é—á–∞', 'success'); Logger.log('‚ö° –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏: –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ, spatial hashing, early-exit', 'success'); }
    
    toggle() { this.running = !this.running; const btn = document.getElementById('btnStart'); if (btn) { btn.textContent = this.running ? '‚è∏ –ü–∞—É–∑–∞' : '‚ñ∂ –°—Ç–∞—Ä—Ç'; btn.className = this.running ? 'btn-danger' : 'btn-primary'; btn.setAttribute('aria-pressed', String(this.running)); } Logger.log(this.running ? '‚ñ∂ –°–∏–º—É–ª—è—Ü–∏—è –∑–∞–ø—É—â–µ–Ω–∞' : '‚è∏ –ü–∞—É–∑–∞', 'info'); if (this.running) { this.lastTime = performance.now(); this.loop(); } }
    
    reset() { this.running = false; const btn = document.getElementById('btnStart'); if (btn) { btn.textContent = '‚ñ∂ –°—Ç–∞—Ä—Ç'; btn.className = 'btn-primary'; btn.setAttribute('aria-pressed', 'false'); } this.world = new World(this.logicalWidth, this.logicalHeight); this.world.reset(); this.world.spawnAgents(); this.world.enemies?.forEach(a => { if (!a) return; a.net.lr = this.settings.learningRate; a.net.lambda = this.settings.lambda; a.net.gamma = this.settings.gamma; if (a.critic) a.critic.lr = this.settings.learningRate; if (a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6; }); Logger.log('üîÑ –°–∏–º—É–ª—è—Ü–∏—è —Å–±—Ä–æ—à–µ–Ω–∞', 'warn'); this.updateStats(); this.updateMetrics(); }
    
    loop() { if (!this.running) return; if (!this.ctx || !this.world) { console.error('Context or world lost'); this.running = false; return; } if (!this.world.enemies?.length || this.world.enemies.length < 2 || !this.world.enemies[0] || !this.world.enemies[1]) { console.error('Invalid agents in world'); this.running = false; Logger.log('‚ùå –û—à–∏–±–∫–∞: –∞–≥–µ–Ω—Ç—ã –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –∏–ª–∏ –Ω–µ–≤–∞–ª–∏–¥–Ω—ã', 'error'); return; } const now = performance.now(), dt = Math.min((now - this.lastTime) / 16.67, 3), fps = Math.round(1000 / (now - this.lastTime + 0.001)); this.fps = fps; this.lastTime = now; const fpsEl = document.getElementById('fpsCounter'); if (fpsEl) fpsEl.textContent = `FPS: ${this.fps}`; try { const state = this.world.update(dt); this.world.draw(this.ctx, this.vision); this.updateStats(state); if (this.showMetrics) this.updateMetrics(); if (this.debug) this.updateDebugPanel(); } catch (e) { console.error('Loop error:', e); Logger.log(`‚ùå –û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ: ${e.message}`, 'error'); this.running = false; return; } this.rafId = requestAnimationFrame(() => this.loop()); }
    
    updateStats(state = null) { if (!state) { if (!this.world?.enemies?.length || this.world.enemies.length < 2 || !this.world.enemies[0] || !this.world.enemies[1]) return; state = { blue: this.world.enemies[0], red: this.world.enemies[1], pointsLeft: this.world.points?.filter(p => p && !p.collected).length || 0, episode: this.world.episode }; } const { blue, red, pointsLeft, episode } = state; if (!blue || !red) return; const blueHealthEl = document.getElementById('blue-health'), redHealthEl = document.getElementById('red-health'); if (blueHealthEl) { blueHealthEl.style.width = `${(blue.health / blue.stats.maxHealth) * 100}%`; blueHealthEl.setAttribute('aria-valuenow', String(Math.round(blue.health / blue.stats.maxHealth * 100))); } if (redHealthEl) { redHealthEl.style.width = `${(red.health / red.stats.maxHealth) * 100}%`; redHealthEl.setAttribute('aria-valuenow', String(Math.round(red.health / red.stats.maxHealth * 100))); } const blueRewardEl = document.getElementById('blue-reward'), redRewardEl = document.getElementById('red-reward'); if (blueRewardEl) blueRewardEl.textContent = blue.cumulativeReward.toFixed(2); if (redRewardEl) redRewardEl.textContent = red.cumulativeReward.toFixed(2); const updateMode = (el, mode) => { if (el) { el.className = `mode-badge mode-${mode}`; el.textContent = mode.toUpperCase(); } }; updateMode(document.getElementById('blue-mode'), blue.mode); updateMode(document.getElementById('red-mode'), red.mode); const blueWinsEl = document.getElementById('blue-wins'), redWinsEl = document.getElementById('red-wins'); if (blueWinsEl) blueWinsEl.textContent = blue.wins; if (redWinsEl) redWinsEl.textContent = red.wins; const blueGenEl = document.getElementById('blue-gen'), redGenEl = document.getElementById('red-gen'); if (blueGenEl) blueGenEl.textContent = blue.generation; if (redGenEl) redGenEl.textContent = red.generation; const episodeEl = document.getElementById('episodeStat'), stepEl = document.getElementById('stepStat'), dotsEl = document.getElementById('dotsStat'), obstaclesEl = document.getElementById('obstaclesStat'); if (episodeEl) episodeEl.textContent = episode; if (stepEl) stepEl.textContent = this.world.step; if (dotsEl) dotsEl.textContent = pointsLeft; if (obstaclesEl) obstaclesEl.textContent = this.world.walls.length; const avgFit = (blue.cumulativeReward + red.cumulativeReward) / 2, bestFit = Math.max(blue.cumulativeReward, red.cumulativeReward), fitnessEl = document.getElementById('fitnessStat'), bestFitnessEl = document.getElementById('bestFitnessStat'); if (fitnessEl) fitnessEl.textContent = avgFit.toFixed(1); if (bestFitnessEl) bestFitnessEl.textContent = bestFit.toFixed(1); const progressEl = document.getElementById('episodeProgress'); if (progressEl) { progressEl.style.width = `${(episode % 10) * 10}%`; progressEl.setAttribute('aria-valuenow', String((episode % 10) * 10)); } }
    
    updateMetrics() { if (!this.showMetrics || !this.world?.enemies?.length || this.world.enemies.length < 2 || !this.world.enemies[0] || !this.world.enemies[1]) return; const blue = this.world.enemies[0], red = this.world.enemies[1], blueMetrics = blue.getLearningMetrics(), redMetrics = red.getLearningMetrics(), avgTD = (blueMetrics.avgTDError + redMetrics.avgTDError) / 2, avgPred = (blueMetrics.avgPredictionError + redMetrics.avgPredictionError) / 2, avgEnt = (blueMetrics.avgPolicyEntropy + redMetrics.avgPolicyEntropy) / 2, avgWin = (blueMetrics.winRate + redMetrics.winRate) / 2, avgColl = (blueMetrics.collectionRate + redMetrics.collectionRate) / 2, avgSurv = (blueMetrics.survivalTime + redMetrics.survivalTime) / 2; const tdEl = document.getElementById('metricTDError'), predEl = document.getElementById('metricPredError'), entEl = document.getElementById('metricEntropy'), winEl = document.getElementById('metricWinRate'), collEl = document.getElementById('metricCollection'), survEl = document.getElementById('metricSurvival'); if (tdEl) { tdEl.textContent = avgTD.toFixed(4); tdEl.className = `metric-value${avgTD < 0.5 ? ' good' : avgTD > 2 ? ' degrading' : ''}`; } if (predEl) { predEl.textContent = avgPred.toFixed(3); predEl.className = `metric-value${avgPred < 0.3 ? ' good' : avgPred > 0.7 ? ' degrading' : ''}`; } if (entEl) { entEl.textContent = avgEnt.toFixed(3); entEl.className = `metric-value${avgEnt > 0.1 && avgEnt < 0.8 ? ' good' : ''}`; } if (winEl) winEl.textContent = avgWin.toFixed(2); if (collEl) collEl.textContent = avgColl.toFixed(2); if (survEl) survEl.textContent = avgSurv.toFixed(2); const progressTDEl = document.getElementById('progressTD'), progressEntropyEl = document.getElementById('progressEntropy'), progressPredEl = document.getElementById('progressPred'); if (progressTDEl) { const w = Utils.clamp(100 - avgTD * 20, 0, 100); progressTDEl.style.width = `${w}%`; progressTDEl.setAttribute('aria-valuenow', String(Math.round(w))); } if (progressEntropyEl) { const w = Utils.clamp(avgEnt * 100, 0, 100); progressEntropyEl.style.width = `${w}%`; progressEntropyEl.setAttribute('aria-valuenow', String(Math.round(w))); } if (progressPredEl) { const w = Utils.clamp(100 - avgPred * 100, 0, 100); progressPredEl.style.width = `${w}%`; progressPredEl.setAttribute('aria-valuenow', String(Math.round(w))); } }
    
    updateDebugPanel() { const panel = document.getElementById('debugPanel'), isActive = this.debug && this.selectedAgent; panel.classList.toggle('active', isActive); panel.hidden = !isActive; if (!isActive || !this.selectedAgent) return; const info = this.selectedAgent.getDebugInfo(), setDebugValue = (id, value) => { const el = document.getElementById(id); if (el) el.textContent = value; }; setDebugValue('dbgMode', info.mode); setDebugValue('dbgTarget', info.target); setDebugValue('dbgSpeed', info.speed); setDebugValue('dbgAggro', info.aggro); setDebugValue('dbgMemory', info.memory); setDebugValue('dbgNeurons', info.neurons); setDebugValue('dbgReward', info.reward); setDebugValue('dbgStuck', info.stuck); setDebugValue('dbgConf', info.confidence); setDebugValue('dbgTDErr', info.tdError); setDebugValue('dbgEntropy', info.policyEntropy); setDebugValue('dbgPredErr', info.predError); setDebugValue('dbgWinRate', info.winRate); setDebugValue('dbgCollection', info.collectionRate); setDebugValue('dbgGate0', info.gate0); setDebugValue('dbgGate1', info.gate1); setDebugValue('dbgExpert0', info.expert0); setDebugValue('dbgExpert1', info.expert1); setDebugValue('dbgLoadBal', info.loadBal); setDebugValue('dbgHebbian', info.hebbian); const confBar = document.getElementById('dbgConfBar'), confVal = document.getElementById('dbgConfVal'); if (confBar) { const w = (this.selectedAgent.predictive.confidence || 0.5) * 100; confBar.style.width = `${w}%`; confBar.setAttribute('aria-valuenow', String(Math.round(w))); } if (confVal) confVal.textContent = info.confidence; }
    
    toggleDebug() { this.debug = !this.debug; const btn = document.getElementById('btnDebug'); if (btn) { btn.classList.toggle('active', this.debug); btn.setAttribute('aria-pressed', String(this.debug)); } this.updateDebugPanel(); Logger.log(`üîç Debug ${this.debug ? '–≤–∫–ª—é—á—ë–Ω' : '–≤—ã–∫–ª—é—á–µ–Ω'}`, this.debug ? 'success' : 'info'); }
    updateBtns() { const visionBtn = document.getElementById('btnVision'), metricsBtn = document.getElementById('btnMetrics'); if (visionBtn) { visionBtn.classList.toggle('active', this.vision); visionBtn.setAttribute('aria-pressed', String(this.vision)); } if (metricsBtn) { metricsBtn.classList.toggle('active', this.showMetrics); metricsBtn.setAttribute('aria-pressed', String(this.showMetrics)); } }
    
    save() { try { const data = { version: '4.0.1', timestamp: Date.now(), settings: this.settings, world: { episode: this.world.episode, step: this.world.step, points: this.world.points.map(p => ({ x: p.x, y: p.y, type: p.type, collected: p.collected })), walls: this.world.walls.map(w => ({ x: w.x, y: w.y })) }, agents: this.world.enemies.map(a => a ? a.toJSON() : null).filter(a => a) }; localStorage.setItem('aiArenaV4Save', JSON.stringify(data)); Logger.log('üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ (v4.0.1 Professional)', 'success'); } catch (e) { if (e.name === 'QuotaExceededError') Logger.log('üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ: –ø—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç —Ö—Ä–∞–Ω–∏–ª–∏—â–∞', 'error'); else Logger.log(`‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: ${e.message}`, 'error'); } }
    
    load() { try { const raw = localStorage.getItem('aiArenaV4Save'); if (!raw) { Logger.log('‚ùå –ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–π v4.0.1', 'error'); return; } const data = JSON.parse(raw); if (data.version !== '4.0.1') { Logger.log('‚ö†Ô∏è –¢—Ä–µ–±—É–µ—Ç—Å—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ v4.0.1', 'warn'); return; } this.settings = { ...this.settings, ...data.settings }; document.getElementById('learningRate').value = this.settings.learningRate; document.getElementById('lambda').value = this.settings.lambda; document.getElementById('gamma').value = this.settings.gamma; document.getElementById('entropyCoeff').value = this.settings.entropyCoeff; document.getElementById('mutationRate').value = this.settings.mutationRate; document.getElementById('skillGrowth').value = this.settings.skillGrowthRate; document.getElementById('learningRateValue').textContent = this.settings.learningRate; document.getElementById('lambdaValue').textContent = this.settings.lambda; document.getElementById('gammaValue').textContent = this.settings.gamma; document.getElementById('entropyValue').textContent = this.settings.entropyCoeff; document.getElementById('mutationRateValue').textContent = this.settings.mutationRate; document.getElementById('skillGrowthValue').textContent = this.settings.skillGrowthRate; this.world.episode = data.world?.episode || 0; this.world.step = data.world?.step || 0; this.world.points = data.world?.points?.map(p => Object.assign(new SmartPoint(p.x, p.y, p.type), { collected: p.collected })) || []; this.world.walls = data.world?.walls || []; this.world.enemies = data.agents?.map((a, i) => a ? Agent.fromJSON(a, i === 0 ? '#00d4ff' : '#ff5577') : null).filter(a => a) || []; this.world.enemies.forEach(a => { if (!a) return; a.net.lr = this.settings.learningRate; a.net.lambda = this.settings.lambda; a.net.gamma = this.settings.gamma; if (a.critic) a.critic.lr = this.settings.learningRate; if (a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6; }); Logger.log('üìÇ –ó–∞–≥—Ä—É–∂–µ–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ v4.0.1', 'success'); this.updateStats({ blue: this.world.enemies[0], red: this.world.enemies[1], pointsLeft: this.world.points?.filter(p => p && !p.collected).length || 0, episode: this.world.episode }); this.updateMetrics(); } catch (e) { Logger.log(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ${e.message}`, 'error'); } }
    
    exportWeights() { try { const data = { version: '4.0.1', timestamp: Date.now(), blue: this.world.enemies[0]?.toJSON() || null, red: this.world.enemies[1]?.toJSON() || null }, blob = new Blob([JSON.stringify(data)], { type: 'application/json' }), url = URL.createObjectURL(blob), a = document.createElement('a'); a.href = url; a.download = `arena-v4.0.1-agents-${Date.now()}.json`; a.click(); URL.revokeObjectURL(url); Logger.log('üì§ –ê–≥–µ–Ω—Ç—ã —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã', 'success'); } catch (e) { Logger.log(`‚ùå –û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞: ${e.message}`, 'error'); } }
    
    importWeights(e) { const file = e.target.files?.[0]; if (!file) return; if (file.size > 10 * 1024 * 1024) { Logger.log('‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (–º–∞–∫—Å. 10MB)', 'error'); e.target.value = ''; return; } const reader = new FileReader(); reader.onload = (ev) => { try { const result = ev.target?.result; if (typeof result !== 'string') throw new Error('Invalid file content'); const data = JSON.parse(result); if (data.version !== '4.0.1') throw new Error('–¢—Ä–µ–±—É–µ—Ç—Å—è —Ñ–æ—Ä–º–∞—Ç v4.0.1'); if (!data.blue || !data.red) throw new Error('–ù–µ–≤–µ—Ä–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ñ–∞–π–ª–∞'); if (data.blue && this.world.enemies[0]) this.world.enemies[0] = Agent.fromJSON(data.blue, '#00d4ff'); if (data.red && this.world.enemies[1]) this.world.enemies[1] = Agent.fromJSON(data.red, '#ff5577'); this.world.enemies.forEach(a => { if (!a) return; a.net.lr = this.settings.learningRate; a.net.lambda = this.settings.lambda; a.net.gamma = this.settings.gamma; if (a.critic) a.critic.lr = this.settings.learningRate; if (a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6; }); Logger.log('üì• –ê–≥–µ–Ω—Ç—ã –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã', 'success'); } catch (err) { Logger.log(`‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: ${err.message}`, 'error'); } finally { e.target.value = ''; } }; reader.readAsText(file); }
    
    importPretrained(e) { const file = e.target.files?.[0]; if (!file) return; if (file.size > 10 * 1024 * 1024) { Logger.log('‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (–º–∞–∫—Å. 10MB)', 'error'); e.target.value = ''; return; } const reader = new FileReader(); reader.onload = (ev) => { try { const result = ev.target?.result; if (typeof result !== 'string') throw new Error('Invalid file content'); const data = JSON.parse(result); if (data.blue && this.world.enemies[0]) { const b = data.blue; if (b.net) this.world.enemies[0].net = NeuralNetwork.fromJSON(b.net); if (b.critic) this.world.enemies[0].critic = CriticNetwork.fromJSON(b.critic); if (b.policySelector) this.world.enemies[0].policySelector = PolicySelector.fromJSON(b.policySelector); } if (data.red && this.world.enemies[1]) { const r = data.red; if (r.net) this.world.enemies[1].net = NeuralNetwork.fromJSON(r.net); if (r.critic) this.world.enemies[1].critic = CriticNetwork.fromJSON(r.critic); if (r.policySelector) this.world.enemies[1].policySelector = PolicySelector.fromJSON(r.policySelector); } this.world.enemies.forEach(a => { if (!a) return; a.net.lr = this.settings.learningRate; a.net.lambda = this.settings.lambda; a.net.gamma = this.settings.gamma; if (a.critic) a.critic.lr = this.settings.learningRate; if (a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6; }); Logger.log('üì• Pretrained weights –∑–∞–≥—Ä—É–∂–µ–Ω—ã', 'success'); } catch (err) { Logger.log(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ pretrain: ${err.message}`, 'error'); } finally { e.target.value = ''; } }; reader.readAsText(file); }
    
    destroy() { if (this.rafId) { cancelAnimationFrame(this.rafId); this.rafId = null; } window.removeEventListener('resize', this._onResize); document.removeEventListener('keydown', this._onKey); if (this.canvas) { this.canvas.removeEventListener('click', this._onClick); this.canvas.removeEventListener('touchend', this._onClick); } this.running = false; }
}

// ============================================================================
// GLOBAL INITIALIZATION
// ============================================================================
/** @type {GameEngine|null} */
window.arenaGame = null;
if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initArena); else initArena();
function initArena() { try { window.arenaGame = new GameEngine(); if (window.arenaGame) console.log('‚úÖ AI Arena v4.0.1 initialized'); } catch (e) { console.error('‚ùå Failed to initialize AI Arena:', e); console.error('Stack:', e.stack); alert('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: ' + e.message); } }
window.addEventListener('beforeunload', () => { if (window.arenaGame) { window.arenaGame.destroy(); window.arenaGame = null; } });

// ============================================================================
// AUDIT VERIFICATION ‚Äî RUN ON LOAD
// ============================================================================
if (typeof window !== 'undefined') {
    window.addEventListener('load', () => {
        setTimeout(() => {
            try {
                // Verify attention matrix
                const nn = new NeuralNetwork({ seed: 'audit_test' });
                const h1 = new Array(48).fill(0).map((_, i) => Math.sin(i * 0.1));
                const attnResult = nn._selfAttention(h1);
                console.assert(attnResult.length === 48, 'Attention output dimension mismatch');
                console.assert(attnResult.every(v => isFinite(v)), 'Attention produced invalid values');
                
                // Verify expert connection
                const inputs = new Array(57).fill(0).map((_, i) => i * 0.01);
                const forwardResult = nn.forward(inputs);
                console.assert(forwardResult.gateProbs?.length === 4, 'Gate probs missing');
                console.assert(forwardResult.loadBalanceLoss !== undefined, 'Load balance loss missing');
                
                // Verify policy selector context
                const ps = new PolicySelector({ seed: 'audit_test' });
                const context = [0.5, 0.3, 0.8, 0.2, 0.6, 0.4, 0.7, 0.1];
                const skills = [0.3, 0.4, 0.2, 0.5, 0.6];
                const { probs } = ps.forward(context, skills);
                const policyResult = ps.update(context, skills, 2, 0.5);
                console.assert(policyResult.entropy !== undefined, 'Entropy not computed');
                console.assert(policyResult.loss !== undefined, 'Loss not returned');
                
                Logger.log('‚úÖ All audit fixes verified: attention, MoE, policy, Hebbian', 'success');
            } catch (e) {
                Logger.log(`‚ùå Audit verification failed: ${e.message}`, 'error');
            }
        }, 1000);
    });
}
</script>
</body>
</html>
